---
title: 计算机网络
---

---
title: 计网


---

## 模型架构

三种模型 分别是OSI TCP/IP 五层模型

> 为什么要设计不同的layer？

对于同一台设备的不同进程的通信，有很多方式 <font color = blue>管道，消息队列，信号，共享内存 </font>,  但是对于不同设备的进程间通信，就会使用到网络通信， 各种设备具有不同的特性，为了兼容，就协商出了一套通用的网络协议

网络的分层：

1. **模块化设计**：网络分层将整个网络系统分解为多个层次，每个层次都有特定的功能和责任。这种模块化设计使得网络结构更加清晰，降低了网络系统的复杂度，方便了系统的设计、开发和维护。
2. **标准化**：每个网络层次都有相应的标准和协议，定义了该层次的功能、数据格式、传输方式等规范。这些标准和协议使得不同厂商的网络设备和软件可以互相兼容和通信，促进了网络设备的互联互通。
3. **提高可靠性**：各层之间解耦合，由于每个层次都有明确的功能和责任，网络分层可以提高网络系统的可靠性。当一个层次出现问题时，只需修复该层次，而不会影响到其他层次，从而提高了网络系统的稳定性和可靠性。
4. **提高性能**：网络分层可以使网络通信过程更加高效。每个层次只需关注自己的功能和责任，而不需要关心其他层次的具体实现细节，从而提高了网络通信的效率。
5. **降低成本**：网络分层可以将网络系统分解为多个相对独立的模块，降低了系统设计、开发和维护的成本。此外，通过使用标准化的协议和技术，可以降低网络设备和软件的开发成本，提高了网络系统的经济效益。

### TCP/IP 网络模型

#### 应用层

进程需要通信时，就把数据传给下一层，应用层只需要关注为用户提供功能，如HTPTP，FTP，Telnet，DNS, SMTP;

应用层不关心怎么传输，只负责把数据给传输层

工作在用户态



#### 传输层

应用层的数据包会给传输层，传输层负责给应用层提供服务

##### 两个协议TCP和UDP

Transmission Control Protocol, 大部分应用使用的都是传输控制协议TCP，如HTTP，TCP面向连接，多了很多特性，保证可靠的交付，UDP不保证可靠交付，但是传输效率较高

> 要实现可靠的UDP也可以，只需要在UDP上把TCP的特性实现一遍就行了，拥塞控制，流量控制，超时重传...



要传输的数据可能很大，直接传不太方便，所以需要对数据包进行分块，TCP传输的数据是报文段，传输的数据大小超过了MSS（TCP最大报文段长度），就需要对数据包分块，这样即使有一个包丢失了，只需要重传丢失的即可。



传输层在接收方需要干的事情就是 负责处理下层送上的数据，去掉之前加上的头部，顺序重组，校验和... 然后上传给应用层

> 如何区分是哪个应用呢？端口号
>
> 80 web服务器使用的端口号，22 ssh服务使用的端口号...



#### 网络层

传输层只负责传输过程的一些预处理，但实际上并不负责传输

实际上的网络环境十分复杂，有非常多的节点和设备，需要进行路径和节点的选择，这部分交给传输层做就有点冗余了，因此把这一部分分出来给网络层做，进一步解耦。

网络层最常使用的就是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP头部组成IP报文，如果IP报文超过了MTU（1500 bytes normally），就再次分段，得到一个IP报文段。



> 网络层负责将数据传输到另外一个设备，世界上这么多设备，如何找到对方呢？网络层需要有 区分不同设备的编号 -> <mark background-color="yellow">IP</mark>



网络号 主机号 子网掩码

在寻址过程中，先找到对应的网络号（先找到学校），再去找主机号（在找对应的人）

除了寻址，网络层还有一件事情就是路由，数据传输过程中，并不是一条网线走到黑，而是需要经过一系列的节点（交换机，路由器，转发），所以网络层需要通过路由算法来决定下一步走哪个节点

IP协议告诉你要去哪里，路由告诉你下一跳该去哪，一个是大局，一个是细节



#### 网络接口层

加上了IP头部之后，交给网络接口层，在头部再加上MAC头部，封装成一个数据帧发送到网络上



IP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们就可以知道这个包要去哪，但是在以太网的世界中，是行不通的，

以太网是一种在局域网内将附近的设备连接起来进行通信的技术。以太网在区分设备的时候是通过MAC地址判断的，MAC就是设备网卡的硬件地址，出厂时唯一设定，



MAC头部是以太网使用的头部，包含接收方和发送方的MAC地址信息，可以通过ARP协议获取MAC地址，



网络接口层为网络提供 **链路级别** 传输的服务，负责在以太网，WIFI这样的底层网络上发送数据包，工作在网卡这个层次，使用MAC地址来标识网络设备

| 层级        | 地址类型 | 功能                       |
| ----------- | -------- | -------------------------- |
| 网络层 (IP) | IP地址   | 在网络中唯一标识设备       |
| 数据链路层  | MAC地址  | 在同一局域网内唯一标识设备 |





#### 总结

**上至下**

|   layer    | 数据包格式 |              处理操作               |
| :--------: | :--------: | :---------------------------------: |
|   应用层   |   数据包   |                 无                  |
|   传输层   |   报文段   |   加上TCP头（校验和，ack，syn等等   |
|   网络层   |   ip报文   |  加上ip头，加入目标地址ip原地址ip   |
| 网络接口层 |   MAC帧    | 加上mac头，下一跳mac地址，帧头 帧尾 |
|   物理层   |  01比特流  |                                     |



**下至上**

|   layer    | 数据包格式 |                           处理操作                           |
| :--------: | :--------: | :----------------------------------------------------------: |
|   应用层   |   数据包   |                           处理数据                           |
|   传输层   |   报文段   | 去掉TCP头，按照序号重组，验证校验和... 发送给对应应用层端口号 |
|   网络层   |   ip报文   |                   去掉IP头尾 发送到上一层                    |
| 网络接口层 |   MAC帧    |                 去掉mac帧 头尾，发送到上一层                 |
|   物理层   |  01比特流  |                                                              |





### 输入url点击回车，发送了什么？

#### HTTP (Hypertext Transfer Protocol)

首先要做解析 URL，从而生成发送给web服务器的请求信息

http://web-server/dir/file.html

| 协议名字 | 分隔符 | 服务器名字 | 目录名 | ...  | 文件名    |
| -------- | ------ | ---------- | ------ | ---- | --------- |
| http     | //     | web-server | dir    |      | file.html |
| https    |        |            |        |      |           |



Web-server : /-  <font color = "blue">根目录</font>

​			|-dir1

​			|-dir2

​			|-dir3- file.html	

当没有指定文件的时候，返回的是根目录下的默认文件



对url进行解析之后，浏览器确定了服务器和文件名以及对应的协议， 根据这些信息就可以生成HTTP请求消息了。



#### DNS （Domain Name System） 地址解析协议

web-server 一般是一个 域名 如 www.baidu.com = www.baidu.com. ，但是网络中的地址是IP地址，如何通过域名得到IP？ -> DNS 协议

在域名中，**越靠右**的位置表示其层级**越高**。

域名使用. 来分隔，实际上域名最后还有一个点. 表示根域名，根域名 <mark background-color = "yellow"> . </mark> ，顶级域名 <mark background-color="red">.com</mark> , 

域名的层级关系类似一颗树

- 根DNS服务器 .
- 顶级域DNS服务器 .com
- 权威DNS服务器 Baidu.com

---

域名解析的工作流程

1. 客户端首先发起一个DNS请求，问www.server.com的ip是什么，并且发送给本地的DNS服务器（也就是客户端TCP/IP设置中填写的DNS服务器地址，如114.114.114.114
2. 本地域名服务器收到客户端的请求之后，如果缓存有www.server.com的记录，就直接返回，如果没有，本地DNS会去询问他的根域名服务器，根具有所有域名的IP，但并不能直接告诉，只能指路
3. 根DNS收到本地请求之后，发现有.com ,于是回复 这个事情归小弟 .com顶级域名服务器管理，你去问他吧
4. 本地DNS收到了根返回的  .com顶级域名服务器 地址， 于是向他询问
5. 顶级域com服务器 回复 给 负责www.server.com区域的权威DNS地址
6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。



> 是否每次解析域名都要经过这么复杂的步骤？

这个时候缓存就发挥作用了，如果***浏览器自身***有这个域名对应的缓存，就直接返回，没有的话就去问***操作系统的缓存***，还没有就去***hosts文件***查看，再没有才去问***DNS服务器***



<font color = "blue"> 现在已经获得目的计算机的IP了，接下来数据包要怎么做呢？</font>

#### 协议栈

获得目的IP之后，就可以吧HTTP的传输工作交给操作系统的协议栈

协议栈分为几个部分，分别承担不同的工作，上面负责委托下面工作，下面负责为上面提供服务

> GPT: 协议栈（Protocol Stack）是指在计算机网络中，一组按照层次结构组织的网络协议的集合。这些协议按照功能和责任被分成不同的层次，每一层都负责执行特定的功能，从物理层到应用层依次排列。协议栈的每一层都建立在下一层的基础上，并为上一层提供服务。

应用程序 通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP

下半部分是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

此外 IP 中还包括 `ICMP` 协议和 `ARP` 协议。

- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。



IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作

#### TCP

TCP协议 可靠传输



#### IP



#### MAC



#### 网卡



#### 交换机



#### 路由器





## HTTP

### HTTP基本概念

#### HTTP是什么？

HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。

##### 协议

HTTP是一个用在计算机世界里的协议， 它确定了一种计算机之间<font color = "blue">交流与通信的规范</font>，以及相关的<font color="red">各种控制和错误处理方式</font>

##### 传输

HTTP是一个双向协议，也就是A - B 之间的传输，数据虽然是在AB之间传输，但是运行中间有中转和接力，只需要中间人也满足HTTP协议，不打扰正常的数据传输，可以添加任意额外的东西

HTTP 是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范。

##### 超文本

HTTP 传输的内容是「超文本」。

我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。

再来理解「超文本」，它就是**超越了普通文本的文本**，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。

HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。



<mark background-color = "yellow">**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」** </mark>

#### HTTP常见的状态码

<font color="blue">1xx</font> 提示信息，表示目前是协议处理的中间状态，还需要后续处理，实际用到的比较少



<font color="blue">2xx</font> 表示服务器成功处理了客户端的请求

- 「**200 OK**」 最常见的成功状态码，表示一切正常，如果是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

<font color="blue">3xx</font>  状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

<font color="blue">4xx </font> 表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

<font color="blue">5xx </font> 表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

 

#### HTTP常见字段



### HTTP1.0

短连接

### HTTP1.1

实现了长连接

优点：

- 简单：` header+body `, 头部信息也是`key-value`的简单格式

- 灵活和易于扩展

- 应用广泛和跨平台

缺点：

- 无状态
- 明文传输
- 不安全

#### 特性

##### 长连接

##### 管道网络传输 

不是默认开启， 并且浏览器基本没有支持

##### 队头堵塞



##### Http1.1 断点续传

1、客户端发起请求，并在请求包含Range字段：**Range：bytes=start-end**

2、服务器收到请求之后，返回指定范围的数据，响应状态码为206，表示部分内容成功返回 响应字段有Content-Range: bytes 0-499/22400 返回数据的范围和接数据总的大小；

3、客户端收到部分响应之后，保存到本地的临时文件中，并且继续请求

4、下载完成之后，客户端将文件合并到最终的文件，从而实现整个文件的下载



此外 因为服务器上的数据可能会被更改，所以需要断点续传需要判断是否发生过更改 if_modified ETag  ..



#### 性能瓶颈

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；

- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；

- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；

- 没有请求优先级控制；

- 请求只能从客户端开始，服务器只能被动响应。

  

### HTTP2.0

基于HTTPS实现，HTTP是明文传输 所以在安全上有以下三个问题：

> 窃听风险：明文可以直接被其他人看到
>
> 篡改风险：明文容易被直接修改内容
>
> 冒充风险：容易被冒充服务端



HTTP<font color='blue'>**S**</font>，在HTTP于TCP层之间加入了`SSL/TLS`协议，可以解决上述的风险：

- 信息加密:  信息加密 无法破解 <font color='blue'>混合加密 = > 机密性 </font>
- 校验机制：保证内容是没被修改过的  <font color='blue'>摘要算法 => 完整性</font>
- 数字身份证书：保证和你通信的对端是server端  <font color='blue'>数字证书=> "唯一性"</font>



#### HTTPS 

默认端口 ***443***

消息机密性  通过混合加密的方式

消息完整性  摘要算法保证消息的完整性（hash值）

身份认证 数字证书CA认证

##### 1、混合加密

非对称加密：加密解密效率高，但是需要交换密钥，容易被截获

常用的有RSA，DSA，ECC，DH

对称加密：加密解密效率低，但是相对安全

常用的有AES，DES，IDEA... 

> 私钥加密 公钥解密 -> 保证消息不会被冒充，因私钥是不可泄漏的，能解密出来合法的消息说明发送方也是合法的
>
> 公钥加密 私钥揭秘 -> 内容只有一个人（持有私钥）可以破译 保证消息机密

结合二者的优点 =》 **混合加密**

- 在通信建立阶段使用非对称加密的方法进行  `会话密钥`  交换，

- 通信过程中使用对称加密的  `会话密钥`  加密明文数据进行通信



##### 2、摘要算法 + 数字签名

为了保证数据的完整性，需要针对内容计算一个「指纹」,然后和内容一起传输

对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。



那么，在计算机里会**用摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。

通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**



所以非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。



##### 3、数字证书

已经解决了完整性和机密性，但是还不够，但是这还远远不够，**还缺少身份验证的环节**，万一公钥是被伪造的呢？



因此需要一个权威机构来认证服务器分发公钥的合法性，在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<font color='blue'> 数字证书 = 服务器公钥 + CA的数字签名 </font>+ 一些信息

> CA 会使用自己的<font color='blue'>私钥</font>将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；



##### HTTPS 如何建立连接？

SSL/TLS 协议基本流程：”Secure Sockets Layer" / "Transport Layer Security"

- 客户端向服务器所要数字证书，验证公钥
- 双方协商产生  `会话密钥`
- 使用  `会话密钥`  通信

TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_rsa.html)和 [ECDHE 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_ecdhe.html)。

具体的四次握手 略

证书的验证过程中**还存在一个证书信任链的问题** 

最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？

**这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题**



##### HTTPS 的应用数据是如何保证完整性的？

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，具体过程如下：

- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

##### HTTPS一定安全可靠吗？

理论上是可靠的，只要用户不擅自信任未知来源的网站



客户端 --- 中间人 ---- 服务器

解决中间人转发的问题 HTTPS双向认证，加上服务器对客户端的认证，服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。



#### 特性

##### 1、头部压缩

压缩头部，如果同时发出多个请求，头是一样的，协议会消除重复的部分 HPAC算法



##### 2、二进制格式

不像HTTP1.1 是纯文本格式，采用的二进制，统称为帧，头和body 都是二进制，对计算机友好，直接解析二进制报文，增加了数据传输的效率



##### 3、并发传输

引入了stream概念，多个stream复用在一个TCP连接，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。

<font color='blue'>解决了队头堵塞的问题</font>



##### 4、服务器推送

client和server都可以建立stream <font color='blue'>客户端建立的stream必须是奇数， server必须是偶数</font>

奇数steam 传输客户端向服务器请求的资源，偶数stream传输服务器主动推动的资源

<font color=blue>但是如果需要频繁推送资源 就需要使用Websocket了</font>



#### 缺陷

HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。



也就是内核接收到的数据包如果乱序或者丢包了，那么这个数据报就会被卡在内核，直到数据全部到齐，TCP重组成功再返回给应用层，<font color='blue'>也就是HTTP2.0是由于采用的TCP协议堵塞在内核里面的！</font>

### HTTP3.0

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输



#### 特性

##### 1、无队头堵塞

QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。 再加上 协议更换成了UDP，内核层面的堵塞也没有了，所以没有队头堵塞

##### 2、更快的连接建立

对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。

HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。

但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，

##### 3、连接迁移

基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。

那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。

而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。



#### 缺陷

有待普及

### HTTP版本总结

|      | http 1.0                              | http 1.1                                                     | http 2.0                                                     | http 3.0                                                    |
| ---- | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------------- |
| 改进 |                                       | 1、更改为长连接  2、增加了管道机制，允许请求端一次性发送多个请求3、支持断点续传4、支持先发送header而不发送body，先用header判断是否成功，再发送数据，节约带宽 | 1、基于HTTP S，安全性有保障 2、头部压缩 3、二进制格式 3、并发传输 4、服务器主动推送资源 | TCP改成了UDP QUIC协议来保证可靠传输 更快的连接建立 连接迁移 |
| 缺陷 | 短连接，每次重复连接TCP带来的性能开销 | 1、首部不能压缩，只能压缩body，导致冗余，2、头部冗长，每次都要发送冗长的头部效率较低 3、server端只能按照请求顺序响应，会有队头堵塞问题 4、没有请求优先级控制 5、请求只能从客户端开始，服务器只能被动响应 | 通过stream的并发能力，不同的请求可以使用不同的stream ID来发送解决了队头堵塞的问题，但是只解决了HTTP的队头堵塞，TCP的“队头堵塞“还没有解决：发生丢包x则x+1之后的数据会被堵塞在内核直到包x重传 | 尚未普及                                                    |

SSL/TLS  Secure Sockets Layer / Transport Layer security







### HTTP缓存技术

##### 为什么需要缓存？

如果每次向服务器请求的响应都是一样的，那么就没必要向服务器请求响应，只需要由浏览器缓存下来，然后判断缓存是否可用，直接处理即可

##### 强制缓存

只要浏览器判断缓存没有过期，直接使用本地缓存，<font color='blue'>决定是否使用缓存的主动性在浏览器这边</font>

HTTP响应头部使用 **Cache-Control** 相对时间   ， **Expires** 绝对时间 两个字段来实现

如果同时有两个字段 ，**前者优先级高**

Cache-control <font color='red'>选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存</font>。具体的实现流程如下：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

##### 协商缓存

某些请求的响应码是304， 这就是服务器在告诉浏览器可以使用本地缓存的资源，<font color='blue'>这种服务器通知客户端可以使用本地缓存的方式-> 协商缓存</font>

###### 实现方式1 **请求头中的If-Modified-Sincce + 响应头的Last-Modified**

响应头的Last-Modified：标识这个响应资源的最后修改时间

请求头中的If-Modified-Sincce ： 

- 当资源过期了，发现响应头有Last-Modified，则再次请求的时候带上Last-Modified，(If-Modified-Since = Last-Modified)
-  服务器收到请求后发现有If-Modified-Since字段与资源的最后修改时间(Last-Modified)对比
- 如果Last-Modified大（更新），返回最新资源 HTTP200 OK
- 如果Last-Modified小（更旧），资源无修改，返回HTTP 304 走缓存

###### 实现方式2 **请求头中的If-None+Match + 响应头的Etag**

<font color='blue'>这种方法的优先级更高</font>

> 因为ETag 主要能解决 Last-Modified 几个比较难以解决的问题：
>
> 1、在没有修改文件内容的时候，修改时间可能也会变，比如touch命令，导致客户端还是需要重新请求资源响应
>
> 2、有些文件实在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次
>
> 3、有些服务器不能精确获取文件最后的修改时间



响应头部中的Etag：响应资源的唯一标识

请求头部中的If-None-Match：

- 当资源过期的时候，发现响应头里面有Etag，则再次发起请求的时候，就把If-None-Match的值设置为Etag的值
- 服务器收到请求之后比对，如果资源更改返回HTTP 200 ok
- 没有更改返回 HTTP 304

##### 总结

​	协商缓存这两个字段都需要配合强制缓存中的`Cache-Control`来使用，只有未能命中强制缓存，才能发起带有协商缓存字段的请求。

也即是：

<font color='green'>浏览器请求->是否有缓存-> Cache-Control是否过期-> 是否有Etag ->是否有Last-Modified </font>









什么是同步和异步？



## 负载均衡

#### 普通哈希

对客户端的IP+port 进行哈希 ，然后的得到的 值 对服务器集群的数量进行取模， 也就是hash(ip+port) % num, 即可得到由哪台服务器提供服务

问题：一旦要对 服务器集群进行扩容和缩容，就会出现原有的**哈希映射失效，数据需要重新分配**，在集群数量比较多的时候，这是非常繁琐麻烦的



#### 一致性哈希

Hash(ip+port) % 2^32 对固定的数字取模，而不是对服务器集群的数量取模，

两个步骤：1、 先对 集群服务器的每个节点（IP）做一次哈希，然后可以得到这个节点在**哈希环**上的位置

​		    2、 客户端发起请求， 进行哈希，然后在哈希环上顺时针遇到的第一个节点就是提供服务的节点



问题：当需要缩容的时候，需要缩容的节点可能在哈希环上是很多客户端选择的节点，把这个服务器节点A从哈希环上去掉，就会发生 这个A顺时针往下的一个节点B突然接收到A所负责的这部分请求，从而导致B崩溃





#### 虚拟节点

在哈希环上引入虚拟节点， A-01，A-02，A-03， B-01，B-02，B-03，C-01，C-02，C-03，遇到虚拟节点的就会去找虚拟节点对应的真实节点， 虚拟节点在哈希环上是均匀分布的

当A服务器要下线的时候，A的虚拟节点承载的请求会被均衡分配到BC的虚拟节点，也就是分给不同的服务器处理而不是一致性哈希只给一台服务器处理，这样就**分散了压力**

