---
title: KMP 专题
---

### 什么是KMP

说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。

因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

### KMP有什么用

KMP主要应用在字符串匹配上。

KMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**





### 什么是前缀表

用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配

那么前缀表：记录下标 i 之前（包括i）的字符串中，有多大长度的相同前缀后缀

> 比如模式串 aabaaf ，f的位置的最长前缀后缀就是2

前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力，

#### 最长相等前后缀

字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。

**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。



所以例子 **a a b a a f**的 前缀表是

​		**0 1 0 1 2 0**



#### 前缀表与next数组

**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**





### 如何构造next数组

使用函数遍历一遍模式串从而得到next数组

这是统一 -1 的next数组

**i指向后缀末尾位置**

**j指向前缀末尾位置**

```c++
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

next[i]表示i(包括i)之前最长相等的前后缀长度（其实就是j）



使用next数组，用模式串匹配文本串的代码

```c++
//先调用 getNext函数获取前缀表
// j 是 当前已经得到 匹配的地方在模版串的 位置下标
// -1 表示还没得到匹配
int j = -1; // 因为next数组里记录的起始位置为-1
for (int i = 0; i < s.size(); i++) { // 注意i就从0开始，因这里的s是文本串
    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配 
        j = next[j]; // j 寻找之前匹配的位置
    }
    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
        j++; // i的增加在for循环里
    }
    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
        return (i - t.size() + 1);
    }
}
```



### 时间复杂度分析

使用next数组对文本串和模式串进行匹配的时候，文本串是从前往后遍历的，遍历到最后就可以得到结果

所以时间复杂度为 遍历一次 文本串和模式串的时间 为 <font color = 'blue'>o(m+n);</font>

如果是暴力匹配 则是 <font color = 'red'>o(m * n);</font>

