---
title: mhy8.3 笔试回顾
categories:
- 面试笔试记录
tag:
- 流水线
- 排序
- 异常处理
- TCP UDP
- 面试 && 笔试
---
mhy8.3 笔试回顾

## 选择题

###  流水线的执行时间计算

> 有8个磁盘块需要处理，现在有一个缓存大小和一个磁盘块一样，磁盘块搬移到缓存需要80ms， 缓存搬移到cpu需要40ms，cpu处理这个磁盘块的数据需要60ms，流水线架构需要多长时间完成？
>
> 如果换成双缓存，需要多长时间？

![](https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/202408040053939.png)

所以答案是 (80 + 40) * 8 + 60  = 1020 ms



如果是双缓冲的话是多少呢？

![](https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804005551.png) 

所以答案是 80 * 8 + 40 + 60 = 740 ms



总结

 把图画出来 分析清楚各个stage如何链接就可以了

流水线的思想就是 一个过程如果可以被划分成实际的多个小过程，就可以使用流水线，使得每个模块都尽量不空转😈，进而提升吞吐率

距离就是 洗衣服40min-烘干30min-折叠衣服20min

如果有5桶衣服，洗第一桶衣服走完整个流程 也就是折叠完第一桶衣服之后才去 提第二桶衣服放到洗衣机里面洗 （问题在哪？ 在折叠衣服的时候， 洗衣机没有人用！浪费时间）

还有笔者 小时候学校考的一道题， 大意是用一口锅烙饼，也是使用的流水线思想来提升效率；

### 稳定的排序算法

#### 什么是稳定？

**稳定的排序算法**是一种在排序过程中<mark>不会改变具有相等键值的元素的相对顺序的算法。</mark>

换句话说，如果在未排序的数据中有两个元素A和B，它们的值相等，并且在排序前A在B之前，那么在排序完成后A仍然会在B之前。



#### 稳定具体有哪些？

**冒泡排序（Bubble Sort）**：

- 每次比较相邻的元素并交换它们，直到整个数组有序。
- 稳定性：是稳定的，因为只有在前一个元素大于后一个元素时才会交换。

**插入排序（Insertion Sort）**：

- 从数组的第二个元素开始，依次将每个元素插入到已经排序的部分中。
- 稳定性：是稳定的，因为只会将较大的元素向右移动，不会打乱相等元素的顺序。

**归并排序（Merge Sort）**：

- 递归地将数组分成两部分，然后合并时保持稳定性。
- 稳定性：是稳定的，因为在合并过程中可以确保相等元素按原始顺序排列。

**计数排序（Counting Sort）**：

- 使用额外的计数数组来记录每个元素的出现次数，然后依次将元素放回原数组。
- 稳定性：是稳定的，因为在放回元素时保持了它们的原始顺序。

**基数排序（Radix Sort）**：

- 逐位排序，通常从最低有效位到最高有效位，使用稳定的子排序算法（如计数排序）。
- 稳定性：是稳定的，因为它依赖于稳定的子排序算法。



#### 不稳定 

**快速排序（Quick Sort）**：

- 基于分治法，选择一个主元，然后对数组进行划分。
- 不稳定性：分区过程中，可能会打乱相等元素的顺序。

**堆排序（Heap Sort）**：

- 基于堆数据结构，首先构建最大堆，然后不断提取最大元素。
- 不稳定性：由于堆的重构过程，可能会打乱相等元素的顺序

**希尔排序（shell sort）:**

​	 基于插入排序的 不稳定

#### 寄！

### 异常捕获

```c++
class MyException {};
class derivedException : public MyException {};

void func(){
  throw deriveexception();
}

int main(){
  try{
    func();
  }
  catch(MyException &e){
    cout << "MyException" << endl;
  }
  catch(derivedException &e){
    cout << "derivedException" << endl;
  }
}
```

会输出什么信息？

只会输出 `"MyException"`

#### 为什么？ -  **异常处理的顺序**：

在异常处理机制中，如果先捕获基类的异常，所有派生自它的异常也会被捕获，导致派生类的异常处理代码被跳过。因此，应该先捕获 `derivedException`，然后再捕获 `MyException`。

#### 寄

### TCP与UDP



## 编程   

### 模拟

> 米小游有一个长度为 n 的数组，其中第 i 个元素为 ai。现在定义数组的价值是最大的相邻数字的乘积。例如数组为 [3,5,1,2] ，相邻元素的乘积分别是 3*5=15,5*1=5和1*2=2 ，则数组的价值是这些数字中的最大值，即 15。
>
> 现在米小游想要任选数组中的某两个相邻的元素进行交换（**你必须使用这次交换机会**），他想知道最大可以将数组的价值更改为多少

从前往后遍历，两种情况

```c++
for(int i = 0;i + 1 < nums.size() ;i++){
   ans = max(ans, nums[i] * nums[i + 1]);
}
```

a b c

对应于不换或者换相邻的两个 也就是计算 ab bc 的值，



```c++
for(int i = 0;i + 2 < nums.size();i++){
  ans = max(ans, nums[i] * nums[i + 2]);
}
```

对应于 ac



<mark>唯一需要注意的点就是，乘法可能结果很大，所以需要选用long long </mark>

启示:

<font color = 'blue'>对于C++的ACM模式而言，选用存储结果的数据类型可以直接使用long long，以后一定要注意返回的结果用什么类型的变量存储 </font>

### dfs