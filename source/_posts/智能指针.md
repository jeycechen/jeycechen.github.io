---
title: 智能指针
---



### 为什么要使用智能指针？

智能指针 帮助管理动态分配的内存的，可以帮助我们自动释放new出来的内存，从而避免内存泄露

> 如果分配的动态内存都交给有生命周期的对象来处理，那么在对象过期的时候，让它的析构函数删除指向的内存，这似乎是一个好的方案？
>
> 智能指针就是通过这样的方法来解决指针自动释放的问题 



C++ 98 提供了 auto_ptr

C++11提供了unique_ptr, shared_ptr和weak_ptr

### auto_ptr

```c++
#include <memory>
auto_ptr<类型> 变量名字（new 类型）
  
auto_ptr<myclass> ar(new myclass)
```



智能指针 可以像正常指针一样使用

```c++
auto_ptr<myclass> ptr(new myclass());

ptr->func();
(*ptr).func(); //都是合法的
```



#### 三个常用函数

##### get()

获取智能指针托管的指针地址

但是一般不会使用也没必要去使用

##### release()

取消智能指针对动态内存的托管

##### reset()

重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉

```c++
ptr().reset() //释放掉智能指针托管的指针内存，并将其置为null
ptr().reset(new myclass()) //释放掉智能指针托管的指针内存, 并更新其托管的指针
```



#### 使用建议

- 不要将auto_ptr 定义为全局变量或者指针
- 除非自己知道后果，不要吧auto_ptr智能指针赋值给同类型的另外一个智能指针



#### 存在的问题

c++11之后 auto_ptr已经被抛弃 使用unique_ptr代替



原因

- 复制或者赋值都会改变资源的所有权

  ```c++
  // auto_ptr 被C++11抛弃的主要原因
  auto_ptr<string> p1(new string("I'm Li Ming!"));
  auto_ptr<string> p2(new string("I'm age 22."));
  
  cout << "p1：" << p1.get() << endl;
  cout << "p2：" << p2.get() << endl;
  
  // p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，
  // 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。
  p1 = p2;	
  cout << "p1 = p2 赋值后：" << endl;
  cout << "p1：" << p1.get() << endl;
  cout << "p2：" << p2.get() << endl;
  
  ```

  

- 在STL中使用autp_ptr存在重大风险，因为容器内的元素必须支持可复制和可赋值

  ```c++
  vector<auto_ptr<string>> vec;
  auto_ptr<string> p3(new string("I'm P3"));
  auto_ptr<string> p4(new string("I'm P4"));
  
  // 必须使用std::move修饰成右值，才可以进行插入容器中
  vec.push_back(std::move(p3));
  vec.push_back(std::move(p4));
  
  cout << "vec.at(0)：" <<  *vec.at(0) << endl;
  cout << "vec[1]：" <<  *vec[1] << endl;
  
  
  // 风险来了：
  vec[0] = vec[1];	// 如果进行赋值，问题又回到了上面一个问题中。
  cout << "vec.at(0)：" << *vec.at(0) << endl;
  cout << "vec[1]：" << *vec[1] << endl; //此处会发生数组越界或者说访问空指针 ，为什么？
  
  ```

- 不支持对象数组的操作

  ```c++
  auto_ptr<int[]> array(new int[5]);	// 不能这样定义
  ```

  

### Unique_ptr

由于前述提到的auto_ptr的三个特性，c++11的unique_ptr被提出

#### unique_ptr的特性

- 两个指针不能指向同一个资源<font color = 'blue'>unique </font>
- 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值
- 保存指向某个对象的指针，当它本身离开作用域时会自动释放资源
- 在容器中保存指针是安全的

1. 无法左值复制赋值操作 ， 但是允许临时右值赋值和构造

   因为两个指针不能指向同一个 资源，所以 <font color ='blue'> 左值赋值复制不被允许</font>

   ```c++
   unique_ptr<string> p1(new string("11111"));
   unique_ptr<string> p2(new string("22222"));
   
   p1 = p2 ; // 禁止
   unique_ptr<string> p3(p2); //禁止
   
   unique_ptr<string> p3(std::move(p1));
   p1 = std::move(p2); //这两种就都可以，也是也auto_ptr赋值效果一样，所有权转移
   
   
   ```

   

2. 在STL容器中使用unique_ptr, 不允许直接赋值

```c++
vector<unique_ptr<string>> vec;
unique_ptr<string> p3(new string("111"));
unique_ptr<string> p4(new string("222"));

vec.push_back(std::move(p3));
vec.push_back(std::move(p4));

vec[0] = vec[1] ;// 不允许直接赋值 ，同样也是指针的原因
vec[0] = std::move(vec[1]);  
```



3. 支持对象数组的内存管理

```c++
unique_ptr<int[]> array(new int[5]); 可以这样定义
```



### shared_ptr

为了解决auto_ptr 和unique_ptr的排他性导致的问题---> shared_ptr

如果需要多个指针变量共享怎么办？



> 如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或者拷贝的时候，引用计数+1，当智能指针析构的时候，计数-1，如果计数为0，代表已经没有指针指向这块内存，那么管理的这个内存就会被释放，这就是 shared_ptr 采用的策略



#### use_count()

获取shared_ptr的引用计数



#### 初始化

1. 构造函数

   ```c++
   shared_ptr<int> sp1(new int(5));
   shared_ptr<int> sp2(up1);
   ```

   

2. make_shared()

   ```c++
   shared_ptr<int> sp3 = make_shared<int>(2);
   shared_ptr<string> sp4 = make_shared<string>("111");
   shared_ptr<Myclass> sp5 = make_shared<Myclass>(...);
   ```

3. 主动释放对象

   ```c++
   sp1 = nullptr; //引用计数-1，计数归0 内存释放
   sp1 = NULL;
   ```

4. 重置

   ```c++
   sp1.reset(); //重置为空指针，计数-1
   sp1.reset(sp2); //重置为sp2，sp1计数-1，sp2计数+1，
   sp1.reset(sp2,d) //重置为sp2，并且使用d 作为删除器
   ```

5. 交换

   ```c++
   std::swap(up1, up2); //交换 管理对象，但是原有的引用计数不变
   up1.swap(up2);
   ```





#### 循环引用

当A引用了B，B又引用了A，这两个对象就会因为循环引用导致引用计数始终不为0，从而导致无法释放资源



### Weak_ptr

weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 

<font color='blue'>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</font> 同时weak_ptr 没有重载*和->，

但可以<font color='red'>使用 lock 提升 </font>从而获得一个可用的 shared_ptr 对象。

也就是 weak_ptr 并不能直接使用，他只是保存了一个指针对象，需要使用的时候，需要使用<font color = 'blue'>lock()提升</font>

#### 使用

```c++
weak_ptr wp1;
weak_ptr wp2(sp1);
weak_ptr wp3 = wp2;

wp2.use_count(); // 获取引用计数
```



上面那种循环引用的问题就可以可以使用weak_ptr来解决，在类中使用弱指针来接管共享指针，在需要使用的时候就转换成共享指针去使用

#### Expired 函数

使用expired函数判断weak_ptr() 指针的合法性

```c++
// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true
if(!wp.expired()){
  // 有效，还有托管的指针
}
else{
  // 过期了，没有托管的指针
}
```





### 智能指针使用的注意事项

- 不要把一个原生指针给多个智能指针管理

  ```c++
  int *x = new int(10);
  unique_ptr<int> up1(x);
  unique_ptr<int> up2(x);
  
  //后续释放的时候会发生二次释放堆区内存，报错
  //或者以下形式：
  up1.reset(x);
  up2.reset(x);
  ```

- 记得使用ptr.release()的返回值

在调用u.release()时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就会泄漏

- 禁止使用delete 智能智能get函数返回的指针

如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放

- 禁止用任何类型智能指针get 函数返回的指针去初始化另外一个智能指针！

  ```c++
  shared_ptr< int > sp1(new int(10));
  // 一个典型的错误用法 shared_ptr< int > sp4(sp1.get());
  // 同样也会造成重复释放
  // 推荐使用这个 shared_ptr< int > sp4(sp1);
  ```

  