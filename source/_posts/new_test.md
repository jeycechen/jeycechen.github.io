---
title: 腾讯面试记录
---


## **date** 4.1 19:00  


## **面试部门** QQ浏览器


---
## HTTP UDP 区别  

| item | TCP | UDP |
| ---- | ---- | ---- |
| | 面向连接的 | 无连接的 |  
|可靠性|提供可靠传输|尽最大努力交付，不保证可靠传输|  
||有拥塞控制机制|无拥塞控制机制，不会降低源主机的发送速率，适合用于实时应用 语音 视频 直播|  
|传输对象| 字节流| 报文段|
| 传输效率 | 慢 | 快|
| 首部开销 | 20-60 | 8 字节|
| 场景 |适用于要求传输可靠的场景，如文件邮件传输 | 适用于通信速率要求高 即时通讯场景，域名服务 语音视频|
| |一对一| 一对多 一对一 多对一 多对多|
|示例|使用TCP的应用层协议有 FTP Telnet SMTP POP3 HTTP | DNS SNMP TFTP|


---
## HTTP1.0 与 HTTP1.1 HTTP 2.0
| 特性 | HTTP 1.0 | HTTP 1.1 | HTTP 2.0 |
| ---- | ---- | ---- | ---- |
| 持久连接 | 不支持 | 允许在单个连接上发送多个请求和响应 | 允许在单个连接上多路复用多个请求和响应 |
| 头部压缩 | 不支持 | 引入了部分头部压缩机制 | 引入了头部压缩，减少了重复的头部信息传输 |
| 多路复用 | 不支持 | 不支持 | 支持多路复用，允许同时发送和接收多个请求和响应 |
| 二进制传输 | 不支持 | 不支持 | 使用二进制格式传输数据，提高传输效率 |
| 请求优先级 | 不支持 | 不支持 | 支持请求优先级，允许指定请求的优先级顺序 |
| 流控制 | 不支持 | 不支持 | 支持流控制，避免了发送者超负荷发送数据 |

---
## 断点续传如何实现的
断点续传（Resumable Download）是一种通过在下载过程中保存已下载数据的方式，使用户可以在下载中断后继续下载而不必重新开始的技术。它通常在网络下载和上传中使用，尤其是针对大型文件或不稳定网络环境下的文件传输。

实现断点续传通常包括以下步骤：

1. 服务器端支持： 服务器端需要支持断点续传功能。这通常涉及配置服务器以处理范围请求（Range Requests）。服务器接收到范围请求后，会返回请求的部分内容而不是整个文件。HTTP协议中使用的是Range头部来指示客户端需要的数据范围。

2. 客户端实现： 客户端需要能够处理断点续传的逻辑。当下载中断后，客户端会向服务器发送一个包含已下载部分范围的范围请求。服务器会根据这个范围请求返回相应的数据。然后客户端会将这些数据与之前已下载的数据进行合并，从而实现断点续传。

3. 断点记录： 客户端通常会记录已经下载的文件片段的信息，包括文件的大小、已下载的数据大小等。当下载中断时，客户端可以使用这些信息来向服务器发送范围请求。

4. 续传标识： 服务器端通常会使用特定的HTTP头部（如Accept-Ranges和Content-Range）来指示客户端服务器是否支持范围请求以及返回的数据的范围。

总的来说，断点续传是通过客户端和服务器之间的协作来实现的。客户端在下载中断时发送范围请求，服务器根据请求返回相应的数据片段，客户端将这些数据片段与已下载的部分合并，从而实现断点续传。 

---  

## 数据库技术
没学，寄！ 

---  

## 停止等待ARQ协议 连续ARQ协议
TCP使用的是什么协议？ 

---

## new 和 malloc 的区别

---
## hash如何实现
hash_table 开放寻址法 拉链法

---

## 如何实现TCP那样的可靠传输协议 有哪些难点
 编号重排序， 校验和， 冗余丢弃，超时重传，拥塞控制， 流量控制

---

## 线程与进程
| 特征       | 线程                                        | 进程                                      |
| ---------- | ------------------------------------------- | ----------------------------------------- |
| 定义       | 线程是进程的一部分，是程序执行的最小单元。 | 进程是操作系统分配资源的最小单位。       |
| 资源占用   | 线程共享进程的资源，如内存空间、文件句柄等。| 进程有独立的资源空间，如内存、文件句柄等。 |
| 切换开销   | 线程切换开销小，因为共享相同的地址空间。   | 进程切换开销大，因为需要切换不同的地址空间。|
| 通信方式   | 线程间通信相对容易，因为共享相同的地址空间。| 进程间通信相对复杂，需要使用IPC机制。     |
| 并发性     | 线程并发性高，多个线程可同时执行不同的任务。 | 进程并发性低，多个进程之间执行互不干扰。   |
| 创建开销   | 创建线程的开销较小，通常只需要分配栈空间。  | 创建进程的开销较大，需要分配独立的地址空间、PCB等。 |
| 故障隔离   | 一个线程崩溃可能导致整个进程崩溃。          | 一个进程崩溃不会影响其他进程。           |
| 灵活性     | 线程间切换开销小，适合处理密集型任务。      | 进程间切换开销大，适合处理CPU密集型任务。 |

---

## 死锁
1. 互斥条件：至少有一个资源是非共享的，即一次只能被一个进程使用。如果一个进程在使用该资源时，其他进程不能使用，直到该进程释放该资源。

2. 请求与保持条件：一个进程可以请求资源并保持对其他资源的占用。即当一个进程在请求资源时，它可以继续持有已分配的资源，不释放。

3. 不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程抢占，只能由该进程自己释放。

4. 循环等待条件：若干个进程之间形成一种循环等待资源的关系，即每个进程都在等待下一个进程所持有的资源。

# 构造一个死锁
构造死锁的一个常见方式是通过多个进程之间的资源竞争，同时满足死锁的四个条件。例如，考虑两个进程A和B，它们都需要两个资源，但是资源的顺序分配不同，这可能导致死锁。具体来说：

- 进程A获取资源1，进程B获取资源2。
- 进程A请求资源2，但由于资源2已被进程B持有，所以进程A等待。
- 同时，进程B请求资源1，但由于资源1已被进程A持有，所以进程B也等待。
这样，进程A等待进程B释放资源2，而进程B等待进程A释放资源1，导致了死锁的发生。

# 打破死锁
要打破死锁或预防死锁，可以采取以下方法：

- 避免死锁： 通过设计算法和协议来避免进程陷入死锁状态。例如，银行家算法可以在分配资源时避免死锁。

- 检测和恢复： 定期检测系统中是否存在死锁，一旦检测到死锁，采取恢复措施。常见的方法包括进程终止、资源抢占和回滚操作等。

- 避免资源竞争： 设计资源分配策略，尽量减少进程之间的资源竞争。例如，使用资源分配顺序来避免循环等待条件。

- 加锁顺序： 规定所有进程对资源的访问顺序，确保所有进程以相同的顺序请求资源，从而避免环路的形成。

- 超时机制： 对于等待资源的进程，设置超时机制，如果等待时间超过一定阈值，就放弃等待并释放已持有的资源，从而避免死锁。

---

### coding
    合并两个升序链表

---

### 评价   
# 寄！