---
title: 排序方法 总结
---

总结一下各种排序方法 和模版
主要包括 快速排序，归并排序，冒泡排序，堆排序，希尔排序
以及sort函数的自定义比较函数的使用

## 快速排序 升序排序
```c++
void quicksort(vector<int>& nums, int l, int r){
    if(l >= r) return;
    int i = l, j = r; //这里选择哨兵是最左边的元素，
    while (i < j) {
        while(i < j && nums[j] >= nums[l]) j--; // 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 < nums[l] 的元素
        while(i < j && nums[i] <= nums[l]) i++; // 这样 循环外的 swap（nums[l], nums[j]) 才是对的；
        swap(nums[i],nums[j]);
    }
    swap(nums[l], nums[j]);

    // 递归
    quicksort(nums, l, j - 1);
    quicksort(nums, j + 1, r);

}
```


 降序排序

```c++ 
void quicksort(vector<int>& nums, int l, int r){
    if(l >= r) return;
    int i = l, j = r; //这里选择哨兵是最左边的元素，
    while (i < j) {
        while(i < j && nums[j] <= nums[l]) j--; // 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 < nums[l] 的元素
        while(i < j && nums[i] >= nums[l]) i++; // 这样 循环外的 swap（nums[l], nums[j]) 才是对的；
        swap(nums[i],nums[j]);
    }
    swap(nums[l], nums[j]);

    // 递归
    quicksort(nums, l, j - 1);
    quicksort(nums, j + 1, r);
```

快速排序的特殊用途
在o(n)的时间复杂度下得出第k小的数
方法 由于哨兵就是分界点，某次递归的时候发现哨兵的位置i就是k，那么说明当前位置的哨兵就是第k小的值

> 空间复杂度 <mark style="background-color: yellow;">o(1)</mark>  
> 平均时间复杂度 <mark style="background-color: yellow;">o(nlogn)</mark>  
> 最坏情况复杂度 <mark style="background-color: yellow;">o(n2)</mark> 每次都选中了最小的 或者最大的


## 归并排序
```c++
void merged_sort(vector<int>& nums, vector<int>& temp, int l, int r){
    if(l >= r) return;
    int m = l + (r - l) / 2;
    merged_sort(nums, temp, l, m);
    merged_sort(nums, temp, m+1, r);

    //合并过程, 递归下去的时候两部分已经弄好了，所以需要使用temp 来保存
    // 有序的左右2part， nums用于返回排序好的部分
    int i = l, j = m + 1;

    for(int k = l; k <= r; k++){
        temp[k] = nums[k];
    }
    // 开始合并
    for(int k = l; k <= r; k++){
        if(i >= m+1){
            nums[k] = temp[j++];
        }else if(j > r || temp[i] <= temp[j]){
            nums[k] = temp[i++];
        }else{
            nums[k] = temp[j++]; // ====求逆序数在这统计即可======
        }
    }

}
```
归并排序的特殊用途：
- 归并排序的特殊用途， 求逆序数 ，但是不能用于求每个位置的逆序数，只能求逆序数的总和
- 在注释的位置加上统计操作，返回统计结果就可以了
- 求每个位置的逆序数需要使用树状数组，树状数组也可以求逆序数的和


> 空间复杂度 o(N);
> 平均时间复杂度 o(nlogn)
> 最坏情况复杂度 o(nlogn)



## 冒泡排序
```c++
void bubbleSort(vector<int>& nums) {
    int n = nums.size();
    bool swapped; // 标记是否发生交换

    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                swap(nums[j], nums[j + 1]);
                swapped = true;
            }
        }
        // 如果本轮没有发生交换，则数组已经有序，可以提前结束
        if (!swapped) break;
    }
}
```
> 时间复杂度 <mark style="background-color:yellow"> o(n2) </mark>
> 空间复杂度 <mark style="background-color:yellow"> o(1) </mark>


## 堆排序
```c++
void heapify(vector<int>& nums, int n, int i) {
    int largest = i; // 将当前节点标记为最大值
    int left = 2 * i + 1; // 左子节点的索引
    int right = 2 * i + 2; // 右子节点的索引

    // 找出当前节点、左子节点和右子节点中的最大值
    if (left < n && nums[left] > nums[largest]) {
        largest = left;
    }
    if (right < n && nums[right] > nums[largest]) {
        largest = right;
    }

    // 如果最大值不是当前节点，则将最大值与当前节点交换，并递归调整
    if (largest != i) {
        swap(nums, i, largest);
        heapify(nums, n, largest);
    }
}

// 堆排序函数
void heapSort(vector<int>& nums) {
    int n = nums.size();

    // 构建最大堆，从最后一个非叶子节点开始向上调整
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(nums, n, i);
    }

    // 依次将堆顶元素与末尾元素交换，并调整堆
    for (int i = n - 1; i > 0; i--) {
        swap(nums, 0, i); // 将堆顶元素（最大值）与当前末尾元素交换
        heapify(nums, i, 0); // 调整堆，使剩余部分重新成为最大堆
    }
}

```

> 空间复杂度 <mark style="background-color:yellow"> o(1) </mark>
> 平均时间复杂度 <mark style="background-color:yellow"> o(nlogn) </mark>
> 最坏时间复杂度 <mark style="background-color:yellow"> o(nlogn) </mark>
>
>***它的性能表现良好，在实践中通常比较高效，尤其适用于大型数据集。然而，堆排序的主要缺点是不稳定性，即相同值的元素在排序后可能会改变相对顺序。***


## 希尔排序