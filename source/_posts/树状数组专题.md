---
title: 树状数组专题
---

树状数组 BIT
***用途***
支持单点更新 
前缀和查询

![树状数组示意](./public/img/bit.png)

----
对比前缀和数组  

| 属性        | 前缀和数组 | bit     |
|------------|------------|---------|
| 求区间和   | O(1)       | O(logn) |
| 单点更新   | O(n)       | O(logn) |


***使用场景***
求区间[l,r] 内的最大值
求区间[l,r] 内的出现频次最高的数字
求逆序数


***模版***

```c++
class BIT(){
public:
    int m_size;
    vector<int> Bit;
    BIT(int size){
        m_size = size;
        Bit = vector<int> (m_size+1, 0);
    }

    void update(int idx, int del){ //delta 是变化的值
        //更新当前节点和 父节点，
        while(idx <= m_size){
            bit[idx] += del;
            idx += lowbit(idx);
        }
    }

    int query(int idx){
        int sum = 0;
        while(idx>0){
            sum += bit[idx];
            idx -= lowbit(idx); // 往下加上子节点的数值，直到到达叶子节点。
        }
    }

    int lowbit(int idx) {
        return idx & (-idx);
    }
}
```  


---
##example## 逆序数
```c++
    vector<int> reverse(vector<int> nums){
        int len = nums.size();
        if(len < 2) return vector<int> {}; //特殊判断
        set<int> st;
        vector<int> vec;
        unordered_map<int, int> map;
        for(auto ele:nums){
            map[ele]++;
            if(st.count(ele) == 0) {
                vec.push_back(ele);
            }
        }
        sort(vec.begin(), vec.end()); // 升序排序
        
        
        int size = vec.size();
        BIT bit(size); // 存放排名，每个位置的前缀和是小于当前排名的元素个数
                        //然后从后往前遍历原来的数组，根据数组元素查询排名idx
                        //调用update(idx+1,1) 向上更新;表示 idx+1 往后的节点，小于其排名的元素个数 + 1， 因为出现了一个idx
                        //然后调用query(idx), 向下求和，表示求当前位置之后有多少个元素小于当前位置的元素； 
                        // 倒序遍历 + 离散化排名 保证了逆序对的求值

        //init bit
        vector<int> result;
        for(int i = nums.size() - 1;i >= 0;i--){
            int 
        }

    }
    
```

