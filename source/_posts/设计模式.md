---
title: 设计模式
---

设计模式

# 单例模式

是一种 <font color='blue'>创建型模式</font>

常用到的有 <font color = 'gree'>日志模块 数据库模块</font> 

一个类创建对象，不管创建多少个对象，永远只能得到该类型一个对象的示例

```c++
class SingleTon{
public:
  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法
    return &instance;
  }
private:
  	static SinleTonl instance;// 2. 定义唯一的类的实例对象
  	SingleTon(){ // 1 .构造函数私有化
      
    }
  	SingleTon(const SingleTon&) = delete;
  	SingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造
};
SingleTon SingleTon::instance; //静态成员变量 类内声明 类外初始化

int main(){
  SingleTon* s1 = SingleTon::getInstance();
  SingleTon* s2 = SingleTon::getInstance();
  SingleTon* s3 = SingleTon::getInstance();
}
// 这是饿汉式，静态成员变量在数据段，还没调用，就直接生成了

// 下是懒汉式

class SingleTon{
public:
  // 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入）
  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法
    if(instance == nullptr){
    	instance  = new SingleTon();
    }
    return instance;
  }
private:
  	static SinleTonl* instance;// 2. 定义唯一的类的实例对象
  	SingleTon(){ // 1 .构造函数私有化
      
    }
  	SingleTon(const SingleTon&) = delete;
  	SingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造
};
SingleTon SingleTon::instance = nullptr; //静态成员变量 类内声明 类外初始化
```





饿汉式单例模式 ：还没开始使用单例 就已经创建单例了 <font color='blue'>***线程安全***</font> 缺点 启动过程可能时间较长初始化

懒汉式单例模式 ：获取的时候才创建  不是线程安全的代码



```c++
//线程安全的 懒汉单例模式
std::mutex mtx;
class SingleTon{
public:
  // 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入
  // 加锁 保证原子性
  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法
    // lock_guard<std::mutex> guard(mutex); // 锁的粒度太大了，每次获取单例都要加锁，效率低
    if(instance == nullptr){
      lock_guard<std::mutex> guard(mutex); // 放小粒度，放到里面
      // 1.
      if(instance == nullptr){
				instance  = new SingleTon();
      }
      // 2. instance  = new SingleTon();
      // 选1 还是 2 ？
      /* 缩小锁的粒度，就要锁 + 双重判断，否则 还是会发生竞态条件，比如选2
      	 有 A B 两个线程进来了，A，获得锁了，继续new， B未获得锁，等待
      	 A 释放锁， B获得锁，由于没有 双重判断， 导致instance又被new了一遍
      */
    }
    return instance;
  }
private:
  	static SinleTonl *volatile instance;// 2. 定义唯一的类的实例对象 
  	SingleTon(){ // 1 .构造函数私有化
      
    }
  	SingleTon(const SingleTon&) = delete;
  	SingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造
};
SingleTon *volatile SingleTon::instance = nullptr; //静态成员变量 类内声明 类外初始化
```

其中 volatile 关键字 作用是为了防止cpu执行的时候加快多线程效率直接复制 instance的值，从而导致错误，加上volatile 之后，一旦有线程修改了这个值，其他线程就立马可见了



```c++
//也是线程安全的懒汉单例模式
class SingleTon{
public:
  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法
    // g+++ -o run singleTon.cpp gdb run
    // 函数静态局部变量的初始化，在汇编指令上已经自动加上线程互斥指令了
    static SingleTon instance();
    return &instance;
  }
private:
  	static SinleTonl instance;// 2. 定义唯一的类的实例对象
  	SingleTon(){ // 1 .构造函数私有化
      //很多 构造代码，
      // 会不会有一个线程执行到一半 还没构造完成，然后有又有一个线程进来 构造？
    }
  	SingleTon(const SingleTon&) = delete;
  	SingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造
};
SingleTon SingleTon::instance; //静态成员变量 类内声明 类外初始化
```



# 工厂

要工厂模式： 主要是封装了对象的创建

## 简单工厂 Simple Factory

```c++
class Car{
public:
	Car(string name): _name(name){}
  virtual void show() = 0;
protected:
  string _name;
};

class Bmw: public Car{
public:
  Bmw(string name) : Car(name){}
  void show(){
   	cout << "获取一辆宝马" << _name << endl; 
  }
};

class Audi: public Car{
public:
  BMW(string name) : Car(name){}
  void show(){
   	cout << "获取一辆奥迪" << _name << endl; 
  }
};

enum CarType{
  BMW, AUDI
};
class SimpleFactory{
public:
  Car* createCar(CarType ct){
    switch(ct){
      case BMW:
        return new Bmw("X1");
        break;
      case AUDI:
        return new Audi("A6");
        break;
        
      default:
        cerr << "para error" << endl;
      	break;
    }
    return nullptr;
  }
};
int main(){
	//Car *p1 = new Bmw("X1");
  // Car *p2 = new Audi("A6");
  SimpleFactory *factory = new SimpleFactory();
  Car *p1 = factory->createCar(BMW);
  Car *p2 = factory->createCar(AUDI);
  return 0;
}
```

违反了对修改封闭，对扩展开放

## 工厂方法 Factory Method

在简单工厂上部加了一个抽象类

```c++
class Factory
{
public:
  virtual Car* createCar(string name) = 0;
}

class BMWFactory() : public Factory{
public:
 	Car* createCar(string name){
    return new Bmw(name);
  }
}

class AudiFactory(): public Factory{
public:
  Car* createCar(string name){
    return new Audi(name);
  }
}

class OtherFactory(): public Factory{
  //对修改封闭， 对扩展开放了， 扩展 增加子类就可以
}
```



## 抽象工厂 Abstract Factory

考虑产品 一类产品 一系列有关联的产品， 汽车 灯 座椅 车架 

```c++
class Light{
public:
  virtual void show() = 0;
};

class BmwLight: public Light{
public:
  void show(){
	cout << "BMW Light" << endl;}
};

class AudiLight: public Light{
  void show(){
    cout << "Audi Light" << endl;
  }
};

// 工厂方法 ->抽象工厂（对一组有关联关系的产品簇提供产品对象的统一创建）
// 把有关联的工厂方法 联合组成抽象工厂 提供多个产品的创建接口  也就是宝马的工厂不仅生产车架 也有车灯 座椅
// 缺点 抽象工厂的各个方法都必须实现，否则子类就还是抽象类
class AbstractFactory{
  public:
  virtual Car* createCar(string name) = 0; 
  virtual Light* createCarLight() = 0;
}
```



简单工厂 ： 把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象

优点 客户不用自己创建对象，不用了解对象创建的详细过程 

缺点 提供创建对象实例的接口函数不闭合 不能对修改关闭 对扩展开放

工厂方法：Factory 基类 提供一个纯虚函数（创建产品 ）定义派生类 （具体产品的工厂 ）负责创建对应的产品

优点 可以做到不同的产品，在不同的工厂创建，对修改关闭，扩展开放

缺点 实际上很多产品是有关联关系的， 属于一个产品簇，不应该放在不同的工厂进行创建，这样一不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护



抽象工厂 把有关联关系的 属于一个产品簇的所有产品的创建的接口函数，放在一个抽象工厂里面

派生类 （具体产品的工厂）应该负责创建该产品簇里面的所有产品

# 观察者模式

观察者 监听者模式（发布订阅模式） 行为型模式 

主要关注的是对象的一对多的关系， 也就是多个对象都依赖一个对象，当该对象的状态发生变化时，其他对象都能接收到相应的通知

Eg： 一组数据 （数据对象） -> 通过一组数据 ->  曲线图（对象1） 柱状图（对象2） 圆饼图（对象3）

当数据对象改变时，对象1， 对象2 ，对象3，<font color = 'blue'>应该及时收到相应的通知！</font>

Subject(主题) observer1 observer2 observer3

```c++
class Observer{
public:
  virtual void handle(int msgid) = 0;
};

class Observer1 : public Observer{
public:
  void handle(int msgid){
    switch(msgid){
        case 1:
        	cout << "observer1 recv 1 msg" << endl;
        	break;
      	case 2:
        	cout << "observer1 recv 2 msg" << endl;
        	break;
      	default:
        	cout << "observer1 recv unknown msg!" << endl;
       	 	break;
    }
  }
};
class Observer2 : public Observer{
public:
  void handle(int msgid){
    switch(msgid){
      	case 2:
        	cout << "observer2 recv 2 msg" << endl;
        	break;
      	default:
        	cout << "observer1 recv unknown msg!" << endl;
       	 	break;
    }
  }
};

class Observer3 : public Observer{
public:
  void handle(int msgid){
    switch(msgid){
      	case 1:
        	cout << "observer3 recv 1 msg" << endl;
        	break;
      	case 3:
        	cout << "observer3 recv 3 msg" << endl;
        	break;
      	default:
        	cout << "observer3 recv unknown msg!" << endl;
       	 	break;
    }
  }
};

class Subject{
public:
  void addObserver(Observer* obser, int msgid){
    //给主题 添加观察者
    _subMap[msgid].push_back(obser); // msgid 原先有的话直接插入，没有的话会默认构造一个，然后再插入
  }
  void despatch(int msg){
    //主题检测发生改变，通知相应的观察者对象处理事件
    auto it = _subMap.find(msgid);
    if(it != _subMap.end()){
      for(Observer *pObser : it->second){
        pObser->handle(msgid);
      }
    }
  }
private:
  unordered_map<int, list<Observer*>> _subMap;
};
```



# 适配器模式

结构型 模式

让不同的不兼容的接口可以在一起工作 为了避免重构代码 -> 适配器模式

电脑接到投影仪 -> VGA HDMI DP TypeC

类比 转接口



```c++
class VGA{
public:
  virtual void play() = 0;
};

class TV01 : public VGA{
public:
  void play(){
    cout << "通过VGA接口投影" << endl;
  }
};


//电脑只支持VGA接口
class Computer{
public:
  void playVideo(VGA *pVGA){ //只支持VGA接口指针
    pVGA->play();
  }
};

//现在新进入了一批设备 支持HDMI
class HDMI{
public:
  virtual void play() = 0;
};

class TV02: public HDMI{
public:
  void play(){
    cout << "通过HDMI接口投影" << endl;
  }
};

//方法1 ： 换一个HDMI的电脑-> 代码重构
//方法2 ： 买一个转接头-> 添加 适配器

//电脑只支持VGA 投影仪只支持HDMI 所以需要引入适配器
class VGAToHDMIAdapter : public VGA{
public:
  VGAToHDMIAdapter(HDMI *p): pHdmi(p){}
  void play(){ //该方法相当于就是转接头，做不同接口的信号转换的
			pHdmi->play();
  }
private:
  HDMI *PHdmi;
};
int main(){
  Computer c;
  TV01 t;
  c.playVideo(&t);
  c.playViceo(new VGAToHDMIAdapter(new TV02()));
  return 0;
}


```





# 代理模式

结构型模式 Proxy 通过代理类，来控制实际对象（委托类）的访问权限

客户  	助理Proxy 	老板（委托类）

​		客户和老板之间的权限控制

<font color ='blue'>功能都是 委托类实现的， 代理类只是权限控制， 两者是组合关系</font>

客户直接访问的是代理对象，由代理对象和委托类实现不同客户的功能权限控制

```c++
class VideoSite{
public:
  virtual void freeMovie() = 0;	//免费电影
  virtual void vipMovie() = 0; // VIP电影
  virtual void ticketMoveie() = 0; // 用券观看的电影
};

class	MyVideoSite: public VideoSite{
  virtual void freeMovie(){ //免费电影
    cout << "观看免费电影" << endl;
  }
  virtual void vipMovie(){ // VIP电影
    cout << "观看VIP电影" << endl;
	} 
  virtual void ticketMoveie(){ // 用券观看的电影
    cout << "观看券电影" << endl;
	}
};


class FreeVideoSiteProxy : public VideoSite{
public:
  FreeVideoSiteProxy(){
    pVideo = new MyVideoSite();
  }
  ~FreeVideoSiteProxy(){
    delete pVideo;
  }
  virtual void freeMovie(){ //免费电影
    pVideo->freeMovie(); // 通过代理对象的freeMovie， 来访问真正委托类对象的方法
  }	
  virtual void vipMovie(){ // VIP电影
    cout << "无权限" << endl;
	} 
  virtual void ticketMoveie(){ // 用券观看的电影
    cout << "无券" << endl;
	}
private:
	VideoSite *pVideo;
};

class VIPVideoSiteProxy : public VideoSite{
public:
  VIPVideoSiteProxy(){
    pVideo = new MyVideoSite();
  }
  ~FreeVideoSiteProxy(){
    delete pVideo;
  }
  virtual void freeMovie(){//免费电影
    pVideo->freeMovie(); // 通过代理对象的freeMovie， 来访问真正委托类对象的方法
  }	
  virtual void vipMovie()// VIP电影{
    pVideo->vipMovie();// 通过代理对象的vipMovie， 来访问真正委托类对象的方法
	} 
  virtual void ticketMoveie(){ // 用券观看的电影
    cout << "无券" << endl;
	}
private:
	VideoSite *pVideo;
};
```



# 装饰器模式

Decorator 结构型模式



***装饰器 主要是增加现有类的功能***， 但是增加现有类的功能还有一个方法 就是新增加一个子类 -> 导致类的数量非常多

```c++
class Car{ //抽象基类
public:
  virtual void show() = 0;
};


//三个实体汽车类
class BMW :public Car{
public:
  void show(){
    cout << "BWM 汽车 基本配置" << endl;
  }
};

class AUDI :public Car{
public:
  void show(){
    cout << "Audi 汽车 基本配置" << endl;
  }
};

class Benz:public Car{
public:
  void show(){
    cout << "Benz 汽车 基本配置" << endl;
  }
};



//装饰器 1 定速巡航
class ConcreteDecorator01: public Car{
public:
  ConcreteDecorator01(Car *p): pCar(p){}
  void show(){
    pCar->show();
    cour << "定速巡航" << endl;
  }
private:
  Car* pCar;
};
//自动刹车
class ConcreteDecorator02: public Car{
public:
  ConcreteDecorator02(Car *p): pCar(p){}
  void show(){
    pCar->show();
    cour << "自动刹车" << endl;
  }
private:
  Car* pCar;
};

//车道偏离
class ConcreteDecorator03: public Car{
public:
  ConcreteDecorator03(Car *p): pCar(p){}
  void show(){
    pCar->show();
    cour <<"车道偏离" << endl;
  }
private:
  Car* pCar;
};
```



