---
title: CAS algorithm
---
CAS（比较与交换，Compare and swap)



## 有锁算法

独占锁，假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。

缺点：

- 产生竞争时，线程被阻塞等待，无法做到线程实时响应
- dead lock
- live lock
- 优先级反转
- 使用不当，造成性能下降



### 乐观锁与悲观锁

我们知道`CAS`操作并不会锁住共享变量，也就是一种**非阻塞**的同步机制，`CAS`就是乐观锁的实现。

1. 乐观锁 **乐观锁**总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，**所以在每次操作数据的时候都不会给数据加锁**，即在线程对数据进行操作的时候，**别的线程不会阻塞**仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。
2. 悲观锁 **悲观锁**总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，**所以在每次操作数据的时候都会给数据加锁**，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久



## CAS算法 

CAS的语义是“我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际是多少？”



它是原子的操作

 

CAS是项<font color = 'blue'>***乐观锁***</font>技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。



## CAS引发的问题

### ABA问题

1、线程1 期望值为A，想更新为B

2、线程2 期望值为A，想更新为B



线程1 先执行， 但是线程2因为某种原因阻塞了，线程1将变量改成了B

这个时候线程3来了，他把变量从B 改回了 A，

线程2恢复执行，结果发现值就是A，于是 线程2 将 A改成了B，虽然线程2完成了他的操作，但是线程2并不知道发生了<font color='blue'>A->B->A </font> 的情况



解决方法，给变量加上版本标识，每次更新的时候版本标识+1；

<font color='blue'>A->B->A </font>  ------> <font color='blue'>A1->B2->A3 </font> 



#### ABA的危害

取钱，由于机器不好使，多点了几次取款操作，后台thread1， thead2工作，都是100 - 50，thread1工作成果 （100-》50） ，thread阻塞，但是正好有人汇款给你（50+50=100） ，操作成功，余额变成100，这时候thread2 恢复执行，发现余额是100，继续执行100-50，于是本来余额应该是100， 结果却是50，钱没了！！！





### CAS自选带来的开销

多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。

解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。



### 只能保证一个共享变量的原子操作

`CAS`的原子操作只能针对一个共享变量。

**解决方法**： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行`CAS`操作。