<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>6.828_lab1</title>
      <link href="/2024/10/04/6-828-lab1/"/>
      <url>/2024/10/04/6-828-lab1/</url>
      
        <content type="html"><![CDATA[<p>JOS mit 6.828</p><h1 id="lab1">lab1</h1><h2 id="环境配置和使用">环境配置和使用</h2><p><a href="https://www.cnblogs.com/oasisyang/p/15355667.html">https://www.cnblogs.com/oasisyang/p/15355667.html</a></p><p>make qemu-gdb</p><p>make gdb</p><p>在内存地址 0x7c00 <code>b *0x7c00</code></p><p>打印寄存器的值 <code>p $esi</code></p><p>打印寄存器所指向内存地址的值 <code>p *$esi</code><br>打印要执行的下一条指令<code>x/i $eip</code></p><h2 id="pc-bootstrap">PC Bootstrap</h2><h3 id="pc的物理地址空间">PC的物理地址空间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><p>384KB area from 0x000A0000 through 0x000FFFFF 是供给硬件使用的 尤其是video disdplay buffers 以及 firmware held in non-volatile memory，最重要的BIOS也保存在这个地方 占据着 64KB region from 0x000F0000 through 0x000FFFFF.</p><blockquote><p>该保留区域中最重要的部分是基本输入/输出系统 (BIOS)，它占据了从 0x000F0000 到 0x000FFFFF 的 64KB 区域。在早期的 PC 中，BIOS 保存在真正的只读存储器 (ROM) 中，但当前的 PC 将 BIOS 存储在可更新的闪存中。BIOS 负责执行基本的系统初始化，例如激活视频卡和检查已安装的内存量。执行此初始化后，BIOS 会从某个适当的位置（例如软盘、硬盘、CD-ROM 或网络）加载操作系统，并将机器的控制权交给操作系统。</p><p>When Intel finally “broke the one megabyte barrier” with the 80286 and 80386 processors, which supported 16MB and 4GB physical address spaces respectively, the PC architects nevertheless preserved the original layout for the low 1MB of physical address space in order to ensure backward compatibility with existing software. <font color='blue'>Modern PCs therefore have a “hole” in physical memory from 0x000A0000 to 0x00100000,</font> dividing RAM into “low” or “conventional memory” (the first 640KB) and “extended memory” (everything else). <font color='red'><strong>In addition, some space at the very top of the PC’s 32-bit physical address space, above all physical RAM, is now commonly reserved by the BIOS for use by 32-bit PCI devices</strong>.</font></p><p>也就是现代计算机仍然存在hole 在0x000A0000到 0x00100000的位置，bios和硬件所保留，这个hole把物理内存划分为两部分 low/conventional memory 和 extended memory</p></blockquote><h3 id="the-rom-bios">The ROM BIOS</h3><p>启动qemu</p><p><img src="/Users/casey/blog_md/JOS/lab1/first_code.png" alt="第一个执行的代码"></p><p>可以看到第一句执行的指令是 位于0xffff0的 一条jump指令</p><p>注意到以下三点：</p><ul><li><p>The IBM PC starts executing at physical address 0x000ffff0, which is at the very top of the 64KB area reserved for the ROM BIOS</p></li><li><p>The PC starts executing with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code>.</p><blockquote><p>CS IP是什么？</p><p>CS 代码段寄存器 内存单元的段地址</p><p>IP 指令指针寄存器 内存单元的偏移地址</p><p>如何通过CS IP 得到 实际的物理地址</p><p>physical address = CS * 16 + IP;</p><p>也就是CS左移4位 加上 IP 就是实际的物理内存地址</p><p>通过CS：IP的方式，8088的16位地址线可以管理访问到1M的物理内存</p></blockquote></li><li><p>The first instruction to be executed is a <code>jmp</code> instruction, which jumps to the segmented address <code>CS = 0xf000</code> and <code>IP = 0xe05b</code></p></li></ul><p>为何QEMU这样启动？intel就是这样设计的 PC中的BIOS is “hard-wired” to the physical address range 0x000f0000-0x000fffff， 这种设计确保了 BIOS在开机或者重启的时候 始终能够取得机器的控制权，在开机之后，处理器enters real mode and sets CS to 0xf000 and the IP to 0xfff0，以便从CS:IP这个地址开始执行</p><p>1、0xffff0到 BIOS的末尾0x00100000 也就  <code>16Bytes</code> 能做的事情非常有限，所以这一条指令是一条 <font color='blue'>jump</font>指令.</p><p>2、当BIOS继续运行， 它会设置 interrupt descriptor table and initializes various devices such as the VGA display. 设置中断向量表<font color='blue'>IDT</font>和全局描述符表<font color='blue'>GDT</font></p><p>3、PCI总线和所有的重要设备初始化完成之后，BIOS就会搜索所有的可启动的设备 ，如 floppy, hard drive, or CD-ROM. ，找到可启动磁盘后，BIOS会从磁盘读取 <font color='blue'>引导加载程序<code>Boot Loader</code> 并且将控制权转交给它</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1 0xffff0: ljmp $0xf000, $0xe05b    #跳转到0xfe05b</span><br><span class="line">2 0xfe05b: cmpl $0x0, $cs:0x6ac8    #根据cs:0x6ac8是否为0，进行跳转</span><br><span class="line">3 0xfe062: jne 0xfd2e1                #无跳转</span><br><span class="line">4 0xfe066: xor %dx, %dx                #%dx清零</span><br><span class="line">5 0xfe068: mov %dx, %ss                #%ss置零</span><br><span class="line">6 0xfe06a: mov $0x7000, %esp</span><br><span class="line">7 0xfe070: mov $0xf34d2,%edx</span><br><span class="line">8 0xfe076: jmp 0xfd15c</span><br><span class="line">9 0xfd15c: mov %eax, %ecx</span><br><span class="line">10 0xfd15f: cli                        #BIOS的启动不允许中断，关闭中断</span><br><span class="line">11 0xfd160: cld                        #设置指令增长的方向</span><br><span class="line">12 0xfd161: mov $0x8f, %eax</span><br><span class="line">13 0xfd167: out %al, $0x70            #0x70和0x71是用于操作CMOS 的端口</span><br><span class="line">14 0xfd169: in $0x71, %al            #12-14三条指令是用于关闭不可屏蔽中断</span><br><span class="line">15 0xfd16b: in $0x92, %al</span><br><span class="line">16 0xfd16d: or $0x2, %al</span><br><span class="line">17 0xfd16f: out %al, $0x92</span><br><span class="line">18 0xfd171: lidtw %cs:0x6ab8        #将0xf6ab8处的数据读入到中断向量表寄存(IDTR)</span><br><span class="line">19 0xfd177: lgdtw %cs:0x6a74   #并将0xf6a74的数据读入到全局描述符表格寄存器(GDTR)中</span><br><span class="line">20 0xfd17d: mov %cr0, %eax</span><br><span class="line">21 0xfd180: or $0x1, %eax</span><br><span class="line">22 0xfd184: mov %eax, %cr0  #CR0末位置1，进入保护模式</span><br><span class="line">23 0xfd187: ljmpl $0x8, $0xfd18f</span><br><span class="line">24 0xfd18f: mov $0x10, %eax</span><br><span class="line">25 0xfd194: mov %eax, %ds</span><br><span class="line">26 0xfd196: mov %eax, %es</span><br><span class="line">27 0xfd198: mov %eax, %ss</span><br><span class="line">28 0xfd19a: mov %eax, %fs</span><br><span class="line">29 0xfd19c: mov %eax, %gs</span><br><span class="line">30 0xfd19e: mov %ecx, %eax #第23~29 步用于重新加载段寄存器，在加载完GDTR 寄存器后需要刷新所有的段寄存器的值</span><br></pre></td></tr></table></figure><blockquote><p>what is GDTR?</p></blockquote><p>Global Descriptor Table</p><p>包含一组描述符，用于定义内存段的起始地址、大小、权限等信息。每个描述可以代表一个段。</p><ul><li><strong>内存分段</strong> 通过定义不同的段来划分内存地址空间<font color='blue'> 虚拟地址空间</font></li><li><strong>权限控制</strong> 可以设置不同的权限级别，内核模式和用户模式</li><li><strong>段选择</strong> 通过段选择子来访问GDT中的描述符，从而决定代码和数据的访问范围和权限</li></ul><h2 id="the-boot-loader">The Boot Loader</h2><p>PC的Floopy 和 hard disks 被划分成512bytes 的扇区， 扇区是磁盘的最小传输单位，每个读取或者写入的操作必须是一个或者多个扇区大小，并且要与扇区的边界对齐</p><p>如果磁盘是可以引导的，那个第一个扇区被称为引导扇区，（因其包含boot loader代码）当BIOS找到了一个可引导设备，它就会加载这个设备的第一个扇区512字节到内存地址 <code>0x7c00-0x7dff</code>， 并且使用jmp指令设置CS：IP 为<code>0000:7c00</code>， 就像BIOS的入口地址一样 7c00这个地址<font color='green'>是随意的，但是是约定好的标准，是惯例</font></p><blockquote><p>从CD-ROM Boot有一些不一样 比如 CD-ROOM的扇区大小是2048</p><p>The ability to boot from a CD-ROM came much later during the evolution of the PC, and as a result the PC architects took the opportunity to rethink the boot process slightly. As a result, the way a modern BIOS boots from a CD-ROM is a bit more complicated (and more powerful). CD-ROMs use a sector size of 2048 bytes instead of 512, and the BIOS can load a much larger boot image from the disk into memory (not just one sector) before transferring control to it. For more information, see the <a href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El Torito” Bootable CD-ROM Format Specification</a>.</p></blockquote><p>6.828中 使用传统的hard drive boot mechanism，这意味着引导程序必须在512字节完成，代码在<code>boot/boot.S</code>, <code>boot/main.c</code>, 由assembly  language + c一起完成 ，这两部分代码必须完成两个主要的功能</p><ol><li>首先，boot loader 需要完成processor <font color='blue'>从 16-bit real mode 到32-bit protected mode 的转变</font>，因为只有在protected mode 才能访问在1MB之上的所有内存地址空间</li></ol><blockquote><p>Protected mode is described briefly in sections 1.2.7 and 1.2.8 of <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language</a>, and in great detail in the Intel architecture manuals. <strong>At this point you only have to understand that translation of segmented addresses (segment:offset pairs) into physical addresses happens differently in protected mode, and that after the transition offsets are 32 bits instead of 16.</strong></p></blockquote><ol start="2"><li>其次，boot loader  会通过x86的特殊IO指令直接访问IDE磁盘设备寄存器，从硬盘读取内核</li></ol><blockquote><p>b 打断点  <strong>b *0x7c00</strong></p><p>c</p><p>si 单步</p><p>si N N个单步</p><p>x/i  查看下一条指令</p><p>x/Ni ADDR 查看从ADDR开始的 N条指令</p></blockquote><h3 id="answer-questions">Answer Questions</h3><ul><li><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"># ljmp $0x8, $0x7c32 </span><br></pre></td></tr></table></figure><blockquote><p>1、在完成启用A20地址线之后，以及bootstrap GDT</p><p>and segment translation 加载好GDT表之后，开始转型执行32位的代码，为什么要这样做？（为了向早期的机器兼容）开机的时候1MB以上的地址空间是默认不可用的，需要解锁，<strong><font color='red'>GDT表是什么？</font></strong></p><p>2、因为实模式到保护模式的转变，需要使用更多的地址，就需要16 -&gt; 32位</p></blockquote></li><li><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw$0x1234,0x472# warm boot</span><br></pre></td></tr></table></figure><p>在不中断电源的情况下启动 热启动，将0x1234 写入到地址0x472，系统可以识别并且执行预定的重启程序，比如不进行完全的硬件复位</p></li></ul><p>​再来回顾整个boot 流程</p><p>​1、0xffff0 是 开机的第一条指令 ，跳转到bios，jump到0xfe50b，执行bios的代码</p><p>​2、bios完成必要的一些初始化操作后， 会去扫描磁盘引导扇区，找bootloader，加载bootloader到0x7c00处，然后 bootloader 接管控制权（jump to 0x7c00）</p><p>​3、boot.s 负责启动A20地址线，load <strong><font color='red'>GDT表？</font></strong>，完成实模式到保护模式的转变，然后设置栈指针(为c语言函数作准备) call bootmain(main.c)设置栈指针0x7c00，因为stack是向下增长的 所以不会覆盖bootloader</p><blockquote><p>向下增长的堆栈有助于利用线性地址空间和简化内存管理。例如，当调用函数时，新分配的局部变量和返回地址都放置在较低的地址空间，这样可以有效利用内存并保持堆栈的连续性。</p></blockquote><p>​4、main.c 从 磁盘中读取 内核ELF文件 ，然后进Kernel的入口函数e_entry，启动内核</p><ul><li><p><em>Where</em> is the first instruction of the kernel?</p><p>same as the last question!</p></li><li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p></li></ul><p>Elf 文件格式</p><blockquote><p>Excercise5 Then change the link address in <code>boot/Makefrag</code> to something wrong, run make clean,</p><p>会发生什么？ 无限重启，为什么？因为默认是在0x7c00这个地找bootloader，电脑开机的时候，会先执行bios，bios完成必要的初始化之后，会去搜索所有的磁盘，然后从磁盘的第一个分区尝试找到一个引导程序，如果是合法的引导程序，就会按照引导程序的elf设置将这个程序加载到LMA所指定的地址，bios加载完之后，会默认跳转到0x7c00这个地址执行引导程序，那么如果引导程序没有被加载到这个地址，而是被加载到了0x7100，相当于跳转的地方没有合法的引导程序，SeaBios的实现可能就是无限重启</p></blockquote><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241002111624.png" alt=""></p><p>修改之后-Ttext 0x7c00-&gt;0x8c00，<code>ljmp $0xb886, $0x87c23 -&gt; ljmp $0xb886, $0x88c32</code>;</p><p>这里明明加载到的是8c00，为什么gdb调试的时候，在7c00还是能看到执行的是8c00 的代码？</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241002114002.png" alt=""></p><p>ljmp跳转 88c32  这个位置之后，实际上执行的是最开始的代码 ，</p><p>猜测过程应该是这样的，bios会把bootloader<strong>固定</strong>加载到 0x7c00这个地方，所以无论-Ttext 写的是多少，实际上0x7c00执行的第一句都是boot 的第一行，但是一旦涉及到符号跳转的地方就会出现问题，因为符号跳转使用的是绝对地址，而绝对地址（编译时使用的虚拟地址）的开始值是被设置成0x8c00，也就是ljmp跳转 88c32  ，这个时候就会出现错误，<font color='blue'>然后重新从0xfe05b开始执行，这里应该是bios接管了重新执行</font></p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241002114547.png" alt=""></p><h3 id="loading-the-kernel">Loading the Kernel</h3><p>ELF 文件格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">i386-elf-objdump -h obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000173b  f0100000  00100000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       00000714  f0101740  00101740  00002740  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         00000001  f0101e54  00101e54  00002e54  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .stabstr      00000001  f0101e55  00101e55  00002e55  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  4 .data         0000a300  f0102000  00102000  00003000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .bss          00000660  f010c300  0010c300  0000d300  2**5</span><br><span class="line">                  ALLOC</span><br><span class="line">  6 .comment      00000012  00000000  00000000  0000d300  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  7 .debug_info   0000067f  00000000  00000000  0000d312  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line">  8 .debug_abbrev 000002d0  00000000  00000000  0000d991  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line">  9 .debug_loclists 00000a11  00000000  00000000  0000dc61  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 10 .debug_aranges 00000040  00000000  00000000  0000e672  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 11 .debug_rnglists 00000051  00000000  00000000  0000e6b2  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 12 .debug_line   0000042e  00000000  00000000  0000e703  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 13 .debug_str    00000290  00000000  00000000  0000eb31  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br></pre></td></tr></table></figure><p>注释 ：</p><ul><li><p>VMA(link address)  LMA（load address）</p><blockquote><p>The load address of a section is the memory address at which that section should be loaded into memory.</p><p>就是实际load物理地址</p><p>The VMA of a section is the memory address from which the section expects to execute.</p><p>就是虚拟地址</p><p>The linker encodes the link address in the binary in various ways, such as when the code needs the address of a global variable, with the result that a binary usually won’t work if it is executing from an address that it is not linked for.</p></blockquote><p>通常 ，这俩应该是相等的</p></li><li><p>boot loader 使用ELF program headers来决定如何加载secctions，ELF program headers 指定了ELF的那部分需要加载到内存的哪个目标地址</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">                 CONTENTS, READONLY</span><br><span class="line">(base) casey@192 lab % objdump -x obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:        file format elf32-i386</span><br><span class="line">architecture: i386</span><br><span class="line">start address: 0x0010000c</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x0000c300 memsz 0x0000c960 flags rwx</span><br><span class="line"></span><br><span class="line">Dynamic Section:</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name            Size     VMA      LMA      Type</span><br><span class="line">  0                 00000000 00000000 00000000 </span><br><span class="line">  1 .text           0000173b f0100000 00100000 TEXT</span><br><span class="line">  2 .rodata         00000714 f0101740 00101740 DATA</span><br><span class="line">  3 .stab           00000001 f0101e54 00101e54 DATA</span><br><span class="line">  4 .stabstr        00000001 f0101e55 00101e55 </span><br><span class="line">  5 .data           0000a300 f0102000 00102000 DATA</span><br><span class="line">  6 .bss            00000660 f010c300 0010c300 BSS</span><br></pre></td></tr></table></figure><p>需要加载到内存的对象区域是标记为“LOAD”的区域，</p><ul><li><p>可以看到 内核的 加载地址 和 链接地址不是一样的， 内核告诉loader 将其加载到内存的低地址 00100000，但是他希望从高地址 f0100000开始执行，下一节介绍如何实现这一点</p></li><li><p>除了节信息之外，ELF 头中还有一个很重要的字段，名为 e_entry。此字段保存程序中入口点的链接地址：程序文本节中程序应开始执行的内存地址。可以看到入口点：<code>objdump -f obj/kern/kernel</code></p></li></ul><h2 id="the-kernel">The Kernel</h2><blockquote><p>Like the boot loader, the kernel begins with some assembly language code that sets things up so that C language code can execute properly.</p></blockquote><h3 id="using-virtual-memory-to-work-around-position-dependence">Using virtual memory to work around position dependence</h3><p>上一张说到boot loader的VMA LMA 一样的</p><p>但是 kernel的 VMA LMA不一致，这是因为：</p><p>操作系统内核通常喜欢链接并运行在非常高的<em>虚拟地址</em>上，例如 0xf0100000，以便将处理器虚拟地址空间的较低部分留给用户程序使用。</p><p>许多机器在地址 0xf0100000 处没有任何物理内存，因此不能指望能够将内核存储在那里。相反，我们将使用处理器的内存管理硬件将虚拟地址 0xf0100000（内核代码预期运行的链接地址*）*映射到物理地址 0x00100000（引导加载程序将内核加载到物理内存中的位置）。这样，尽管内核的虚拟地址足够高，可以为用户进程留出足够的虚拟地址空间，但它将加载到 PC RAM 中 1MB 位置的物理内存中，就在 BIOS ROM 上方。这种方法要求 PC 至少有几兆字节的物理内存（以便物理地址 0x00100000 可以工作），但对于 1990 年以后制造的任何 PC 来说，这很可能都是正确的。</p><p>在0x1000c处break 可以看到 在此处完成了虚拟地址的映射</p><p>也就是高地址 0xf0100000可以被访问了</p><p><mark style="background-color:red">怎么做到的？？</mark></p><h3 id="formatted-printing-to-the-console">Formatted Printing to the Console</h3><ol><li>Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</li></ol><p>printf负责提供打印的函数 putch ，cprintf ，vcprintf，</p><p><code>int cprintf(const char *fmt, ...)</code>  负责接收变参数列表变成va_list，然后调用<code>int vcprintf(const char *fmt, va_list ap)</code>，这里再调用vprintfmt函数格式化处理输出<code>vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)</code>，将变参数列表嵌入到format中，保存到<code>putdat</code>中，调用<code>putch</code>回调函数输出到console中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">putch</span><span class="params">(<span class="type">int</span> ch, <span class="type">int</span> *cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">cputchar(ch);</span><br><span class="line">*cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cputchar就是consoles中的函数，负责将ch通过<mark style='background:yello'>与硬件交互真正地输出到终端上</mark></p><ol start="2"><li>Explain the following from console.c</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>)); <span class="comment">//移动 腾出最后一行</span></span><br><span class="line"><span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>; <span class="comment">//最后一行置为空格 也就是全部删除掉</span></span><br><span class="line">crt_pos -= CRT_COLS;<span class="comment">//回到最后一行开始的位置以便继续向缓冲区输出数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crt_buf 满了 清一下？</p><p>正确解释：用于<code>控制文本显示</code>的，具体来说，这段代码处理当字符缓冲区（crt_buf）满时需要<code>滚动屏幕</code>的情况，<code>CRT_SIZE</code>被设置为<code>25*80</code>， 也就是窗口支持显示25行，80列个字符串，现在显示满了，需要将缓冲区向上腾一行，也就是第二行往下的所有内容整体往上移动一行，腾出新的一行的空间，实现滚动的效果</p><ol start="3"><li>Run the following code.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br></pre></td></tr></table></figure><p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><blockquote><p>%s 需要的是一个 char * 的指针 ，所以传入的是一个指针</p></blockquote><p>如果是小端字节序，<code>unsigned int i</code> 在内存中的布局是</p><table><thead><tr><th>地址</th><th>值</th><th>字符</th></tr></thead><tbody><tr><td><code>&amp;i</code></td><td><code>0x72</code></td><td><code>r</code></td></tr><tr><td><code>&amp;i+1</code></td><td><code>0x6c</code></td><td><code>l</code></td></tr><tr><td><code>&amp;i+2</code></td><td><code>0x64</code></td><td><code>d</code></td></tr><tr><td><code>&amp;i+3</code></td><td><code>0x00</code></td><td>null</td></tr></tbody></table><p>为了保持一样的结果 大端字节序的i 的值应该被设置成<code>0x726c6400</code>, 这样在内存的地址才和上面是保持一致的</p><p>但是 57616 不需要修改, 因为%x输出的就是十六进制，<mark style='background-color yello'>无论是小端还是大端系统，整数 <code>57616</code>（十进制）在以十六进制格式输出时都将表现为 <code>e110</code>。这是因为整数在内存中的存储顺序对其整体数值没有影响，只影响内存中字节的排列顺序，而 <code>%x</code> 只关心数值本身。</mark></p><ol start="4"><li>In the following code, what is going to be printed after<code>'y='</code>? (note: the answer is not a specific value.) Why does this happen?</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure><p>输出将会是不确定的，因为，fmt需要两个参数 而va_list只有一个，在取第二个参数的时候，会取到不属于 cprintf 函数栈帧的数据 所以这其实是<font color='blue'>未定义的行为， 输出什么值都有可能</font></p><blockquote><p>补充</p><p>x86进栈顺序，按照函数参数声明的顺序，最后声明的参数将被第一个入栈</p><p>cprintf(“H%x Wo%s”, 57616, &amp;i);， 先入栈的是i的地址 然后是整数57616，最后是fmt字符串</p></blockquote><h4 id="exercise8">Exercise8</h4><p>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">num = getuint(&amp;ap, lflag);</span><br><span class="line">base = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">goto</span> number;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>在i386 init这个地方 <code>cprintf(&quot;\n6828 decimal is %o octal!\n&quot;, 6828);</code>,需要在格式串6828前面添加\n,否则过不了make grade</p><h3 id="the-stack">the Stack</h3><p>在x86架构的函数调用中，ebp（基址指针）是用来帮助管理栈帧的。假设函数A调用了函数B，函数B将当前的esp值复制到ebp中，这个操作实际上是函数B在为自己设置一个新的栈帧。在这种情况下，B并不是不能使用ebp，而是B使用ebp来指向自己的栈帧的起始位置。</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003150047.png" alt=""></p><p>下面是一个具体的步骤说明：</p><ol><li><p><strong>函数A调用函数B</strong>：</p><ul><li><p>先把函数需要使用到的参数压入栈中</p></li><li><p>函数A执行<code>call B</code>指令，这会将返回地址压入栈中，然后跳转到函数B。</p></li></ul></li><li><p><strong>函数B的栈帧初始化</strong>：</p><ul><li>函数B开始执行时，通常会首先保存A的ebp值。这是通过<code>push ebp</code>实现的，将A的ebp值压入栈中。</li><li>然后，B将当前esp（A的栈顶）的值复制到ebp（B的栈底）中：<code>mov ebp, esp</code>。这一步创建了B自己的栈帧，ebp现在指向B的栈帧的起始位置。 <font color='blue'> 也就是设置B的栈底为A的栈顶 然后开始保护寄存器…</font></li></ul></li><li><p><strong>函数B的栈帧使用</strong>：</p><ul><li>在B的执行过程中，esp会随着局部变量和其他栈操作而改变，而ebp则保持不变，用于访问B的参数和局部变量。</li><li>由于ebp指向B的栈帧起始位置，B可以通过ebp+offset的方式访问自己的局部变量和参数。</li></ul></li><li><p><strong>函数B结束并返回到A</strong>：</p><ul><li><p>在函数B即将返回时，通常会恢复A的ebp值。这是通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ebp</span><br></pre></td></tr></table></figure><p>实现的：</p><ul><li><code>mov esp, ebp</code>：将esp恢复到B的栈帧起始位置，这样可以正确弹出返回地址。</li><li><code>pop ebp</code>：将A的ebp值弹出栈，并恢复到ebp寄存器。</li><li><font color='blue'>这两条在实际实现中 使用<code>leave</code> 来实现</font></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave // 清除当前函数的栈帧</span><br><span class="line">ret // 这一步 对应一开始的call ，弹出地址，设置eip</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003113003.png" alt=""></p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003104512.png" alt=""></p></li><li><p><strong>函数A继续执行</strong>：</p><ul><li>函数B返回后，esp指向A的栈帧的原位置，并且ebp也恢复为A的值。</li></ul></li></ol><p>通过这种机制，每个函数在调用过程中都可以使用ebp来管理自己的栈帧，而不会干扰其他函数的栈帧。因为ebp在发生函数调用的时候，会被push保护起来，因此，ebp是可以被每个函数独立使用的。</p><h3 id="问题">问题</h3><p>1、为什么是mov %esp， %ebp</p><p>mov dest, source 那么这里就是把ebp 复制到esp，是不是写反了？？？</p><p>往上查到的 是mov dest，source</p><p>但是这个jos实验所用的架构好像是先source 再dest</p><p>如<code>f010011d movl $0x5, (%esp)</code>;</p><p>2、为什么第一个参数是以<code>movl $0x5, (%esp)</code> 的形式入栈，而其他是以push入栈？</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003150251.png" alt=""></p><p>因为esp这个时候是上一个函数的参数，5，这里参数不太清楚，把stack_test(1,2,3,4,6)最后一参数换成6，gdb调试一下;</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003151940.png" alt=""></p><p><font color='blue'>也就是这里的栈顶放的是上一个函数的入参，但是已经不需要用了，所以就直接movl 覆盖掉就好了</font></p><h3 id="思考">思考</h3><p>为什么在函数开始的地方需要保存ebx？</p><p>参见<font color='blue'>csapp 173</font> 寄存器分为被调用者保存寄存器和调用者保存寄存器</p><p><strong>被调用者保存寄存器</strong> rbx rbq r12-r15</p><p>P调用Q的时候，Q必须保存这些寄存器， <font color='red'>保护这些寄存器是被调用者的责任，如果需要使用这些寄存器的话，就必须push（保护 和pop（恢复</font></p><p><strong>调用者保存寄存器</strong> 处理上面这些寄存器和rsp， 都是调用者保存寄存器</p><p><font color='blue'> 调用者保存，因为任何函数都可以使用这类寄存器，如果过程P在这类寄存器有局部数据，就必须自己保存，因为其他过程可以随便修改这类寄存器</font></p><p>为什么这么设置，这是x86-64的惯例！</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003123418.png" alt=""></p><h1 id="运行结果">运行结果</h1><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241001163923.png" alt=""></p><h4 id="exercise-10-12">exercise 10 - 12</h4><p>实现内核调用栈回溯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line"><span class="type">uint32_t</span> ebp, eip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="comment">//指针学习</span></span><br><span class="line">    <span class="comment">//+1实际上偏移的是4bytes</span></span><br><span class="line">    <span class="keyword">for</span>(ebp=read_ebp(); ebp!=<span class="number">0</span>; ebp=*((<span class="type">uint32_t</span> *)ebp))&#123;</span><br><span class="line">        eip = *((<span class="type">uint32_t</span> *)ebp+<span class="number">1</span>);</span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,</span><br><span class="line">                    ebp, eip, *((<span class="type">uint32_t</span> *)ebp+<span class="number">2</span>), *((<span class="type">uint32_t</span> *)ebp+<span class="number">3</span>), </span><br><span class="line">                    *((<span class="type">uint32_t</span> *)ebp+<span class="number">4</span>), *((<span class="type">uint32_t</span> *)ebp+<span class="number">5</span>), *((<span class="type">uint32_t</span> *)ebp+<span class="number">5</span>), </span><br><span class="line">                    *((<span class="type">uint32_t</span> *)ebp+<span class="number">6</span>));</span><br><span class="line">                    <span class="comment">//.有截断的能力，*能够让eip_fn_namelen阶段字符串</span></span><br><span class="line">        cprintf(<span class="string">&quot;         %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, </span><br><span class="line">                            info.eip_fn_namelen, info.eip_fn_name, eip-info.eip_fn_addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在debuginfo_eip中需要补充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">info-&gt;eip_line = lline &gt; rline ? <span class="number">-1</span> : stabs[lline].n_desc;</span><br></pre></td></tr></table></figure><h1 id="挑战">挑战</h1><p><em>Challenge</em> Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret <a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/">ANSI escape sequences</a> embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on <a href="https://pdos.csail.mit.edu/6.828/2017/reference.html">the 6.828 reference page</a> and elsewhere on the web on programming the VGA display hardware. If you’re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</p><p>我们知道参数是按照声明顺序从右到左入栈的，也就是最后所有的参数入栈之后，最下面的那个（栈顶）应该是第一个参数。思考如下问题</p><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list ap;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">va_start(ap, fmt);</span><br><span class="line">cnt = vcprintf(fmt, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回答">回答</h3><p>int cprintf(const char *fmt, …) 这里应该被改成int cprintf(…, const char *fmt)</p><p>同时va_xxx对format的遍历应该从末尾开始，因为从左到右压入栈之后，栈顶第一个元素是最末尾的参数，为了匹配参数大小，应该从format的末尾开始</p>]]></content>
      
      
      
        <tags>
            
            <tag> boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll实现原理</title>
      <link href="/2024/09/18/epoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2024/09/18/epoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>epoll是对select和poll的改进，解决了 性能开销大 和 文件描述符数量少 这两个缺点，是性能最高的多路复用方式，能支持的并发量也很大</p><p>在 监视大量的链接只有少量是活动的情况下，epoll的性能是强于select/poll的，但是如果大量的链接都是活动的，那么大家都半斤八两</p><p>1）epoll 使用<strong>红黑树</strong>存储一份文件描述符集合（在内核维护， 每个文件描述符只需在添加的时候传入一次， – 解决了 select 和poll 需要 重复拷贝到内核的问题</p><p>2）通过异步IO的方式找到就绪的文件描述符，而不是轮询</p><p>3）使用队列存储就绪的文件描述符，按需返回就绪的文件描述符，无需遍历整个文件描述符的集合</p><h2 id="用法">用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;   <span class="comment">// 创建一个 eventpoll 内核对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;   <span class="comment">// 将连接到socket对象添加到 eventpoll 对象上，epoll_event是要监听的事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;      <span class="comment">// 等待连接 socket 的数据是否到达</span></span><br></pre></td></tr></table></figure><h2 id="实现">实现</h2><p>epoll_create</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span> &#123;</span><br><span class="line"> <span class="type">wait_queue_head_t</span> wq;      <span class="comment">// 等待队列链表，存放阻塞的进程</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">list_head</span> rdllist;  <span class="comment">// 数据就绪的文件描述符都会放到这里</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;        <span class="comment">// 红黑树，管理用户进程下添加进来的所有 socket 连接</span></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240919230824.png" alt=""></p><p>wq 等待队列</p><p>rbr 红黑树的作用是 快速删除 修改 <code>O(logn)</code>的时间复杂度</p><p>rdlist 就绪的双向链表</p><blockquote><p>红黑树</p><p>1、节点只有两种颜色黑色和红色</p><p>2、根节点是黑色的</p><p>3、叶子是黑色的</p><p>4、红色节点的孩子全是黑色</p><p>5、任意节点到叶子节点的黑色节点的数量一样</p><p>这五个性质保证了 一个节点到所有叶子的长度差异不可能超过两倍 - &gt; 尽量自平衡的一颗二叉树 为什么？<mark> 节点到叶子的黑色节点个数是一样的，但是红色不会连续出现，所以红色节点的个数不会超过黑色节点，也就是最少的路径长度全是黑色节点m， 最长的路径黑红交替2m，最多差距不超过两倍</mark></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> epoll </tag>
            
            <tag> IO多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>task_struct详解</title>
      <link href="/2024/09/12/task-struct%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/09/12/task-struct%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="pcb">PCB</h1><p>Process Control Block进程控制块</p><p>是操作系统中一个用于管理进程的一个抽象的数据结构，包含了进程的状态信息，程序计数器，寄存器内容， 内存管理信息，环境变， 打开的文件描述符的集合</p><p>task_struct 是linux内核对PCB的具体实现</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240927234621.png" alt=""></p><h1 id="task-struct">task_struct</h1><h3 id="进程标识">进程标识</h3><figure class="highlight plaintext"><figcaption><span>pid;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid_tpid;</span><br><span class="line">pid_ttgid;</span><br></pre></td></tr></table></figure><p>pid 取值0-32767</p><p>tpid 在Linux系统中，一个线程组中的所有线程使用与该线程组的领头线程相同的pid</p><p><font color='blue'>也就是同一个进程组的tgid是一样的，并且都是创建线程的主线程id</font></p><h3 id="进程状态">进程状态</h3><h4 id="运行状态">运行状态</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span>state;</span><br></pre></td></tr></table></figure><ol><li>task_running 可以运行或者是正在运行</li><li>task_interruptible 可以中断的等待状态，是针对等待某事件或其他资源的睡眠进程设置的，在内核发送信号给该进程表明事件已经发生时，进程状态变为TASK_RUNNING，它只要调度器选中该进程即可恢复执</li><li>TASK_UNINTERRUPTIBLE: 不可中断的等待状态，处于该状态的进程正在等待某个事件(event)或某个资源，它肯定位于系统中的某个等待队列(wait_queue)中，处于不可中断等待态的进程是因为硬件环境不能满足而等待，例如等待特定的系统资源，它任何情况下都不能被打断，只能用特定的方式来唤醒它，例如唤醒函数wake_up()等 它们不能由外部信号唤醒，只能由内核亲自唤醒</li><li>TASK_ZOMBIE: 僵死</li><li>TASK_STOPPED: 暂停，此时的进程暂时停止运行来接受某种特殊处理。通常当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或 SIGTTOU信号后就处于这种状态。例如，正接受调试的进程就处于这种状</li><li>TASK_TRACED</li><li>TASK_DEAD</li><li>TASK_SWAPPING: 换入/换出</li></ol><h4 id="flags进程标识符">flags进程标识符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span>usage; <span class="comment">// 进程描述符使用计数，为2的时候表示进程描述符正在被使用且对应的进程处于活动状态</span></span><br><span class="line"><span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>flags; <span class="comment">// 进程当前的状态标志，与state区分开</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ptrace;</span><br></pre></td></tr></table></figure><p>flags 标识的不是运行的状态 state ，而是与管理有关的其他信息</p><p>如 PF_SUPERPRIV 标识进程拥有超级用户特权 等等</p><h4 id="退出状态">退出状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>exit_state;</span><br><span class="line"><span class="type">int</span>exit_code;</span><br><span class="line"><span class="type">int</span>exit_signal;</span><br><span class="line"><span class="comment">/* The signal sent when the parent dies: */</span></span><br><span class="line"><span class="type">int</span>pdeath_signal;</span><br></pre></td></tr></table></figure><h3 id="进程内核栈">进程内核栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*<span class="built_in">stack</span>; <span class="comment">// 进程的内核栈</span></span><br></pre></td></tr></table></figure><h3 id="调度">调度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>on_rq;</span><br><span class="line"><span class="type">int</span>prio; <span class="comment">//调度器考虑的优先级保存在prio，由于在某些情况下内核需要暂时提高进程的优先级，因此需要第三个成员来表示（除了下面两个之外的第三个</span></span><br><span class="line"><span class="type">int</span>static_prio; <span class="comment">//静态优先级 进程启动的时候分配的优先级</span></span><br><span class="line"><span class="type">int</span>normal_prio;<span class="comment">//基于进程的静态优先级和调度策略算出来的优先级</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>rt_priority;<span class="comment">//实时进程的优先级</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>*<span class="title">sched_class</span>;</span><span class="comment">//普通进程的调度实体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span><span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span><span class="title">rt</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span>*<span class="title">sched_task_group</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span><span class="title">dl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line"><span class="comment">/* List of struct preempt_notifier: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">preempt_notifiers</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>btrace_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>policy; <span class="comment">// 调度策略 FCFS CFS ...</span></span><br><span class="line"><span class="type">int</span>nr_cpus_allowed;</span><br><span class="line"><span class="type">cpumask_t</span>cpus_allowed; <span class="comment">//控制进程可以在哪些cpu上运行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_RCU</span></span><br><span class="line"><span class="type">int</span>rcu_read_lock_nesting;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">rcu_special</span><span class="title">rcu_read_unlock_special</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">rcu_node_entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span>*<span class="title">rcu_blocked_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_PREEMPT_RCU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASKS_RCU</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>rcu_tasks_nvcsw;</span><br><span class="line">u8rcu_tasks_holdout;</span><br><span class="line">u8rcu_tasks_idx;</span><br><span class="line"><span class="type">int</span>rcu_tasks_idle_cpu;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">rcu_tasks_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_RCU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span><span class="title">sched_info</span>;</span> <span class="comment">// 调度器统计进程的运行信息</span></span><br></pre></td></tr></table></figure><h3 id="进程地址空间-内存管理">进程地址空间（内存管理）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>*<span class="title">mm</span>;</span> <span class="comment">// 指向进程所拥有的内存描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>*<span class="title">active_mm</span>;</span> <span class="comment">//指向进程运行时所使用的内存描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Per-thread vma caching: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmacache</span><span class="title">vmacache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SPLIT_RSS_COUNTING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_rss_stat</span><span class="title">rss_stat</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="信号处理">信号处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Signal handlers: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>*<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span>*<span class="title">sighand</span>;</span></span><br><span class="line"><span class="type">sigset_t</span>blocked;</span><br><span class="line"><span class="type">sigset_t</span>real_blocked;</span><br><span class="line"><span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line"><span class="type">sigset_t</span>saved_sigmask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span><span class="title">pending</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>sas_ss_sp;</span><br><span class="line"><span class="type">size_t</span>sas_ss_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>sas_ss_flags;</span><br></pre></td></tr></table></figure><h3 id="文件系统">文件系统</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filesystem information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>*<span class="title">fs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open file information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>*<span class="title">files</span>;</span></span><br></pre></td></tr></table></figure><h3 id="用户和权限">用户和权限</h3><h3 id="中断">中断</h3><h3 id="io调度">IO调度</h3><h3 id="进程链表">进程链表</h3><h3 id="进程通讯">进程通讯</h3><h3 id="进程亲属关系">进程亲属关系</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pointers to the (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment"> * older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment"> * p-&gt;real_parent-&gt;pid)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Real parent process: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>*<span class="title">real_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Recipient of SIGCHLD, wait4() reports: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>*<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Children/sibling form the list of natural children:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">children</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">sibling</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">group_leader</span>;</span></span><br></pre></td></tr></table></figure><h4 id="real-parent-vs-parent">real_parent vs parent</h4><p>real_parent 指向实际创建当前进程的父进程，</p><p>parent 指向当前父进程的逻辑父进程</p><p>也就是 real_parent一般是等于 parent的，但是如果real_parent终止了，那么parent可能就不等于real_parent了，<font color='red'>当real_parent终止的时候，init进程会接管当前进程，也就是parent会被设置为init进程（PID 1）</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux kernel </tag>
            
            <tag> PCB </tag>
            
            <tag> task_struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ac_tricks</title>
      <link href="/2024/09/09/ac-tricks/"/>
      <url>/2024/09/09/ac-tricks/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂算法">快速幂算法</h1><p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span><br>暴力方法 要乘n次 复杂度 <code>o(n)</code><br>快速幂 <code>o(logn)</code><br>a = a * a, 1 2 4 8 16<br>b的二进制 有没有 1 2 3 8 16 有就乘 a 没有不管</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果遇到 <mark> 求幂 + 结果要取模 </mark>，发现ac不了，可以使用快速幂，在中间取模<br><font color='blue'>不要用移位 或者 pow(a,b) </font></p><h1 id="子数组-子序列-子串">子数组 子序列 子串</h1><p>数组<br>子数组要求连续<br>子序列 只 要求顺序一致</p><p>字符串<br>子串 要求是位置连续的字符组成的<br>子序列 只 要求顺序一致 （也可以理解为从原来的字符串中删除一部分字符串</p>]]></content>
      
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie &amp;&amp; session</title>
      <link href="/2024/09/09/cookie-session/"/>
      <url>/2024/09/09/cookie-session/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要有cookie和session？">为什么要有cookie和session？</h1><p>因http是无状态的，如果用户每次打开一个关联页面都需要重新登陆，就很操蛋，所以引入cookie和session</p><h1 id="cookie">cookie</h1><p>Cookie主要用于以下方面：</p><ul><li>会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)</li><li>个性化设置(如用户自定义设置、主题等)</li><li>浏览器行为跟踪(如跟踪分析用户行为等)</li></ul><p>Cookie存储在客户端，这就意味着，可以通过一些方式进行修改，欺骗服务器。针对这个问题，怎么解决呢?那就引入了Session。</p><h3 id="cookie-如何计算">cookie 如何计算</h3><p>一个cookie 通常包含以下字段</p><ul><li><p><strong>name</strong>：Cookie名称，必须唯一。</p></li><li><p><strong>value</strong>：Cookie的值，可以是字符串。</p></li><li><p><strong>expires</strong>：Cookie的有效期，定义在何时过期（可选）。</p></li><li><p><strong>domain</strong>：Cookie所属的域名，指定哪些域可以访问该Cookie。</p></li><li><p><strong>path</strong>：指定Cookie适用的URL路径。</p></li><li><p><strong>secure</strong>：指定Cookie只能通过HTTPS发送。</p></li><li><p><strong>HttpOnly</strong>：防止客户端通过JavaScript访问Cookie，增加安全性。</p></li></ul><h3 id="cookie-使用流程">cookie 使用流程</h3><p>当客户端第一次请求服务器的时候，服务器通过HTTP响应头部中的字段<code>set-cookie</code> 向客户端发送cookie</p><p>客户端访问服务的时候， 通过cookie字段将对应的cookie 发送给服务器</p><h3 id="cookie存在哪里？">cookie存在哪里？</h3><p>浏览器的内存 或者浏览器的本地存储</p><p>内存 用于存储会话cookie ，仅在当前的浏览器会话期间有效，浏览器关闭的时候会被删除</p><p>磁盘 用于存储持久性cookie， 根据设置的过期时间长时间存储SQLite，会话结束之后仍然存在的cookie，会有一个过期时间</p><h1 id="session">session</h1><p>Session代表服务器和客户端一次会话的过程。</p><p>对照Cookie，Session是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。</p><p>当在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而会在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效时会话结束。</p><p>目前大多数的应用都是用Cookie实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中返回给客户端，在Cookie中记录SessionID，后续请求时传递SessionID给服务，以便后续每次请求时都可分辨你是谁。</p><p><font color='blue'> 也就是cookie是session的一种实现方式</font></p><h3 id="分布式系统中session如何处理">分布式系统中session如何处理</h3><p>如果用户在A服务器登录，Session位于A服务器，那么当下次请求被分配到B服务器，将会出现登录失效的问题。</p><p>针对类似的场景，有三种解决方案：</p><ol><li><p>请求精确定位。也就是通过负载均衡器让来自同一IP的用户请求始终分配到同一服务上。比如，Nginx的ip_hash策略，就可以做到。</p></li><li><p>Session复制共享。该方案的目标就是确保所有的服务器的Session是一致的。像Tomcat等多数主流web服务器都采用了Session复制实现Session的共享.</p></li><li><p>基于共享缓存。该方案是通过将Session放在一个公共地方，各个服务器使用时去取即可。比如，存放在Redis、Memcached等缓存中间件中。</p></li></ol><h3 id="同源和跨域请求">同源和跨域请求</h3><p>所谓的“同源”指的是“三个相同”：协议相同、域名相同、端口相同。只有这三个完全相同，才算是同源。</p><p>同源策略的目的：是为了保证用户信息的安全，防止恶意的网站窃取数据。</p><p>比如，用户访问了银行网站A，再去浏览其他网站，如果其他网站可以读取A的Cookie，隐私信息便会泄露。更可怕的是，通常Cookie还用来保存用户登录状态，会出现冒充用户行为。因此，&quot;同源策略&quot;是必需的，如果Cookie可以共享，互联网就毫无安全可言了</p><p>要求cookie来源相同才提供服务</p><p><font color='blue'>同源策略保证了一定的安全性，但在某些场景下也带来了不便，比如常见的跨域请求问题。</font></p><h1 id="区别">区别</h1><table><thead><tr><th></th><th>cookie</th><th>session</th></tr></thead><tbody><tr><td>作用范围</td><td>客户端</td><td>服务端</td></tr><tr><td>有效期</td><td>有效时间比较长</td><td>有效时间比较短</td></tr><tr><td>安全性</td><td>容易被窃取</td><td>在服务端不易窃取</td></tr><tr><td>大小</td><td>&lt; 4 k</td><td>远大于cookie</td></tr><tr><td>传输机制</td><td>发送cookie</td><td>发送一个sessionID即可，实际的会话数据存放在服务端</td></tr><tr><td>使用场景</td><td>适用于一些非敏感的用户偏好数据，如语言设置，主题颜色。。 适合持久化客户端状态，小数据和非敏感数据</td><td>存储敏感信息，比如用户的登录状态 购物车信息等，<font color='blue'>数据较为频繁、动态变化的时候优先使用session</font> 适合存储敏感信息和需要更强安全性的短期会话数据</td></tr></tbody></table><h1 id="禁用了cookie">禁用了cookie</h1><p>如果客户在浏览器禁用了Cookie，该怎么办呢?</p><p><mark>方案一：拼接SessionId参数</mark>。在GET或POST请求中拼接SessionID，GET请求通常通过URL后面拼接参数来实现，POST请求可以放在Body中。无论哪种形式都需要与服务器获取保持一致。</p><p>这种方案比较常见，比如老外的网站，经常会提示是否开启Cookie。如果未点同意或授权，会发现浏览器的URL路径中往往有&quot;?sessionId=123abc&quot;这样的参数。</p><p><mark>方案二：基于Token(令牌)</mark>。在APP应用中经常会用到Token来与服务器进行交互。Token本质上就是一个唯一的字符串，登录成功后由服务器返回，标识客户的临时授权，客户端对其进行存储，在后续请求时，通常会将其放在HTTP的Header中传递给服务器，用于服务器验证请求用户的身份。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++面经</title>
      <link href="/2024/09/05/c++%E9%9D%A2%E7%BB%8F/"/>
      <url>/2024/09/05/c++%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<p>c++ 面经</p><h3 id="c-this指针是干什么用的">c++ this指针是干什么用的</h3><h3 id="c-的new-和-delete-什么时候使用new-申请-可以用delete释放-free-和-delete-的区别">c++ 的new 和 delete 什么时候使用new[]申请 可以用delete释放，free 和 delete 的区别</h3><h3 id="c-的static关键字的作用">c++的static关键字的作用</h3><h3 id="c-的继承-多态">c++ 的继承 多态</h3><p>类和类的关系 继承a kind of … 组合 a part of</p><p>1、代码的复用</p><p>2、通过继承，在基类里面给所有派生类可以保留统一的纯虚函数接口，等待派生类进行重写，通过使用多态可以通过基类指针访问不同派生类的同名overwrite方法</p><h3 id="c-的继承多态-空间配置器-vector和list区别-map-多重map">C++的继承多态，空间配置器，vector和list区别，map 多重map</h3><p>静态多态：编译时期多态 函数模版和重载</p><p>动态多态 运行时多态 虚函数</p><p>空间配置器 allocator 给容器使用的，主要作用是把对象的内存开辟和对象狗仔分开，把对象构造和内存释放分开</p><p>为什么要分开？ 初始化容器 只需要 开辟空间，不需要创建对象 ，所以不能用new，new会构造对象</p><p>删除一个元素，只需要删除这个元素，而不需要delete释放内存，因为容器的空间还需要使用！释放整个容器，只需要释放有效的空间</p><p>vector 和 list 随机访问（优先级队列基于vector) vs 频繁增删</p><p>map 不允许key重复，映射表[key - value] ,红黑树，multimap 允许key重复</p><p>红黑树：优化的二叉排序树</p><p>5个性质，插入3种情况（最多选择2次） 删除（最多选择3次） 4种情况</p><h3 id="c-如何防止内存泄漏">c++如何防止内存泄漏</h3><p>使用智能指针</p><h3 id="c-如何调用c语言函数接口">c++如何调用c语言函数接口</h3><p>c/c++生成符号的方式不一样，c c++语言之间的API接口无法直接调用，所以需要使用 extern ”C“ {}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> <span class="comment">//C符号sum c++符号sum_int_int</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br></pre></td></tr></table></figure><h3 id="c-中类的初始化列表">c++中类的初始化列表</h3><p>成员初始化顺序与<mark>成员变量定义顺序</mark>有关系，与初始化列表的出现顺序没关系</p><p>可以指定对象成员变量的初始化方式，尤其是指定成员对象的构造方式</p><h3 id="c-c-区别">C/C++区别</h3><ol><li>引用 智能指针</li><li>函数重载 运算符重载</li><li>const inline 带默认值参数的函数</li><li>new delete</li><li>类对象 oop</li><li>模版</li><li>异常处理</li><li>STL</li></ol><h3 id="int-const-p-和-const-int-p">int* const p 和 const int *p</h3><p>int* const p p不能修改</p><p>const int *p p可以修改 但是int 不能修改</p><h3 id="malloc和new-的区别">malloc和new 的区别</h3><ol><li>malloc按照字节开辟内存 ，new底层也是malloc 但是还可以提供初始化</li><li>malloc开辟内存失败 返回 nullptr new开辟失败 抛出bad_alloc异常</li><li>malloc C的库函数 operator new</li><li>malloc单个数组，new int(10); new int[20] ();</li></ol><h3 id="stl">STL</h3><p>标准容器-》顺序容器 （vector， deque， list），容器适配器（stack-&gt;deque，queue-&gt;queue，priority_queue-&gt;vector) ， 关联容器（有序和无序）</p><p>迭代器 泛型算法</p><h4 id="迭代器失效的问题">迭代器失效的问题</h4><p>迭代器不允许一边读一边修改的</p><p>当通过迭代器插入一个元素，所有迭代器就都失效了</p><p>通过迭代器删除一个元素，当前删除位置到后面所有的迭代器都是失效了</p><p>当通过迭代器更新容器元素之后，要及时对迭代器进行更新，insert/erase 都会返回新的有效的迭代器</p><h3 id="struct-和-class">struct 和 class</h3><ol><li><p>定义类的时候，前者默认共有，后者默认私有</p></li><li><p>继承 class B：A 私有继承 struct B：A 共有继承</p></li><li><p>struct空结构体是0， struct空类是 1</p></li><li><p>class 在template&lt;class T&gt;还可以定义模版类型参数</p></li></ol><h3 id="data-bss">data bss</h3><p>Data 初始化且初始值不为0</p><p>bss 未初始化 / 初始化为0</p><h3 id="堆和栈的区别">堆和栈的区别</h3><p>堆大小 &gt;&gt; 栈内存</p><table><thead><tr><th></th><th>heap</th><th>stack</th></tr></thead><tbody><tr><td>大小</td><td>大</td><td>小</td></tr><tr><td>增长放下</td><td>低到高</td><td>高到低</td></tr><tr><td>释放</td><td>自己请求分配 释放</td><td>esp上上下下 不用管释放</td></tr></tbody></table><p>push ebp</p><p>Mov ebb, esp</p><p>Mov esp, ebp</p><p>pop ebp</p><p>Ret</p><h3 id="构造函数-和析构可以不可以是虚函数-为什么？">构造函数 和析构可以不可以是虚函数 为什么？</h3><p>虚函数的作用是什么？实现多态，基类指针指向派生类的对象，调用基类虚函数的时候，实际调用的是子类的虚函数</p><p>当继承的时候，需要先构造基类 在子类，所以构造函数不能是虚函数</p><p>构造函数 不能是虚函数</p><p><mark>基类的析构函数必须是虚析构函数</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>(); </span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 如果是虚析构， 就会调用调用的时候进行动态绑定</span></span><br><span class="line">如果不是虚的，调用的析构就是基类的 内存泄漏</span><br></pre></td></tr></table></figure><h3 id="析构函数-和-构造函数能不能抛出异常-why？">析构函数 和 构造函数能不能抛出异常， why？</h3><p>析构不能抛出，抛异常之后，之后的代码就不会执行，那么</p><p>就会发生泄漏</p><p>构造也不能抛出异常，抛出异常之后，对象失败，就不会调用对象的析构函数，内存释放</p><h3 id="宏和内联函数的区别">宏和内联函数的区别</h3><p>define 预编译阶段 字符串替换</p><p>inline 编译阶段，在函数调用点 直接展开函数</p><p>调试 宏没有办法调试 ，inline函数可以调试（debug版本下inline就和普通函数 ，有标准的函数调用过程</p><p>#define 可以定义常量 代码块 函数块</p><h3 id="拷贝构造函数-为什么传引用而不传值">拷贝构造函数，为什么传引用而不传值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">const</span> Test t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是传值，那么 const Test t 本身形参 又需要 初始化 又得调用自身，</p><p><mark> 会直接产生编译错误 </mark></p><h3 id="如何实现一个不可以被继承的类">如何实现一个不可以被继承的类</h3><p>派生类的初始化过程：基类构造 -&gt; 派生类构造</p><p><mark> 基类的构造函数私有化</mark></p><h3 id="纯虚函数-为什么要有纯虚函数-虚函数表放在哪？">纯虚函数，为什么要有纯虚函数，虚函数表放在哪？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>抽象类 不能实例化对象，但是可以定义指针和引用</p><p>一般定义在基类里面，基类不代表任何实体，他的主要作用之一就是给所有的派生类保留统一的纯虚函数，让子类重写</p><p><mark>虚函数表在编译阶段产生，运行时，加载到.rodata段,用指针或者引用  调用虚函数 指针访问对象的头4个字节，vftable中去出虚函数的地址，进行动态绑定调用 </mark></p><h3 id="const-const-与-static-的区别">Const ,const 与 static 的区别</h3><p>const定义的叫常量，它的编译方式是，在编译过程中，把出现常量名字的地方，用常量的值进行替换</p><p>const 还可以定义常成员方法 Test * this =》 const Test *this; 普通对象和常对象就都可以调用了</p><p>面向过程</p><p>const 全局变量 局部变量 形参变量 static 全局变量 局部变量</p><p>const 不能修饰函数 static 可以修饰函数</p><p>面向对象</p><p>const 常方法/成员变量 Test * this =》 const Test *this 不依赖对象</p><p>static 静态方法/成员变量 Test * this 没有了 不依赖于对象，通过类作用域来访问</p><h3 id="deque的底层">deque的底层</h3><p>#define MAP_SIZE 2</p><p>#define QUE_SIZE(T) 4096/sizeof(T)</p><p>一维数组的初始大小 是MAP_SIZE(T*)</p><p>第二维数组默认开辟大小就是QUE_SIZE(int) = 1024</p><p>扩容 两倍扩容 2-4-8-16，扩容以后，会把原来的数组复制到中间</p><p>stack queue-&gt; 底层都是 deque 为什么？</p><p>内存利用率高，刚开始就有一段内存可以使，</p><p>pritority_queue 利用下标来计算数 所以需要使用vector</p><h4 id="早绑定和晚绑定">早绑定和晚绑定</h4><p>早绑定（静态绑定）：普通函数的调用，用对象调用虚函数call编译阶段已经知道掉那个函数</p><p>晚绑定（动态绑定）：用指针/引用调用虚函数的时候，都是动态绑定</p><h4 id="指针和引用的区别">指针和引用的区别</h4><p>指针多级， 引用 没有多级引用，引用必须赋初值</p><h2 id="unordered-map-vs-map">unordered_map vs map</h2><p>底层 哈希表 VS 红黑树</p><p>使用场景</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论</title>
      <link href="/2024/09/05/%E6%95%B0%E8%AE%BA/"/>
      <url>/2024/09/05/%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="质数">质数</h1><p>只有1 和本身是 因子的数 1， 2， 3 ，5 ，7 ，11 …</p><h3 id="1-试除法">1、试除法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> || n % <span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i * i &lt;= n; i += <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> || n % (i + <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-埃拉托斯特尼筛法-埃氏筛">2 、埃拉托斯特尼筛法(埃氏筛)</h3><p>如果需要判断多个数是否为质数，埃拉托斯特尼筛法能高效生成一段范围内的所有质数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieveOfEratosthenes</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(limit + <span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">2</span>; p * p &lt;= limit; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[p]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = p * p; i &lt;= limit; i += p) &#123;</span><br><span class="line">                isPrime[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Prime numbers up to &quot;</span> &lt;&lt; limit &lt;&lt; <span class="string">&quot; are: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">2</span>; p &lt;= limit; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[p]) &#123;</span><br><span class="line">            std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小公约数gcd">最小公约数gcd</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="comment">// 递归版本</span></span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b); <span class="comment">// 欧几里得算法 辗转相除法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="comment">// 迭代版本</span></span><br><span class="line">  <span class="keyword">while</span>(b ! =<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> tmp = b;</span><br><span class="line">    b = a % b;</span><br><span class="line">    a = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alogrithm&gt;</span></span></span><br><span class="line">__gcd(<span class="type">int</span> a,<span class="type">int</span> b)</span><br></pre></td></tr></table></figure><h1 id="最小公倍数lcm">最小公倍数lcm</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> &gt;= c++17</span></span><br><span class="line">std::<span class="built_in">lcm</span>(a, b);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 质数 </tag>
            
            <tag> 最小公倍数lcm </tag>
            
            <tag> 最大公约数gcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试记录</title>
      <link href="/2024/09/05/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/09/05/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="字节一面">字节一面</h1><p>128个数据，取出前面最大的10个</p><p>堆 时间复杂度</p><p>redis 分布式锁</p><p>一道 滑动窗口</p><p>环形双向链表 0-5 13步 从 0 出发回到 0 有几种 -1 % 5 = -1</p><h1 id="oppo一面">oppo一面</h1><p>面试官jave golang，不会c++, 猛攻项目</p><p>聊天服务器</p><p>如何保证消息发送到对面了，存消息,收到ack</p><p>如何保证消息的顺序性, 消息ID, 如何避免重复发送</p><p>消息存怎么存, 在服务区还是客户端, 以什么方式存, A-B聊天, 这个数据需要存两份吗?还是什么?</p><p>其他忘了</p><h1 id="字节二面-寄">字节二面 寄</h1><p>面试官气场很强</p><ol><li>抢红包问题，要求最小单位0.01，每个人都能抢到钱，每个人都以机会抢到最大金额， 对于一个金额的红包，每个人拿到他的机会是均等的<ul><li>注意事项 浮点数的处理问题 可以用10000来表示100块，化浮点数为整数，以及注意分钱的时候最后一位不用分，剩下的钱就是最后一个红包</li></ul></li><li>问实习的事情</li><li>问一个系统 需要实现大学课程系统，一门课程可以有多个老师上课，要求支持学生查成绩，<ul><li>设计几个页面</li><li>怎么设计表</li><li>寄</li></ul></li></ol><h1 id="美团一面-寄">美团一面 寄</h1><p>面试官发型比较强大，直接是🧑‍🦲</p><ol><li><p>进程 线程 协程</p></li><li><p>陷入内核空间算不算中断？？</p></li><li><p>unordered_map Vs map底层实现 和 使用场景</p></li><li><p>一致性哈希， 哈希环，虚拟节点</p><ul><li>一台机器加入进来，有几台机器的请求会发到新机器上</li><li>一台机器A宕机，原先发往A的请求 会 发到几台机器上？？</li><li>答的不好， 寄了</li></ul></li><li><p>问了HTTP的字段有哪些? cookie放在哪? 字段还是</p><ul><li><p><code>host</code> <code>content-length</code> <code>connection</code> <code>content-type</code> <code>accept</code> <code>accept-encoding</code> <code>content-encoding</code> <code>range</code></p><p>以及一些缓存控制的字段</p></li><li><p>cookie存放在哪里?</p></li></ul></li><li><p>epoll select poll 区别</p></li><li><p>算法题 找出k个最小的数  要求复杂度<code>o(nlogk)</code></p><ul><li>堆排序 静态建堆<code> o(n + klogn)</code></li><li>动态建堆 每次数字向下down 超过logk 次就不用down了,因为这个数字不可能是k小的, 所以 每个数字最多down logk次, 复杂度<code>o(nlogk)</code></li><li>面试官给了动态建堆的提示, 但是我是傻逼,没做出来</li></ul></li></ol><h1 id="百度">百度</h1><p>9.11 20.00<br>检测内存泄漏的工具 valgrind Asan（AddressSanitizer） Dr. Memory, Purify</p><p>bool max(int &amp;x);<br>进程线程之间的区别<br>进程初始化的时候如何分配资源 销毁的时候如何回收资源<br>静态函数 函数<br>全局变量 静态变量<br>auto VS decltype</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th><code>auto</code></th><th><code>decltype</code></th></tr></thead><tbody><tr><td>类型推导方式</td><td>根据初始化表达式推导类型，去掉 <code>const</code> 和引用</td><td>精确推导表达式的类型，保留 <code>const</code> 和引用</td></tr><tr><td>需要初始化表达式</td><td>是</td><td>否</td></tr><tr><td>典型用途</td><td>简化变量声明，推导初始化表达式的类型</td><td>获取变量、表达式的准确类型</td></tr><tr><td>处理左值与右值</td><td>对左值类型不会推导为引用</td><td>对左值推导出引用类型</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// y 的类型是 int 去掉了 const</span></span><br><span class="line"><span class="keyword">auto</span>&amp; y = x; <span class="comment">// 类型是const int&amp;, 保留了const 和引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(x) z = x; <span class="comment">// z的类型是const int</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x;</span><br><span class="line"><span class="keyword">decltype</span>(red) b = x; <span class="comment">//ref 类型是 int &amp; </span></span><br></pre></td></tr></table></figure><p>堆如何实现的<br>介绍c++容器 和 底层实现<br>动态库的加载问题</p><p>编程题 最大栈</p><h1 id="快手">快手</h1><p>9.12 14:00<br>编程 实现stoi 考虑负数和超过整型的字符串</p><p>epoll select<br>read write返回的状态码<br>backlog参数<br>redis 如何处理热key 的请求<br>top 查看线程 如何查看磁盘 IO 网络这些  <code>htop</code> <code>iotop</code> <code>netstat</code><br>函数重载和重写的区别<br>TCP UDP的区别<br>虚函数如何实现的<br>用过gdb吗<br>sendfile<br>三次握手 timeout 的原因是 什么<br>inline函数 和 普通函数<br>vector 分配 空间<br>unordered_map vs map<br>建议：项目可以考虑得深入一些</p><h1 id="科大讯飞二面">科大讯飞二面</h1><p>9.12 19.00<br>寄中寄<br>100万的IP地址如何查找一个某个IP<br>Muduo库 事件驱动模式<br>one loop per thread 存在什么缺点 提示 面对IO密集型的任务的时候<br>muduo 库的缓存是如何设计的 为什么这么设计<br>如何实现一个无锁队列，CAS 说CAS不对<br>问CI CD<br>问TCP的keep - alive<br>mysql数据库的连接池满了怎么办 如果这个时候有了新的请求来了怎么办？</p><p>议是：http webserver 没啥吊用</p><h1 id="百度二面">百度二面</h1><p>9.14 21：00<br>-&gt; 9.18 20:00<br>MUDUO库用到了哪些设计模式<br><mark> 单例模式 观察者模式（channel） 简单工厂 reactor模式 线程池模式 RAII模式（智能指针）</mark><br>epoll是如何实现的 红黑树 具体是怎么实现的？<br>教室场景行为识别演示系统<br>最近在看什么书<br>未来三年的职业规划<br>训练一个分类猫狗等100个类的模型，需要注意什么？</p><p>反问环节<br>什么部门 什么业务 技术栈是什么？ IDG 地图BU 手机地图 车机地图 …<br>加班情况</p>]]></content>
      
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ST表</title>
      <link href="/2024/09/04/ST%E8%A1%A8/"/>
      <url>/2024/09/04/ST%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="st表">ST表</h1><p>sparse table 稀疏表， 是用于解决可重复贡献问题的一种数据结构</p><h5 id="什么是可重复贡献问题？">什么是可重复贡献问题？</h5><blockquote><p>是指对于运算<code>opt</code>，满足<code>x opt x = x</code>，则对应的区间询问就是一个可重复贡献问题。例如，最大值有<code>max(x,x) = x</code>，gcd 有<code>gcd(x,x)=x</code>，所以 RMQ 和区间 GCD 就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外，opt还必须满足结合律才能使用 ST 表求解。</p></blockquote><p>也就是区间重复 不会影响结果 ，</p><p>RMQ ：range Maximum/Minimum query 区间最大最小值</p><p>区间最大最小， GCD，区间与， 区间或 都是可重复贡献问题</p><h2 id="例题">例题</h2><p>给定n个数，有m个询问，对于每个询问，需要回答[l,r]中的最大值</p><p>暴力做法，每次都线性扫描一遍， 求出最大值，显然会超时</p><h2 id="倍增思想">倍增思想</h2><p>binary lifting 倍增，<font color='blue'> 它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。</font></p><p>最常用的是RMQ问题 和 求LCA（树上最近公共祖先）</p><h3 id="例题1">例题1</h3><p>如何使用尽量少的砝码量出[0,31]之间的所用重量？只能在天平的一端放砝码</p><blockquote><p>砝码重量为 1 2 4 8 16，即可，也就是值域【0，n】 砝码数量只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span></span>即可，值域翻倍，砝码个数只需要+1</p></blockquote><h3 id="例题2">例题2</h3><p>给一个长度为<code>n</code>的环和一个常数<code>k</code>，每次会从第i个点跳到第<code>(i+k)mod n + 1 </code>个点，总共跳了m次，每个点都有一个权值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,求m次跳跃的起点的权值之和对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>取模的结果</p><p>数据范围：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\leq n \leq 10^6, 1 \leq m \leq 10^{18}, 1 \leq k \leq n, 0 \leq a_i \leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><h4 id="暴力">暴力</h4><p>m次最大是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>,  超时</p><h4 id="倍增">倍增</h4><h2 id="st表">ST表</h2><p><code>o(nlogn)</code>预处理建表， <code>o(1)</code> 查询，不支持修改操作</p><p>暴力的做法等于是遍历每个可能的区间，线性扫描</p><p><font color='blue'>倍增的想法是利用 倍增的区间 来表示 整个可能的区间，由于是可重复贡献问题，所以倍增之后的区间作 <code>opt</code> 不会影响最后的结果</font></p><p>具体实现 <code>f(i,j)</code> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, i + 2^j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 内的最大值</p><p>则<code>f(i,0) = ai</code></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i,j) = max(f(i,j-1), f(i + 2^{j-1}, j-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.069104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>对于每个区间[l,r] 给他 不遗漏的划分出两个区间，可以重叠</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>l</mi><mo>+</mo><msup><mn>2</mn><mi>s</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, l + 2^s -1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>−</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[r - 2^s +1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p><p>也就是</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><msup><mn>2</mn><mi>s</mi></msup><mo>−</mo><mn>1</mn><mo>≥</mo><mi>r</mi><mo>−</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l + 2^s -1 \geq r - 2^s +1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7977219999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7977219999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>解出来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor log_2{(r-l+2)} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span><span class="mclose">⌋</span></span></span></span></p><h2 id="代码模版">代码模版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SparseTable</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> VT = vector&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> VVT = vector&lt;VT&gt;;</span><br><span class="line">  <span class="keyword">using</span> func_type = function&lt;<span class="built_in">T</span>(<span class="type">const</span> T &amp;, <span class="type">const</span> T &amp;)&gt;;</span><br><span class="line"></span><br><span class="line">  VVT ST;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> T <span class="title">default_func</span><span class="params">(<span class="type">const</span> T &amp;t1, <span class="type">const</span> T &amp;t2)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">max</span>(t1, t2); &#125;</span><br><span class="line"></span><br><span class="line">  func_type op;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SparseTable</span>(<span class="type">const</span> vector&lt;T&gt; &amp;v, func_type _func = default_func) &#123;</span><br><span class="line">    op = _func;</span><br><span class="line">    <span class="type">int</span> len = v.<span class="built_in">size</span>(), l1 = <span class="built_in">ceil</span>(<span class="built_in">log2</span>(len)) + <span class="number">1</span>;</span><br><span class="line">    ST.<span class="built_in">assign</span>(len, <span class="built_in">VT</span>(l1, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      ST[i][<span class="number">0</span>] = v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; l1; ++j) &#123;</span><br><span class="line">      <span class="type">int</span> pj = (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + pj &lt; len; ++i) &#123;</span><br><span class="line">        ST[i][j] = <span class="built_in">op</span>(ST[i][j - <span class="number">1</span>], ST[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lt = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// int lt = r - l + 2;</span></span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">floor</span>(<span class="built_in">log2</span>(lt));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">op</span>(ST[l][q], ST[r - (<span class="number">1</span> &lt;&lt; q) + <span class="number">1</span>][q]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建表复杂度 o(nlogn)</p>]]></content>
      
      
      
        <tags>
            
            <tag> ST表 </tag>
            
            <tag> 可重复贡献问题 </tag>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一张表</title>
      <link href="/2024/09/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%BC%A0%E8%A1%A8/"/>
      <url>/2024/09/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%BC%A0%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="设计表的流程">设计表的流程</h1><ul><li>需求分析 根据需求 分析出哪些数据需要记录</li><li>概要设计 根据分析出的数据，设计ER图</li><li>详细设计 ER图 - 》 数据库模型图和数据表</li></ul><h2 id="瀑布模型-vs-螺旋模型">瀑布模型 vs 螺旋模型</h2><h3 id="瀑布模型">瀑布模型</h3><p>什么是瀑布模型，一次性的，没有迭代回溯的，做完需求分析之后，就不会回到该阶段了，直接进入下一阶段，所以，如果有中途修改需求的话，推倒重来的代价非常大</p><p>适合瀑布模型的前提是：</p><ol><li>非常明确的需求</li><li>用户不会在中途修改需求</li></ol><p>如果没有一个明确的需求，只是什么火做什么，那么就不适合瀑布，适合使用螺旋模型</p><h3 id="螺旋模型">螺旋模型</h3><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240903204737.png" alt=""></p><p>四个象限，每次开发都会走这四个象限，有回溯的开发模型</p><p>第一次迭代，开发项目核心，当将来项目有新的需求时，再做下一次迭代开发，这种小步快跑的开发模式就是螺旋模型了。</p><p>就算这一次开发失败了，我们只需要推翻这一次迭代的项目。</p><p>举个例子：你老板在别的地方看到一个非常不错的系统，让你模仿一个管理系统，由于老板并不清楚所有的业务模块划分，反正就是叫你模仿。</p><p>如果使用螺旋模型，先提炼出它最想要的核心功能，你的团队花费两周时间的迭代开发，然后拿着这个成果去跟老板确认，如果是老板想要的，就继续下一个功能的迭代开发。就算老板不满意，这成本也不是很高。</p><h3 id="所以数据库应该使用什么模型？？">所以数据库应该使用什么模型？？</h3><p>瀑布模型</p><p>因为数据库设计的修改，产生的连带性是很大的。比如，我们修改了一个字段名，那么后端 java 项目需要修改相关的代码，前端项目要同样要修改。这种连带性就很大。</p><p>因此数据库设计适合使用瀑布模型。提前设计好完整健壮的数据库。</p><h1 id="什么是erd？">什么是ERD？</h1><p>实体关系图 Entity Relation Diagram 提供了表示实体类型 熟悉 和关系的方法，用来描述现实世界的概念模型</p><p>有以下几个关键元素：</p><ul><li>矩形表示 实体</li><li>椭圆形表示字段</li><li>主键 在字段上使用下划线</li><li>菱形 外键约束</li></ul><blockquote><p>什么是外键？</p><p>是数据库中用于建立和加强数据之间关系的一种约束。它是一列或多列，<mark>在一个表中表示对另一个表中主键的引用</mark>。外键的主要作用是确保数据的引用完整性（Referential Integrity），即防止出现孤立或不匹配的数据记录。</p><p>外键所在的表为子表，外键引用的表称之为父表，子表中的外键列存储的值必须在父表中的主键列中存在，确保引用的记录在父表中有对应的存在。</p><p><mark>外键约束</mark>: 外键约束是一种规则，强制子表中的外键值必须是父表中的一个有效值，或者为空（在外键允许为空的情况下）。</p></blockquote><p>系统范围内的主要实体，+  实体之间的相互关系</p><p>绘制ER图 visio</p><h2 id="er图属性语法">ER图属性语法</h2><h4 id="复合属性">复合属性</h4><p>是多个属性的组合 eg 工号 是 公司 部门 数字序号的组合</p><h4 id="多值属性">多值属性</h4><p>某个属性可以有多个不同取值，比如员工有多个角色，正式工+leader +项目负责人+…</p><h4 id="派生属性">派生属性</h4><p>不保存在实体中的属性，用虚线的椭圆表示</p><p>简单说， 派生属性是运算出来的结果</p><h4 id="可选属性">可选属性</h4><p>允许没有值的 属性 比如说备注 在字段下用(0)来表示</p><h2 id="实体关系语法">实体关系语法</h2><h3 id="一对一">一对一</h3><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240903233204.png" alt=""></p><p>菱形的上方含义是：办公电脑只要有员工编号，就可以通过编号查询到这台办公电脑；</p><h3 id="一对n">一对N</h3><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240903233335.png" alt=""></p><h3 id="n对n">N对N</h3><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240903233357.png" alt=""></p><h1 id="案例一-新零售数据结构设计">案例一 - 新零售数据结构设计</h1><p>产品 vs 商品</p><p>eg iphone12 是产品， ip12 128g 远峰蓝是商品</p><h2 id="需求">需求</h2><p>用户模块，新闻模块，评论模块，成员模块，链接模块，论坛模块，产品模块</p><p>用户模块</p><p>shux</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> ER图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2024/09/01/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2024/09/01/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="使用场景">使用场景</h2><p>适合求解 区间修改 区间查询，单点修改 <code>logN</code>的时间复杂度</p><p>且最终的答案可以通过子区间的合并结果得出</p><p>比如<code>[L,R]</code>的结果可以由<code>[L, M] [M+1,R]</code>求出 区间可加性</p><p>区间和 区间最大最小 区间异或等等</p><h2 id="基本结构">基本结构</h2><p>就是堆的数据结构，堆的每个叶子节点是 原始数组的数据</p><p>父节点是子区间的结果</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240921235710.png" alt=""></p><blockquote><p>那么堆的大小应该是多少？？？</p></blockquote><p>如果树的深度是 k， 那么叶子数量<code>cnt</code>至多是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>  也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>≤</mo><msup><mn>2</mn><mi>k</mi></msup><mo>=</mo><mo>&gt;</mo><mi>k</mi><mo>≥</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow></mrow><annotation encoding="application/x-tex">cnt\leq2^k =&gt; k\geq log_2{cnt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></span></p><p>知道叶子的个数应该是n，则树的深度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>=</mo><mo>&gt;</mo><mi>k</mi><mo>=</mo><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">k \geq log_2{n} =&gt; k = \lceil log_2{n} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mclose">⌉</span></span></span></span></p><p>则由深度反推叶子应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">⌉</mo><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{\lceil log_2{n} \rceil + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌈</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span><span class="mclose mtight">⌉</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>,也就是节点的最大数量是这个，也可以直接把节点上了开到4n</p><h3 id="区间与节点的对应关系">区间与节点的对应关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)</span><br><span class="line">    <span class="keyword">return</span> d[p];  <span class="comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">  <span class="type">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>), sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum += <span class="built_in">getsum</span>(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span>(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间修改和优化">区间修改和优化</h3><p>例如 要给[3,5]区间内的所有数字都加上5，如果每次都递归到子节点更新，多次修改的时间复杂度难以接受，</p><blockquote><p>思想， 每次更新只更新到当前修改区间的最大子区间，更小的子区间就不更新，而是在当前区间打上标记，等到下次查询需要使用到更小的子区间的时候，将标记下传更新lazy tag</p></blockquote><div style="display: flex; justify-content: center; align-items: center; flex-direction: column; max-width: 600px; margin: auto; border: 1px solid #ddd; padding: 20px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);">  <img id="image" src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240922004736.png" style="width: 100%; max-width: 500px; border-radius: 10px;">  <button onclick="nextImage()" style="margin-top: 10px; padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);">Next</button></div><script>  var images = [ 'https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240922004736.png', 'https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240922004741.png', 'https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240922004906.png'  ];  var currentIndex = 0;   function nextImage() {    currentIndex = (currentIndex + 1) % images.length;    document.getElementById('image').src = images[currentIndex];  }  </script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p</span></span><br><span class="line">  <span class="comment">// 为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">    d[p] += (t - s + <span class="number">1</span>) * c, b[p] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;  <span class="comment">// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span></span><br><span class="line">  <span class="type">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b[p] &amp;&amp; s != t) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m);</span><br><span class="line">    b[p * <span class="number">2</span>] += b[p], b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p];  <span class="comment">// 将标记下传给子节点</span></span><br><span class="line">    b[p] = <span class="number">0</span>;                                <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) <span class="built_in">update</span>(l, r, c, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) <span class="built_in">update</span>(l, r, c, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询">区间查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  <span class="comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">  <span class="type">int</span> m = s + ((t - s) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (b[p]) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m);</span><br><span class="line">    b[p * <span class="number">2</span>] += b[p], b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p];  <span class="comment">// 将标记下传给子节点</span></span><br><span class="line">    b[p] = <span class="number">0</span>;                                <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum = <span class="built_in">getsum</span>(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span>(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka</title>
      <link href="/2024/08/29/kafka/"/>
      <url>/2024/08/29/kafka/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka是什么？">kafka是什么？</h2><blockquote><p>可不是村上春树的《海边的卡夫卡》哦</p></blockquote><p>kafka是消息队列MQ，消息中间件的一种</p><h2 id="为什么需要使用消息队列？？">为什么需要使用消息队列？？</h2><p>主要就是三个目的 解耦 异步 消峰</p><h3 id="解耦">解耦</h3><p>如果不使用 MQ，有多个系统或者集群之间需要通信的时候，就需要建立系统和集群之间的连接，如果需要增加或者减少系统或者集群节点，就需要删除/增加连接，<mark>非常麻烦，扩展性几乎没有</mark></p><p>所以这个时候可以使用消息队列，来作为中间件解耦各个系统，系统只需要连接到消息队列中就可以了，不需要管其他的，删除也只需要从消息队列移除就好了，<mark>方便， 扩展性拉满</mark></p><h4 id="有什么问题吗？">有什么问题吗？</h4><p>引入了更多的组件，本来系统只需要使用A B C三个系统之间互相通信就可以，现在加入了MQ，系统的复杂性增加了，可用性可能就降低了，因为多了一个环节，<font color='blue'>多做多错（不是</font> ,例如如何保证 消息确实被消费了，如何保证消息不会被重复消费</p><p>以及<mark>一致性问题</mark> “A系统处理完了直接返回成功了，人都以为你的请求成功了，但是问题是，要在BCD三个系统中，BD两个系统写库成功了，结果C系统写库失败了，这样就会存在数据不一致的问题。”</p><p>但是好处比坏处多，所以还是得用！</p><h3 id="异步">异步</h3><p>下面的一个场景就是系统A，调用了其它三个系统的服务，我们发现用户在执行一个请求后，需要花费很长的时间，如果是同步的，那么请求就要卡在这，结果就是用户端感觉是卡卡的，</p><p>使用MQ进行异步优化，使得A直接发送消息请求到MQ中直接返回，然后其他系统负责执行，这样就不会被阻塞住</p><h3 id="削峰">削峰</h3><p>如果没有MQ，用户的请求永远直接打到系统，系统再去查询数据库，在用户请求高峰期的时候，<mark>数据库容易被直接打死</mark></p><blockquote><p>一般的MySQL，抗到QPS=2000的时候就已经达到了瓶颈，如果每秒请求达到了5000的话，可能直接就把MySQL打死了。如果MySQL被打死，然后整个系统就崩溃，然后系统就没法使用。</p></blockquote><p>但是过了高峰期，请求又降下来了，这个时候又没人用</p><p>所以可以考虑使用MQ作为缓冲，将请求存下来，按照数据库的查询速度来慢慢消费，</p><blockquote><p>削峰就是大量的请求过来，然后MQ将其消化掉了，然后通过其它系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。</p><p>高峰期打过来的请求不是不消费，而是放到MQ中有序消费</p><p><s><font color='blue'>“不是不生，是下辈子生”</font></s> :dog:</p></blockquote><h2 id="常用的mq有哪些？？">常用的MQ有哪些？？</h2><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10万级</td><td>10万级</td></tr><tr><td>时效性</td><td>ms</td><td>us</td><td>ms</td><td>ms</td></tr><tr><td>可用性</td><td>主从架构 高可用</td><td>主从架构 高可用</td><td>分布式架构 非常高</td><td>分布式架构  非常高</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢</td><td>消息不丢失</td><td>经过参数配置可以做到0丢失</td><td>经过参数配置可以做到0丢失</td></tr><tr><td>核心特点</td><td>MQ该有的功能都有</td><td>基于Erlang开发，并发能力强，性能极好，延迟低</td><td>MQ功能较为完善，分布式，高可用，扩展性好</td><td>功能较为见到，支持简单的MQ，高可用</td></tr><tr><td></td><td>偶尔丢消息，虽然很成熟，功能也强大，但是比较少使用</td><td>erlang用的人比较少，虽然性能很强，开源，但是没什么人用，可能因为语言比较偏门？</td><td>阿里的，接口简单，吞吐量大，分布式高可用，扩展性也好，适合复杂MQ业务场景，底层java</td><td>仅提供较少的核心功能，但是超高吞吐率，ms级别延时，分布式扩展性可用性都🐮，同时kafka最好是支撑较少的topic数量即可，保证其超高的吞吐率</td></tr></tbody></table><h2 id="如何保证消息队列的高可用？？">如何保证消息队列的高可用？？</h2><p>也就是消息重复消费，消息丢失的问题</p><h3 id="rabbitmq高可用性">RabbitMQ高可用性</h3><p>有三种模式，单机模式，普通集群模式，镜像集群模式</p><h4 id="单机模式">单机模式</h4><p>顾名思义，部署在单机，可用性几乎为0，一般就是本地启动后玩一玩，没有人生产环境中使用。</p><h4 id="普通集群模式">普通集群模式</h4><p>每台机器启动一个RabbitMQ实例，然后集群，但是只有一台A是有真正的数据，其他的实例只是存放了元数据，消费的时候，要么连接到了A直接消费，要么连接到了B，然后从A拉去数据消费，</p><p>缺点，如果A宕机了，所有其他设备都不可以用，并且如果是连接到A消费，则A有性能瓶颈，如果连接到了非A的机器， 会有从A拉去数据的开销</p><h4 id="镜像集群模式">镜像集群模式</h4><p>每个实例都存有所有的数据，每次写消息都要同步写入到所有的实例中，</p><p>好处，有一个宕机了还有其他的可以用</p><p>坏处，所有机器都有所有的消息数据，非常冗余，性能开销提升，消息同步所有的机器，导致网络带宽压力和消耗增加，第二就是没有什么扩展性，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue</p><h3 id="kafka的高可用">Kafka的高可用</h3><p>分布式！</p><p>基本结构，多个broker组件，每个broker是一个节点一台服务器就是一个broker（掮客），一个topic可以被划分为多个partition（也就是每个partition只放一部分数据），每个partition存在于不同的broker上<img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240909151757.png" alt=""></p><p><font color='blue'>这就是天然的分布式消息队列，就是说一个topic的数据，是分散在多个机器上的，每个机器上就放一部分数据。</font></p><p><strong>每个topic的partition只有一份吗？一份的话这唯一的丢失了怎么办？</strong></p><p>kafka0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法读也没办法写，没有什么高可用可言，</p><p><strong>解决办法，每个partition提供副本</strong></p><p>而在0.8版本后，提供了HA机制，就是replica副本机制，每个partition的数据都会同步到其它机器上，形成自己的多个replica副本，然后所有的replica就是<mark>follower</mark>，写的时候，<mark>leader</mark>会负责数据都同步到所有的follower上，读的时候就直接读取leader上的数据即可。</p><p><font color='blue'>只能从leader读写然后同步给replica是不是有点捞</font>?</p><p>如果能随意读写每个follower，那么就需要保证数据一致性的问题，系统复杂度太高，很容易出问题，kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才能够提高容错性</p><p><strong>如果leader所在的节点broker宕机了怎么办？</strong></p><p>kafka会感知到leader宕机，然后<font color='blue'>从follow(replica)中选举出一个新的节点作为leader执行leader的职能</font></p><h2 id="如何保证消息不会被重复消费？如何保证消息消费的幂等性质？">如何保证消息不会被重复消费？如何保证消息消费的幂等性质？</h2><p>kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我从上次消费到的offset来继续消费。</p><p><mark>有点类似TCP的确认序号的机制</mark></p><p>如果是暴力重启 直接kill，那么可能消费者还没来得提交offset，就被kill掉了，下次重启之后还是会从已经执行过但是没有被提交的offset开始执行，重复消费</p><p>重复消费的问题可大可小，如果只是一个普通的查询请求，重复也就重复了，但是如果是插入请求，插入一条还是插入两条区别还是挺大的，导致数据出错</p><h3 id="什么是幂等性">什么是幂等性</h3><p>幂等性就是一个数据，或者一个请求，给你执行多次，得保证对应的数据不会改变，并且不能出错，这就是幂等性。</p><h3 id="如何保证幂等性">如何保证幂等性</h3><ol><li>如果请求要写库，先根据主键查一下，如果数据已经存在，那就不插入，直接更新，<mark>避免插入同样的数据</mark></li><li>生产者生产消息的时候 分配一个全局id，每次消费者消费的时候先判断这个消息id是否被消费过了，是的话就不消费，否则就进行消费， 然后把这个id记录到redis中 <font color='blue'> 这个好像还是应对不了突然死机，然后还没来得及写入到redis中的情况</font></li><li>基于数据库的唯一键UNIQUE来保证重复数据不会被插入多条，有了UNIQUE作为约束每次重复消费只会插入报错，而不会出现重复的数据</li><li>增加回滚log 可行吗</li></ol><h2 id="其他问题">其他问题</h2><h3 id="如何保证消息传输不丢失">如何保证消息传输不丢失</h3><p>也就是保证消息确实被消费了，</p><p>哪些环节可能丢失数据</p><p>producer = 》 MQ = 》consumer</p><ol><li>Producer 宕机了，消息没发送出去，解决 在prodocer 加入回滚log</li><li>Producer 发送到MQ的过程中丢失了，导致Producer以为自己发了，但是MQ却没收到，解决方法增加回复确认， Producer发送给MQ之后必须收到正确的返回值才能认为消息到了MQ，否则就重发，异步的，发了直接跑路自己运行自己的了，成功则啥也不管，失败调用回调函数重传</li><li>MQ自己搞丢了，也就是MQ宕机了，解决方法 消息本地持久化 + 分布式提高容错</li><li>MQ发到cosumer的过程中中丢失了，解决方法 MQ发送完毕必须接收到cosumer 的收到确认才能确认consumer真的收到了，一定时间没收到确认就直接重传</li><li>consumer丢失了，consumer宕机丢失了，在consumer增加回滚日志</li></ol><h4 id="kafka如何保证消息的不丢失？">kafka如何保证消息的不丢失？</h4><p><mark>参数的配置</mark></p><h5 id="kafka的配置">kafka的配置</h5><p><code>replication.factor</code> 默认是1，表示follower副本的数量</p><p><code>min.insync.replicas</code> 默认是1，表示消息至少要写入这么多副本才算成功到了消息队列中 当<code>request.required.acks</code> = all时候生效</p><h5 id="kafka生产者的配置">kafka生产者的配置</h5><p><code>requests.required.acks</code>副本确认 0 ，1， all</p><ul><li>0 表示无需等待broker确认就直接返回</li><li>1 表示leader写入成功就返回</li><li>all 表示leader和followe都写入才返回</li></ul><p>重试次数，当MQ返回写入消息失败，producer重新发送，知道成功，或者超过了重试次数</p><p>消息补偿机制，超过重试次数之后，将消息放到本地消息表，用定时任务轮询，重新推送到MQ</p><h5 id="kafka消费者的配置">kafka消费者的配置</h5><p><code>enable.auto.commit = false</code> 关闭自动ack，方式</p><p>手动提交offset，使用kafka的consumer的类，用方法consumer.commitSync()提交</p><p>…</p><h5 id="死信队列-重试队列">死信队列&amp;&amp;重试队列</h5><p>死信队列：一条消息初次消费失败，消息队列 MQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，<br>则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 MQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中，<br>这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p><p>回退队列: 与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）,<br>进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，<br>可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。</p><p>重试队列: 其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到Broker中。<br>与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</p><h3 id="如何保证消息的顺序性">如何保证消息的顺序性</h3><p>如果没有顺序性质，执行出来的结果可能是出乎意料的结果</p><h4 id="rabbitmq">RabbitMQ</h4><p>rabbitMQ出现顺序错乱的原因是消费者的集群部署，不同的消费者消费到了同一订单的不同的消息，如消费者 A 执行了增加，消费者 B 执行了修改，消费者 C 执行了删除，但是消费者 C 执行比消费者 B 快，消费者 B 又比消费者 A 快，就会导致消费 binlog 执行到数据库的时候顺序错乱，本该顺序是增加、修改、删除，变成了删除、修改、增加。</p><p>RabbitMQ 解决： 一个consumer 对应与一个queue，同一个订单号的消息只会发送到同一个queue，从而保证顺序性</p><h4 id="kafka">kafka</h4><p>对于kafka而言，一个 topic 下同一个 partition 中的消息肯定是有序的，生产者在写的时候可以指定一个 key，通过我们会用订单号作为 key，这个 key 对应的消息都会发送到同一个 partition 中，所以消费者消费到的消息也一定是有序的。</p><p><font color='blue'>那么kafka为什么还会乱序</font> 因为消费者的多线程执行的问题，有可能导致 原本的消息 因为消费者多线程执行速度的原因 导致乱序</p><p>kafka解决：保证同一个订单号的消息只被同一个线程处理即可，引入内存队列，通过消息的key 一致性hash 映射到固定的内存队列中，这个这个消息就只会被一个线程执行</p><h3 id="百万消息积压在队列中要如何处理">百万消息积压在队列中要如何处理</h3><h4 id="场景-1-积压了大量的消息">场景 1 积压了大量的消息</h4><p>紧急扩容 增加消费者，</p><ol><li>修复原有的consumer的消费问题（如果有的话）</li><li>增加10倍数量的 临时 queue</li><li>增加一个临时的consumer程序，这个程序部署 只是为了分发消息</li><li>扩容consumer 调用更多物理机器 ，负责消费临时的queue 的消息，一个 临时consumer 消费一个 queue</li></ol><h4 id="场景-2-积压了大量的消息-但是设置过期时间">场景 2 积压了大量的消息，但是设置过期时间</h4><p>新的挑战就是，积压太久就没了！</p><p>如何解决，消息已经丢失，只能去持久化存储（磁盘，日志系统）中手动找哪些消息丢失，然后重新找个时间拉回来处理，（扩容，或者找个淡季慢慢处理）</p><h4 id="场景-3-大量消息积压-导致mq磁盘满了">场景 3 大量消息积压，导致MQ磁盘满了</h4><h3 id="如何设计一个消息中间件架构">如何设计一个消息中间件架构</h3><ul><li>幂等性</li><li>可用性 - 分布式</li><li>顺序性</li><li>可伸缩性 扩展性</li><li>消息持久化</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2024/08/28/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2024/08/28/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>什么是单调栈？</p><h3 id="例题">例题</h3><p>给一个序列，计算比当前位置左边第一个比自己小的元素，或者其对称问题 左边（右边）第一个比自己大（小）的元素  就可以使用单调栈</p><h3 id="暴力">暴力</h3><p>两层循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j =i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line"><span class="keyword">if</span>(大于) 输出; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p>也可以使用一个栈保存下来当前遇到的元素 stack</p><p>使用栈 就会出现一个 问题，当idx出现一个更小的元素的时候，idx以后的位置元素比ve c[idx]大的答案就一直会是 idx，也就是，<mark>对于位置大于idx 且 val &gt;vec[idx]的元素而言，idx之前的元素已经被屏蔽掉了，永远不可能作为答案输出</mark>, 也就是 对于栈来说，目前遇到的元素idx 会按照顺序把栈顶弹出， 直到 栈顶小于 vec[idx]</p><p>也就是单调栈的<font color='blue'>精髓就在于 及时丢弃 不可能的答案 及时止损</font></p><h3 id="常见例题-接雨水">常见例题 接雨水</h3><h3 id="模版">模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> st[N], size;<span class="comment">// 模拟栈 size 是大小 ，并且从 0开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//vec </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">      st[++size] = vec[i];</span><br><span class="line">      <span class="comment">// 输出 -1 ，表示左边没有比他小的</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(size &gt;= <span class="number">1</span> &amp;&amp; st[size] &gt;= vec[i])&#123;</span><br><span class="line">      size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出 st[size];</span></span><br><span class="line">    st[++size] = vec[i]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2024/08/26/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/08/26/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是堆">什么是堆</h2><p>堆是完全二叉树，除了最后一层之外，其他地方都是 满的</p><p>分为大顶堆和小顶堆</p><p>以小顶堆为例，根比左右都小，然后递归定义</p><p>使用线性表来表示二叉树</p><p>i 的 左儿子 2*i 右儿子 2i+ 1 ，i节点编号从1 开始，比较方便</p><h2 id="如何实现一个堆-基本操作">如何实现一个堆-基本操作</h2><h3 id="down">down</h3><p>复杂度 logn</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heap[size+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = k;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span>*k &lt;= size &amp;&amp; heap[u] &gt; heap[<span class="number">2</span>*k]) u = <span class="number">2</span> * k;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span>*k+<span class="number">1</span> &lt;= size &amp;&amp; heap[u] &gt; heap[<span class="number">2</span>*k+<span class="number">1</span>]) u = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(u != k)&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[k], heap[u]);</span><br><span class="line">        <span class="built_in">down</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="up">up</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heap[size+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> father = k % <span class="number">2</span> == <span class="number">0</span> ? k / <span class="number">2</span> : (k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span>(father &gt; <span class="number">0</span> &amp;&amp; heap[father] &gt; heap[k])&#123;</span><br><span class="line">    <span class="built_in">swap</span>(a[father], a[k]);</span><br><span class="line">    <span class="built_in">up</span>(father);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入一个数">插入一个数</h3><p>Heap[++size] = x; up(size);</p><h3 id="求集合中的最小值">求集合中的最小值</h3><p>Heap[1];</p><h3 id="删除最小值">删除最小值</h3><p>Heap[1] = heap[size];size–;down(1);</p><h3 id="删除任意一个元素">删除任意一个元素</h3><p>Heap[k] = heap[size];size–;down(k);up(k);</p><h3 id="修改任意一个元素">修改任意一个元素</h3><p>Heap[k] = x; down(k);up(k);</p><h2 id="完整代码">完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> heap[N];</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = k;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span>*k &lt;= size &amp;&amp; heap[u] &gt; heap[<span class="number">2</span>*k]) u = <span class="number">2</span> * k;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span>*k+<span class="number">1</span> &lt;= size &amp;&amp; heap[u] &gt; heap[<span class="number">2</span>*k+<span class="number">1</span>]) u = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(u != k)&#123;</span><br><span class="line"><span class="built_in">swap</span>(heap[k], heap[u]);</span><br><span class="line">      <span class="built_in">down</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> m, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;heap[i]);</span><br><span class="line">  size = n;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>;i;i--) <span class="built_in">down</span>(i); <span class="comment">// 建堆复杂度 o(n)</span></span><br><span class="line">  <span class="keyword">while</span>(m--)&#123; <span class="comment">// 复杂度 mlog n</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,heap[<span class="number">1</span>]); <span class="built_in">o</span>(<span class="number">1</span>)</span><br><span class="line">    heap[<span class="number">1</span>] = heap[size];</span><br><span class="line">    size--;</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>); <span class="built_in">o</span>(logn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建堆">建堆</h3><p><mark>for(int i = n/2;i;i–) down(i); 为什么复杂度是 o(n)?</mark></p><p>相当于一颗树，从一半的地方开始down</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240828112723.png" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>∗</mo><mn>1</mn><mo>+</mo><mfrac><mi>n</mi><mn>4</mn></mfrac><mo>∗</mo><mn>2</mn><mo>+</mo><mfrac><mi>n</mi><mn>8</mn></mfrac><mo>∗</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mi>n</mi><msup><mn>2</mn><mi>i</mi></msup></mfrac><mo>∗</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\frac{n}{2} * 1 + \frac{n}{4} * 2 + \frac{n}{8}*3 +... = \sum_{i=1}^{+\infin} \frac{n}{2^i} * i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.256231em;vertical-align:-0.345em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.911231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7570857142857143em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> = S</p><p>倒数第二层down 1 次就可以 ，</p><p>倒数第三层down 2 次就可以 ， 树的高度</p><p>倒数第四层down 3 次就可以 ，。。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆排序 </tag>
            
            <tag> 快速选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存 &amp;&amp; 存储体系</title>
      <link href="/2024/08/18/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2024/08/18/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟内存-vm">虚拟内存（VM）</h1><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240808102059.png" style="zoom: 50%;" /><p>使用物理内存直接寻址有什么问题？</p><p>无法做到进程间的内存隔离，不安全，容易出错，</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240808102032.png" alt=""></p><p>1.提供了进程间的内存隔离，不容易出错，给每个程序都提供了一个统一的虚拟地址空间（这也就是所有程序反汇编都是从0000开始，但是实际运行的时候也不会发生冲突的原因）</p><p>2.这也使得程序编写变得容易，编写的时候并不需要关心地址问题</p><p>3.方便实现权限控制</p><p>4.可以运行 运行内存需求超过物理内存的程序</p><h2 id="内存分段和分页">内存分段和分页</h2><h3 id="分段">分段</h3><p>就是程序整段整段连续得映射，问题 会导致内存碎片，</p><p>A 程序占用256M，B占用100M C占用200M，D占用100M，然后BD执行完毕 释放了， 这个时候E要求连续的128M空间，虽然还有剩余的200M空间，但是已经没有连续的128M了，程序E还是无法运行，----&gt; 内存交换，内存片太大，效率低</p><h5 id="内部碎片">内部碎片</h5><p>没有，分段是用多少 分配多少，内部不会存在碎片</p><h5 id="外部碎片">外部碎片</h5><p>有</p><h3 id="分页">分页</h3><p>分页就是让每个内存小块的大小都是均匀的4K，每个程序不再是映射到一个连续的内存段 而是不连续(可能连续也可能不连续）的许多内存页，</p><p>PAGESIZE很小 所以 交换的效率比较高</p><h5 id="内部碎片">内部碎片</h5><p>有，因为内存分配的最小单位就是 PAGESIZE 4k 即使用不到 这么多也给你了</p><h5 id="外部碎片">外部碎片</h5><p>没有</p><h2 id="简单页表">简单页表</h2><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240808101832.png" alt=""></p><p>简单页表将内存地址划分为 虚拟页号 + offset，使用虚拟页号去页表中查询到物理页号，<font color='blue'> 物理页号 与 offset 组合之后去物理内存查询对应的内容</font></p><p>有什么问题 32位系统 如果页号是20位，offset是12 位，那么每个进程需要保存的页表是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>∗</mo><mn>4</mn><mi>B</mi><mo>=</mo><mn>4</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{20} * 4 B = 4MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> ,光是保存页表就是4MB，而且有的程序大小可能都没有4MB，太浪费了</p><h2 id="多级页表">多级页表</h2><p>例题<br><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240818162241.png" alt=""></p><p>一个物理页的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>字节，一个页表项大小是2字节 -&gt; 一个物理页最多能放下 $$\frac{2^{10}}{2} = 2^9$$个页表项</p><p>需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> 个页，则 页目录至少能够表示$$\frac{2^{16}}{2^9} = 2^7 = 128 $$ , 也就是页目录号 至少是 7位，至少是能表示128个页 选B</p><p>例2</p><p>页大小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{13} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,页表项是<code>2B</code>，逻辑地址空间大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>页，页目录表中包含表项的个数至少是 256</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240822151516.png" alt=""></p><p>多级页表虽然节省了存储空间，但是带来了时间上的开销，一次转换可能需要查询多次表</p><p>所以就有了 TLB</p><h3 id="tlb">TLB</h3><p>每一条地址都需要MMU查表 做虚拟地址到物理地址的转换，性能不太行，<mark>遇事不决 加 缓存</mark>，利用时间局部性和空间局部性</p><p>Translation Lookside buffer地址变换高速缓冲，在cpu内部，这块缓冲放了之前已经进行转换的查询结果，这样，以后遇到同样的转换请求，就可以直接查表，而不需要多次访问内存来查页表的得到转换结果</p><p>这部分缓冲液和cpu的高速缓冲类事，可以分成指令的TLB 和数据的TLB， 也可以根据大小和速度来分级。 L1 L2 L3</p><h3 id="安全性和内存保护">安全性和内存保护</h3><h4 id="可执行空间保护">可执行空间保护</h4><p>指令 可执行（只读可执行）</p><p>数据 不给予可执行权限（可写 可读 不可执行）</p><p>为什么这么设计，在CPU看来，数据和指令都是二进制，只要合法，cpu就可以执行，黑客可以更改数据的值，然后设计一个方法，使得CPU取得这些修改后的数据执行，从而破坏程序的执行或者泄漏数据</p><p>可执行空间保护对于进程内存空间的执行权限进行控制，只有指令可以执行，而指令又是不可修改的，也就保证了只要软件的来源是正确的，就不会被不法者修改数据来破坏执行，即使修改了数据并想加载到cpu执行，也会因为没有执行权限而被阻止</p><h4 id="地址空间布局随机化">地址空间布局随机化</h4><p>固定布局 黑客会去固定的位置查到对应的数据，可以修改数据和指令，从而破坏执行，如果是固定布局，那么很容易就被找到数据的位置</p><p>随机布局 程序的 堆栈 代码段 不再固定 是随机的，破坏者猜不出来，也就无从下手</p><h2 id="分配内存的流程">分配内存的流程</h2><h3 id="malloc">malloc</h3><p>小于一个值 就在 堆区分配 brk()</p><p>大于这个值 就在 文件映射区取一段内存出来使用 使用 mmap()</p><h4 id="为什么要区分两个-系统调用">为什么要区分两个 系统调用</h4><p><font color='blue'>效率问题 </font></p><p>brk()分配的内存 free 的时候并不会被释放掉，而是存起来了，相当于一个缓存池，当下次需要小内存的时候，就可以直接从池子里拿，而不是走系统调用brk()</p><p>mmap() 分配大内存， free的时候 会直接 释放掉，每次需要大内存都需要走系统调用</p><p><mark> fast path + slow path </mark></p><p>为什么不只使用malloc 一直系统调用 效率低</p><p>为什么不只使用brk 内存泄漏 10，20，30，40，50，60</p><p>申请10 20 30，然后 10 20 释放了，请求40 ，没有合适大小的空间，向内核申请，40释放了，申请50 。。。 不可用的内存碎片越来越多</p><h3 id="流程">流程</h3><ol><li><p>程序请求分配内存SIZE</p></li><li><p>操作系统把一段虚拟地址空间标记为使用中</p><ul><li>如果请求的SIZE超过了最大的虚拟地址空间，退出</li></ul></li><li><p>当程序真的访问到这段内存的时候，MMU进行虚拟地址转换的时候发现<font color='blue'> 这个虚拟地址并没有被映射到物理地址</font>,触发缺页中断</p></li><li><p>如果这个时候有空闲的物理内存 就直接建立映射</p><p>没有空闲物理内存 开始内存回收<font color='blue'>（页的换出算法）</font>(1.文件页 内核缓存的磁盘数据 看其dirty与否 不脏直接释放 脏可以直接写入到磁盘中完成回收 2.匿名页，程序运行时的堆栈，没有对应的文件实体，所以需要在磁盘中开辟专门的分区来存放这部分内容 —&gt; Swap 分区)</p><ul><li>后台内存回收 异步 不会阻塞进程执行</li><li>直接内存回收 同步 阻塞进程执行</li></ul></li><li><p>回收完还是不够，挑一个综合得分最高（占用页面数 + 进程的oom_score_adj 用于调整被杀的优先级 -1000～1000， 越低越不易被杀）的进程kill ，释放其内存</p></li></ol><h1 id="存储体系">存储体系</h1><table><thead><tr><th></th><th>寄存器</th><th>L1</th><th>L2</th><th>L3</th><th>内存</th></tr></thead><tbody><tr><td>用时</td><td>0.5ns 半个时钟周期</td><td>1ns 2~4个时钟周期</td><td>4ns 10～20个时钟周期</td><td>10ns 20～60个时钟周期</td><td>100us  200 ～ 300 个时钟周期</td></tr><tr><td>大小</td><td></td><td>128k～2M</td><td>256k～32M</td><td>1M～几百M</td><td></td></tr></tbody></table><h3 id="缓存一致性">缓存一致性</h3><h4 id="数据写入">数据写入</h4><h5 id="写直达">写直达</h5><p>数据 同时写入 内存和cache，如果数据已经在cache里面，就同时更新内存和cache， 否则就写入到内存，不管命中与否，都需要写入主存</p><h5 id="写回">写回</h5><p>数据 只 写入到ceche中，只有cache中的数据是dirty的时候，才写回到主存</p><blockquote><p>dirty 主存数据与cache 不一致的时候</p></blockquote><h3 id="内存映射">内存映射</h3><p>cacheline 的组织</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240822154813.png" alt=""></p><p>有效位 组标记tag 数据</p><p>组标记Tag 可能有多个内存区域可以映射到缓存中，这个时候，就需要确定倒是这个cacheline 到底是哪个了，-&gt;tag 标记</p><p>直接映射</p><p>取模 某一缓存行对应与特定的几个块，快，但是有什么缺点？可能上面一个缓存行在疯狂的没命中，频繁从内存读取数据，但是下面的却没人用</p><p>全相联</p><p>每一个主存块可以映射到任意的缓存行，灵活但是慢（映射过程可能比较复杂）</p><blockquote><p>“就像停车位可以大家随便停一样，停的时候简单，找车的时候需要一个一个停车位的找了。”</p></blockquote><p>组相联</p><p>上面两个的缝合怪，缓存行分组，组内是全相连，组间是直接映射的</p><h3 id="缓存一致性">缓存一致性</h3><p>考虑这样的情况，CPU有多个核心，1234，都从主存中读取了一个变量如iphone16的价格为8000，但是核心1 打活动 修改成了7000，但是还没有同步到主内存或者L3，如果其他核心试图从自己的L1cache读取数据，<mark>其实这个数据是失效的</mark></p><p>解决方法 要满足：</p><ol><li>写传播，在一个cpu核心内对数据的更新，要能够传播到其他节点的对应cache line中</li><li>事务的串行化，在一个cpu核心的读取和写入，在其他节点来看，顺序是一致的。</li></ol><h4 id="总线嗅探-与-mesi协议">总线嗅探 与 MESI协议</h4><h5 id="总线嗅探">总线嗅探</h5><p>把所有的读写请求都通过总线广播给所有的CPU核心，让各个核心取嗅探这些请求，再根据本地的情况响应</p><p>需要配和响应的协议使用</p><h5 id="mesi协议">MESI协议</h5><p>M 代表已经修改 modified 脏标记</p><p>E 代表独占 exclusive 表示这个数据只被加载到了当前的cpu核心，其他cpu核心没有用到这个数据，这个状态下，当前cpu核心可以任意读取这个数据，而不用通知其他人</p><p>S 代表共享 shared 表示这个数据 被加载到了多个CPU核心，需要通知其他人，当需要修改这个数据的时候，需要向所有的CPU核心广播一个请求，要求其他核心把这个数据置成无效状态，然后再更新这个数据，这个广播操作叫做RFO(Request For Ownership)，也就是获取当前对应 cache line 数据的所有权</p><p>I 代表已失效 invaliated 代表已经实效 的数据，cpu不可信任这个数据</p><p>MESI是一种写失效协议，在写失效协议中，只有一个CPU核心负责写入数据，其他核心只是同步读取到这个写入。在CPU核心写入cache之后，广播一个失效请求，告诉其他核心数据已经失效，然后写入主存，其他核心从主存再读取</p><p>相当于 只告诉你 失效了，但不告诉你是多少 <mark> 管杀不管埋</mark></p><p>还有一种写广播协议 就是 一个写入请求广播到所有的CPU核心，然后同时更新各个核心的cache <mark> 送佛送到西</mark></p><p><font color='blue'>CPU在总线嗅探机制和MESI协议规定的状态机流转之下保证缓存的一致性</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
            <tag> TLB </tag>
            
            <tag> 多级页表 </tag>
            
            <tag> 存储体系 </tag>
            
            <tag> 全相连 </tag>
            
            <tag> 组相连 </tag>
            
            <tag> 直接映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++对象模型</title>
      <link href="/2024/08/18/c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/08/18/c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><p><font color='blue'>c++对象的变量和函数是分开存放的，所以sizeof(class) 获取到的大小只是对象的变量所占的大小</font></p><h3 id="对象大小">对象大小</h3><h4 id="例题1-内存对齐">例题1-内存对齐</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sub</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(sub) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案是8</strong></p><h4 id="例题2-空类大小">例题2-空类大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sub</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(sub) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案是1</strong></p><p>为什么？</p><ol><li><strong>唯一性和可区分性</strong></li></ol><p>如果空类的大小为0，那么多个空类实例在内存中将无法区分，因为它们的地址会相同。C++标准规定，即使是空类的实例也必须有一个唯一的地址。因此，编译器为每个空类实例分配至少1字节的大小，以确保它们可以在内存中占据不同的地址。</p><ol start="2"><li><strong>指针运算</strong></li></ol><p>C++支持对类对象的指针进行指针运算。如果空类的大小为0，那么指针运算（如指针加减）将无法正常进行，因为无法确定指针的移动步长。将空类的大小设为1字节解决了这个问题，使得指针运算符合常规逻辑。</p><ol start="3"><li><strong>语言标准</strong></li></ol><p>C++标准要求任何类型（包括类）都必须占据至少1字节的内存空间。这一规定保证了对象在内存中的地址是唯一的，并确保对象模型的一致性。</p><h3 id="非虚函数如何调用？">非虚函数如何调用？</h3><p>非虚函数 在编译的当你调用对象的非虚成员函数时，编译器在编译期间就已经确定了函数的地址。调用时，编译器直接生成一个对该函数地址的调用指令。这种方式称为<strong>静态绑定</strong>（Static Binding）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonVirtualFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::nonVirtualFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj;</span><br><span class="line">    obj.<span class="built_in">nonVirtualFunction</span>(); <span class="comment">// 直接调用 Base::nonVirtualFunction</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，编译器在编译时已经知道 <code>Base::nonVirtualFunction</code> 的地址，所以它直接在机器码中生成调用指令。</p><h2 id="多态与虚表的关系">多态与虚表的关系</h2><p>C++虚函数表主要为了实现多态机制，每个对象都有一个<font color='blue'> 虚表指针</font>, 运行时多态，也就是父类指针 在程序运行的时候才知道所指的真正类型是什么，就是通过虚函数表实现的</p><h3 id="虚函数表">虚函数表</h3><p>当一个类本身定义了一个虚函数或者从父类继承了虚函数的时候，编译器会为该类添加一个<strong>虚函数表指针</strong><code>vptr</code>， 指向一个虚函数表</p><p>vptr一般放在类对象的内存布局第一个位置，也即<strong>对象地址就是虚函数表指针地址</strong>，为什么是第一个位置? <mark>方便取用，最高效率直接打到虚函数表里面</mark></p><p>虚函数表 存放的是系列虚函数的地址，虚函数地址的出现顺序和类中虚函数声明的顺序一致，如果涉及到父类的虚函数，先放父类虚函数（多个父类的虚函数顺序由继承顺序决定） 再放子类虚函数，如果子类重写了，那就是覆盖了父类的虚函数</p><h3 id="多继承">多继承</h3><h3 id="菱形继承">菱形继承</h3><h4 id="虚基类表">虚基类表</h4>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 对象 </tag>
            
            <tag> 虚函数表 </tag>
            
            <tag> 虚基类表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2024/08/16/HTTP/"/>
      <url>/2024/08/16/HTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="http">HTTP</h2><h3 id="http基本概念">HTTP基本概念</h3><h4 id="http是什么？">HTTP是什么？</h4><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><h5 id="协议">协议</h5><p>HTTP是一个用在计算机世界里的协议， 它确定了一种计算机之间<font color = "blue">交流与通信的规范</font>，以及相关的<font color="red">各种控制和错误处理方式</font></p><h5 id="传输">传输</h5><p>HTTP是一个双向协议，也就是A - B 之间的传输，数据虽然是在AB之间传输，但是运行中间有中转和接力，只需要中间人也满足HTTP协议，不打扰正常的数据传输，可以添加任意额外的东西</p><p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p><h5 id="超文本">超文本</h5><p>HTTP 传输的内容是「超文本」。</p><p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p><p>再来理解「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p><p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，甚至可能有js脚本，<font color='blue'>再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</font></p><p><mark background-color = "yellow"><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong> </mark></p><h4 id="http常见的状态码">HTTP常见的状态码</h4><p><font color="blue">1xx</font> 提示<font color='blue'>信息</font>，表示目前是协议处理的中间状态，还需要后续处理，实际用到的比较少 <font color='blue'><strong>1</strong></font>xx - <font color='blue'><strong>I</strong></font>nformation</p><p><font color="blue">2xx</font> 表示服务器成功处理了客户端的请求</p><ul><li>「<strong>200 OK</strong>」 最常见的成功状态码，表示一切正常，如果是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP <font color='blue'>分块下载或断点续传</font>，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><font color="blue">3xx</font>  状态码表示<font color='red'>客户端请求的资源发生了变动</font>，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong></p><ul><li>「<strong>301 Moved Permanently</strong>」表示<mark>永久重定向</mark>，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，<font color='blue'>浏览器会自动重定向新的 URL。</font> 301和302从浏览器角度来看，是没有区别的，都是需要重新访问新的url连接，</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<font color='blue'>缓存重定向</font>，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><font color="blue">4xx </font> 表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><font color="blue">5xx </font> 表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h4 id="http常见字段">HTTP常见字段</h4><p><code>Host</code> 发送请求时，指定服务器的域名，用于区分发往同一台服务器的不同网站</p><p><code>Content-Length</code> 表示服务器返回数据的长度 为了解决粘包问题</p><p><code>Connection</code> 指示长连接 Keep-alive</p><p><code>Content-Type</code> 服务器指示客户端本次的数据是什么格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; Charset=utf-8</span><br></pre></td></tr></table></figure><p><code>Accept</code> 客户端指示服务器自己可以接受什么数据格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */* 表示任意都可以接收</span><br></pre></td></tr></table></figure><p><code>Content-Encoding</code> 说明数据的压缩方法，gzip，zip, rar …</p><p><code>Accept-Endoing</code> 客户端可接受的压缩方法</p><h3 id="get-post">GET &amp;&amp; POST</h3><p>GET 从服务器获取指定的资源</p><p>POST根据请求负荷（body） 对指定的资源作出处理</p><h4 id="安全性和幂等性">安全性和幂等性</h4><p><code>安全性</code> 请求方法不会破坏服务器上的资源</p><p><code>幂等性</code> 执行多次操作结果都是一样的</p><p>GET 就是 安全 且幂等的</p><p>POST不安全 也不幂等</p><h3 id="http缓存技术">HTTP缓存技术</h3><p>如果对于一些不经常变动的数据，在客户端第二次访问的时候，直接返回浏览器本地缓存中的内容，就可以大大提供性能</p><h4 id="强制缓存-200-from-disk-cache">强制缓存   200(from disk cache)</h4><p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，<font color='blue'>是否使用缓存的主动权在浏览器这边</font></p><p>使用以下两个关键字来控制</p><p><code>Cache-Control</code> 是相对时间， <font color='blue'>推荐使用这个</font></p><p><code>Expires </code>是绝对时间</p><p>如果同时有这两个关键字，<code>Cache-Control</code>的优先级更高</p><p>返回的状态码是 <mark>200(from disk cache) </mark></p><p>强制缓存的过程：</p><ol><li>浏览器第一次请求服务器资源的时候，服务器在response头部设置<code>Cache-Control</code>为过期时间的大小；</li><li>当浏览器需要再次请求同样的资源时，会先比较当前请求时间与<code>Cache-Control</code>的大小计算出资源是否过期<ul><li>没过期 使用缓存</li><li>过期，发给服务器请求，然后服务器重新设置<code>Cache-Control</code>的值</li></ul></li></ol><h4 id="协商缓存-304">协商缓存 304</h4><p>某些请求的响应码是304， 这就是服务器在告诉浏览器可以使用本地缓存的资源，<font color='blue'>这种服务器通知客户端可以使用本地缓存的方式-&gt; 协商缓存</font></p><p><mark>服务器告知浏览器可以使用本地缓存，主动权在服务器这边</mark></p><h4 id="两种实现方式">两种实现方式</h4><h5 id="if-modified-since-last-modified"><code>If-Modified-Since</code> + <code>Last-Modified</code></h5><p><strong>基于时间</strong></p><p><code>Last-Modified</code> 位于响应头部，表示这个响应资源的最后修改时间。</p><p><code>If-Modified-Since</code> 位于请求头部，当资源过期了，发现资源的响应头有<code>Last-Modified</code> = B字段，于是这次请求的时候发送 请求资源的url + <code>If-Modified-Since:B</code>, 服务器接收到请求之后，比较资源的最后修改时间A🆚B的大小关系</p><ul><li>如果 A &gt; B 也就是服务器的资源更新，需要重新发送资源响应</li><li>else A &lt; B 也就是服务器的资源没有被修改，返回304，这个时候就不用发具体的body了，因为通知浏览器走缓存了，提高了效率</li></ul><h5 id="if-none-match-etag"><code>If-None-Match</code> + <code>ETag</code></h5><p><code>ETag</code> 响应头部 唯一标识响应资源</p><p><code>If-None-Match</code> 请求头部，当需要再次请求资源的时候，浏览器发现资源响应有ETag=xxx标识，于是传输请求头的时候带上<code>If-None-Match：xxx</code> ，服务器接收到之后，对etg进行比较</p><ul><li>相等，说明没有发生变化，返回304 走缓存</li><li>不相等，说明发生变换了，设置响应头的ETag值为最新的，请求的资源放到body中，发给浏览器，状态码200</li></ul><h3 id="http1-0">HTTP1.0</h3><p>短连接 每一次对话都要重新 建立 tcp连接 慢的一</p><h3 id="http1-1">HTTP1.1</h3><p>实现了长连接</p><p>优点：</p><ul><li><p>简单：<code>header+body</code>, 头部信息也是<code>key-value</code>的简单格式</p></li><li><p>灵活和易于扩展 字段 请求方法 都没有被固定死，可以灵活定义扩充，工作在应用册，下层可以随意变化</p></li><li><p>应用广泛和跨平台</p></li></ul><p>缺点：</p><ul><li>无状态</li><li>明文传输</li><li>不安全</li></ul><h4 id="特性">特性</h4><h5 id="长连接">长连接</h5><h5 id="管道网络传输">管道网络传输</h5><p>不是默认开启， 并且浏览器基本没有支持</p><h5 id="队头堵塞">队头堵塞</h5><p>因为有了长连接的支持，所以如果有多个请求，可以一次性发送ABCDEFG，<font color='blue'> 有了管道传输之后，请求是没有堵塞的</font>，但是服务器必须按照请求的发送时间按顺序回复响应，如果A的处理时间比较长，那么在A之后的所有请求的响应都会被阻塞住—》<mark> 队头堵塞</mark></p><h5 id="http1-1-断点续传">Http1.1 断点续传</h5><p>1、客户端发起请求，并在请求包含Range字段：<strong>Range：bytes=start-end</strong></p><p>2、服务器收到请求之后，返回指定范围的数据，响应状态码为206，表示部分内容成功返回 响应字段有Content-Range: bytes 0-499/22400 返回数据的范围和接数据总的大小；</p><p>3、客户端收到部分响应之后，保存到本地的临时文件中，并且继续请求</p><p>4、下载完成之后，客户端将文件合并到最终的文件，从而实现整个文件的下载</p><p>此外 因为服务器上的数据可能会被更改，所以需要断点续传需要判断是否发生过更改 if_modified ETag  …发生更改则可能需要重新下载已经下载的部分</p><h4 id="性能瓶颈">性能瓶颈</h4><ul><li><p>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</p></li><li><p>发送冗长的首部。每次发送相同的首部造成的浪费较多；</p></li><li><p>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</p></li><li><p>没有<font color='blue'>请求优先级控制</font>；</p></li><li><p>请求只能从客户端开始，<font color='blue'>服务器只能被动响应</font>。</p></li><li><p>无状态，用户使用不流畅，登录-加车-结算都需要 询问用户信息，麻烦</p></li></ul><h3 id="http2-0">HTTP2.0</h3><p>基于HTTPS实现，HTTP是明文传输 所以在安全上有以下三个问题：</p><blockquote><p>窃听风险：明文可以直接被其他人看到</p><p>篡改风险：明文容易被直接修改内容</p><p>冒充风险：容易被冒充服务端</p></blockquote><p>HTTP<font color='blue'><strong>S</strong></font>，在HTTP于TCP层之间加入了<code>SSL/TLS</code>协议，可以解决上述的风险：</p><ul><li>信息加密:  信息加密 无法破解 <font color='blue'>混合加密 = &gt; 机密性 </font></li><li>校验机制：保证内容是没被修改过的  <font color='blue'>摘要算法 =&gt; 完整性</font></li><li>数字身份证书：保证和你通信的对端是server端  <font color='blue'>数字证书=&gt; “唯一性”</font></li></ul><h4 id="https">HTTPS</h4><p>默认端口 <em><strong>443</strong></em></p><p>消息机密性  通过混合加密的方式</p><p>消息完整性  摘要算法保证消息的完整性（hash值）</p><p>身份认证 数字证书CA认证</p><h5 id="1-混合加密">1、混合加密</h5><p>非对称加密：加密解密效率低，公钥可以随便发， 私钥保密，解决了密钥交换问题</p><p>常用的有RSA，DSA，ECC，DH</p><p>对称加密：加密解密效率高，只使用一个密钥，密钥必须保密，所以无法做到安全的密钥交换</p><p>常用的有AES，DES，IDEA…</p><blockquote><p>私钥加密 公钥解密 -&gt; 保证消息不会被冒充，因私钥是不可泄漏的，能解密出来合法的消息说明发送方也是合法的</p><p>公钥加密 私钥解秘 -&gt; 内容只有一个人（持有私钥）可以破译 保证消息机密</p></blockquote><p>结合二者的优点 =》 <strong>混合加密</strong></p><ul><li><p>在通信建立阶段使用非对称加密的方法进行  <code>会话密钥</code>  交换，</p></li><li><p>通信过程中使用对称加密的  <code>会话密钥</code>  加密明文数据进行通信</p></li></ul><h5 id="2-摘要算法-数字签名">2、摘要算法 + 数字签名</h5><p>为了保证数据的完整性，需要针对内容计算一个<font color='blue'>「指纹」,然后和内容一起传输</font></p><p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，<font color='blue'>因为这里缺少对客户端收到的消息是否来源于服务端的证明</font></strong></p><p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**<font color='blue'>对内容的哈希值加密</font>**。</p><h5 id="3-数字证书">3、数字证书</h5><p>已经解决了完整性和机密性，但是还不够，但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p><p>因此需要一个权威机构来认证服务器分发公钥的合法性，在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<font color='blue'> 数字证书 = 服务器公钥 + CA的数字签名 </font>+ 一些信息</p><blockquote><p>CA 会使用自己的<font color='blue'>私钥</font>将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p></blockquote><p>CA流程：</p><ol><li>服务器将自己的<font color='blue'>公钥 + 一些信息</font>发给CA机构，CA机构使用CA的私钥 对上述内容的哈希值加密（数字签名），将 <font color='blue'>公钥+一些信息</font>+<font color='red'>数字签名</font> 打包成一个数字证书发回给服务器</li><li>当有客户端需要连接的时候，<font color='blue'>服务器发给自己的数字证书给客户端</font></li><li>客户端通过浏览器或者操作系统内置的<font color='blue'>CA公钥对数字证书的签名进行解密</font>，然后验证hash值，如果是对的，则说明对端就是官方的server端，否则可能是中间人，中止连接</li></ol><h5 id="https-如何建立连接？">HTTPS 如何建立连接？</h5><p>SSL/TLS 协议基本流程：”Secure Sockets Layer&quot; / “Transport Layer Security”</p><ul><li>客户端向服务器索要数字证书，验证公钥</li><li>双方协商产生  <code>会话密钥</code></li><li>使用  <code>会话密钥</code>  通信</li></ul><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法 (opens new window)</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法 (opens new window)</a>。</p><p>具体的<font color='blue'>四次握手</font> 略</p><p>证书的验证过程中<strong>还存在一个证书信任链的问题</strong></p><p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p><p><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</strong></p><h5 id="https-的应用数据是如何保证完整性的？">HTTPS 的应用数据是如何保证完整性的？</h5><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，具体过程如下：</p><ul><li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li><li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><h5 id="https一定安全可靠吗？">HTTPS一定安全可靠吗？</h5><p>理论上是可靠的，只要用户不擅自信任未知来源的网站</p><p><mark>HTTPS只有客户端会对服务器端校验身份,而没有服务器对客户端校验身份</mark></p><p>客户端 — 中间人 ---- 服务器</p><p>解决中间人转发的问题 HTTPS双向认证，加上服务器对客户端的认证，服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p><h4 id="特性">特性</h4><h5 id="1-头部压缩">1、头部压缩</h5><p>压缩头部，如果同时发出多个请求，头是一样的，协议会消除重复的部分 HPAC算法</p><h5 id="2-二进制格式">2、二进制格式</h5><p>不像HTTP1.1 是纯文本格式，采用的二进制，统称为帧，头和body 都是二进制，对计算机友好，直接解析二进制报文，增加了数据传输的效率</p><h5 id="3-并发传输">3、并发传输</h5><p>引入了stream概念，多个stream复用在一个TCP连接，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。</p><p><font color='blue'>解决了队头堵塞的问题</font></p><h5 id="4-服务器推送">4、服务器推送</h5><p>client和server都可以建立stream <font color='blue'>客户端建立的stream必须是奇数， server必须是偶数</font></p><p>奇数steam 传输客户端向服务器请求的资源，偶数stream传输服务器主动推动的资源</p><p><font color=blue>但是如果需要频繁推送资源 就需要使用Websocket了</font></p><h4 id="缺陷">缺陷</h4><p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p>也就是内核接收到的数据包如果乱序或者丢包了，那么这个数据报就会被卡在内核，直到数据全部到齐，TCP重组成功再返回给应用层，<font color='blue'>也就是HTTP2.0是由于采用的TCP协议堵塞在内核里面的！</font>虽然有stream并发传输，但是本质上还是复用的一个TCP连接，也就是只要一个TCP没到，还是会阻塞住所有的stream</p><h3 id="http3-0">HTTP3.0</h3><p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240817142613.png" alt=""></p><h4 id="特性">特性</h4><h5 id="1-无队头堵塞">1、无队头堵塞</h5><p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。 再加上 协议更换成了UDP，内核层面的堵塞也没有了，所以没有队头堵塞</p><h5 id="2-更快的连接建立">2、更快的连接建立</h5><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，<font color='blue'>需要分批次来握手，先 TCP 握手，再 TLS 握手。</font></p><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，</p><h5 id="3-连接迁移">3、连接迁移</h5><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><h4 id="缺陷">缺陷</h4><p>有待普及</p><h3 id="http版本总结">HTTP版本总结</h3><table><thead><tr><th></th><th>http 1.0</th><th>http 1.1</th><th>http 2.0</th><th>http 3.0</th></tr></thead><tbody><tr><td>改进</td><td></td><td>1、更改为长连接  2、增加了管道机制，允许请求端一次性发送多个请求3、支持断点续传4、支持先发送header而不发送body，先用header判断是否成功，再发送数据，节约带宽</td><td>1、基于HTTP S，安全性有保障 2、头部压缩 3、二进制格式 3、并发传输 4、服务器主动推送资源</td><td>TCP改成了UDP QUIC协议来保证可靠传输 更快的连接建立 连接迁移</td></tr><tr><td>缺陷</td><td>短连接，每次重复连接TCP带来的性能开销</td><td>1、首部不能压缩，只能压缩body，导致冗余，2、头部冗长，每次都要发送冗长的头部效率较低 3、server端只能按照请求顺序响应，会有队头堵塞问题 4、没有请求优先级控制 5、请求只能从客户端开始，服务器只能被动响应</td><td>通过stream的并发能力，不同的请求可以使用不同的stream ID来发送解决了队头堵塞的问题，但是只解决了HTTP的队头堵塞，TCP的“队头堵塞“还没有解决：发生丢包x则x+1之后的数据会被堵塞在内核直到包x重传</td><td>尚未普及</td></tr></tbody></table><p>SSL/TLS  Secure Sockets Layer / Transport Layer security</p><h3 id="http缓存技术">HTTP缓存技术</h3><h5 id="为什么需要缓存？">为什么需要缓存？</h5><p>如果每次向服务器请求的响应都是一样的，那么就没必要向服务器请求响应，只需要由浏览器缓存下来，然后判断缓存是否可用，直接处理即可</p><h5 id="强制缓存">强制缓存</h5><p>只要浏览器判断缓存没有过期，直接使用本地缓存，<font color='blue'>决定是否使用缓存的主动性在浏览器这边</font></p><p>HTTP响应头部使用 <strong>Cache-Control</strong> 相对时间   ， <strong>Expires</strong> 绝对时间 两个字段来实现</p><p>如果同时有两个字段 ，<strong>前者优先级高</strong></p><p>Cache-control <font color='red'>选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存</font>。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h5 id="协商缓存">协商缓存</h5><h6 id="实现方式1-请求头中的if-modified-sincce-响应头的last-modified">实现方式1 <strong>请求头中的If-Modified-Sincce + 响应头的Last-Modified</strong></h6><p>响应头的Last-Modified：标识这个响应资源的最后修改时间</p><p>请求头中的If-Modified-Sincce ：</p><ul><li>当资源过期了，发现响应头有Last-Modified，则再次请求的时候带上Last-Modified，(If-Modified-Since = Last-Modified)</li><li>服务器收到请求后发现有If-Modified-Since字段与资源的最后修改时间(Last-Modified)对比</li><li>如果Last-Modified大（更新），返回最新资源 HTTP200 OK</li><li>如果Last-Modified小（更旧），资源无修改，返回HTTP 304 走缓存</li></ul><h6 id="实现方式2-请求头中的if-none-match-响应头的etag">实现方式2 <strong>请求头中的If-None+Match + 响应头的Etag</strong></h6><p><font color='blue'>这种方法的优先级更高</font></p><blockquote><p>因为ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p><p>1、在没有修改文件内容的时候，修改时间可能也会变，比如touch命令，导致客户端还是需要重新请求资源响应</p><p>2、有些文件实在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次</p><p>3、有些服务器不能精确获取文件最后的修改时间</p></blockquote><p>响应头部中的Etag：响应资源的唯一标识</p><p>请求头部中的If-None-Match：</p><ul><li>当资源过期的时候，发现响应头里面有Etag，则再次发起请求的时候，就把If-None-Match的值设置为Etag的值</li><li>服务器收到请求之后比对，如果资源更改返回HTTP 200 ok</li><li>没有更改返回 HTTP 304</li></ul><h5 id="总结">总结</h5><p>​协商缓存这两个字段都需要配合强制缓存中的<code>Cache-Control</code>来使用，只有未能命中强制缓存，才能发起带有协商缓存字段的请求。</p><p>也即是：</p><p><font color='green'>浏览器请求-&gt;是否有缓存-&gt; Cache-Control是否过期-&gt;没有cache-control就去看Expires-&gt; 是否有Etag -&gt;是否有Last-Modified </font></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> RPC </tag>
            
            <tag> WebSocket </tag>
            
            <tag> 幂等性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面置换算法</title>
      <link href="/2024/08/13/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2024/08/13/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="页面置换算法">页面置换算法</h1><p>当发生缺页中断， 又没有空闲的物理页可以使用的时候，就需要对页面进行置换，也即从当前的所有物理页中选择一部分换出到磁盘中，然后将需要的页换入内存中</p><h2 id="最佳页面置换算法opt">最佳页面置换算法OPT</h2><p>选择 <mark>未来最长一段时间不会被使用的</mark> 页面 换出，是理想的</p><p>程序的执行 是动态的，因此无法选择出未来最长一段时间不会被使用的页面， 所以这种方法是理想的无法实现的，通常用作baseline 作比较使用</p><h2 id="先进先出置换算法fifo">先进先出置换算法FIFO</h2><p>选择在内存中待的时间最长的页面置换</p><h2 id="最近最久未使用的置换算法lru">最近最久未使用的置换算法LRU</h2><p>选择内存所有页面中 最久时间没有被使用的页面换出去，LRU leetcode有题目</p><p>使用双向链表来实现，</p><p>性能不错，但是开销比较大</p><h2 id="时钟页面置换算法lock">时钟页面置换算法LOCK</h2><p>与LRU相似，又是FIFO的改进，</p><p>简单的 CLOCK 算法是给每一帧关联一个附加位，称为使用位。</p><p>当某一页首次装入主存时，该帧的使用位设置为1;</p><p>当该页随后再被访问到时，它的使用位也被置为1。</p><p>对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区 形成一个环形链表，并且有一个指针与之相关联。<font color = 'blue'>顺时针或者逆时针旋转 </font></p><p>当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。</p><p>当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。</p><p>每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；</p><p>如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；</p><p>如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。 也就是最多会扫描一周，然后</p><h2 id="最不常用置换算法lfu">最不常用置换算法LFU</h2><p>根据使用频率来置换，</p><p>也有问题，可能一个一开始使用非常频繁的页面现在已经不用了，而刚刚加载进来的一个页面才刚开始使用（使用次数比较少）就会被替换出去，会发生抖动，页面被频繁换入换出</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程调度算法</title>
      <link href="/2024/08/12/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2024/08/12/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="进程调度算法">进程调度算法</h1><p>当cpu空闲的时候，操作系统选择内存中某个就绪状态的进程，将其分配给cpu执行</p><h2 id="发生的调度时机">发生的调度时机</h2><p>进程从运行状态 转换到 等待状态 (当前进程阻塞，cpu调度)</p><p>进程从运行状态转换成就绪状态 （当前进程的执行时间片用完了，转到就绪状态，调度）</p><p>进程从等待状态转换到就绪状态 （阻塞返回了，就绪，且这个进程的优先级非常高，调度）</p><p>进程从运行状态转换到终止状态 （进程结束了，cpu调度）</p><p>1、 4 两种情况下的调度称为非抢占式调度</p><p>2、3 称为抢占式调度</p><blockquote><p>什么是抢占式调度，什么是非抢占式调度？</p><p>抢占式就是中止当前正在执行的进程，转而去执行其他进程，非抢占式就是等当前进程执行完毕或者当前进程被阻塞了，再去执行其他线程</p></blockquote><h2 id="调度算法">调度算法</h2><h3 id="先来先服务fcfs">先来先服务FCFS</h3><p>先来后到，每次从就绪队列中选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才继续从队列中取出进程执行</p><p>对长作业有利，不利于短作业，长作业先执行，排在其后面的短作业就会等待很久</p><h3 id="最短作业优先sjf">最短作业优先SJF</h3><p>优先选择最短的作业，<mark>提升吞吐量</mark></p><p>另外一个极端，短作业太多了可能会导致长作业一直得不到执行，对长作业不友好</p><h3 id="高响应比优先算法hrrn">高响应比优先算法HRRN</h3><p>High Response Ratio Next</p><p>每次进程调度的时候，先计算响应比优先级，最高的获得执行</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>优先权</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">优先权 = \cfrac{等待时间 + 要求服务时间}{要求服务时间} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">优</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">权</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">求</span><span class="mord cjk_fallback">服</span><span class="mord cjk_fallback">务</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p><ul><li>等待时间相同的情况下，要求服务时间越短的任务越先被执行（短任务）</li><li>要求服务时间相同的时候，等待时间越长，优先级越高，当长作业等待的时间足够长的时候，长作业的优先级就会很高，就可以得到执行</li></ul><h3 id="时间片轮转调度rr-round-robin">时间片轮转调度RR（Round Robin）</h3><p>每个进程分配一个时间段，称为时间片（quantum）进程在时间片内执行</p><ul><li>如果时间片进程没有被执行完，则直接在队列中切换下一个进程，此进程插到队尾</li><li>如果时间片内进程执行完毕，立马切换</li></ul><p><mark>最公平的算法</mark>，时间片的选择：太短导致过于频繁的切换，降低了CPU效率，太长导致对短作业的响应时间变长 一般设置为20～50ms</p><h3 id="最高优先级调度算法hpf">最高优先级调度算法HPF</h3><p>调度有优先级，RR是公平的，每个进程都是一视同仁，按照队列顺序先来后到，每个人只能执行一个时间片，所以是公平的</p><p>使用优先级就是 从就绪队列中选择 优先级最高的进程执行 <font color = 'blue'>（特权选手）</font>，</p><p>优先级又分为：</p><p>1、静态优先级 创建进程的时候，优先级就确定了，整个运行时间都不会改变</p><p>2、动态优先级 根据进程的变化 <font color='blue'>动态调整其优先级</font>, 比如进程等待时间太长了 提高其优先级，进程的执行时间变长 降低其优先级</p><p>有两种处理高优先级的方式，非抢占式和抢占式：</p><ul><li>非抢占式： 当就绪队列中出现优先级高的进程，运行完当前正在执行的进程，在选择优先级高的进程</li><li>抢占式：当就绪队列中出现高优先级的进程，<font color = 'blue'> 先挂起当前进程</font> 调度优先级高的进程先执行</li></ul><p>缺点 <font color='red'> 优先级低的进程可能永远不会被执行 😖</font></p><h3 id="多级反馈队列调度算法mfq">多级反馈队列调度算法MFQ</h3><p>时间片轮转算法 和 最高优先级 算法的 <mark> 缝合</mark></p><p>多级 表示 有多个 就绪队列，每个队列的优先级从高到低，同时优先级越高时间片越短</p><p>反馈 表示如果有新进程加入优先级高的队列，立刻停止当前正在执行的进程，去执行优先级高的队列</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240813151151.png" alt=""></p><p>新工作 先进入 最高优先级的就绪队列，然后获得按照<font color='blue'>先来先服务原则</font>获得执行，在最高优先级的就绪队列如果没有获得执行，就会将这个进程<font color='blue'>塞到下一级就绪队列中继续执行，但是只有当更高级别的就绪队列是空的时候 才会执行低优先级的就绪队列</font></p><p>如此一来短作业可以较快执行，吞吐量上升，但是长作业却容易被大量的短作业淹没在低优先级的队列中，导致<font color='red'>饥饿</font></p><p>解决办法 ：<mark>周期性提升（boost）所有任务的优先级到最高优先级队列</mark>，也就是每隔一段时间S，长作业至少都能执行一个时间片</p>]]></content>
      
      
      
        <tags>
            
            <tag> 进程调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eventfd_原理与用法</title>
      <link href="/2024/08/10/eventfd-%E5%8E%9F%E7%90%86%E4%B8%8E%E7%94%A8%E6%B3%95/"/>
      <url>/2024/08/10/eventfd-%E5%8E%9F%E7%90%86%E4%B8%8E%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在muduo库中使用到了 eventfd 所以这里复习一下其原理和用法</p><h3 id="原理">原理</h3><p>eventfd，在linux中一切皆文件，每一个文件都对应于一个文件描述符fd，</p><p>eventfd 是专门用于时间通知的文件描述符，可以用于进程间的通信，也可以用于用户态和内核态的通信， eventfd 在内核中包含了一个计数器，该计数器是64为的无符号整数，<mark>计数不为0 表示该fd上有事件发生，否则无事发生</mark>，read 之后计数清0， write递增计数器</p><p><mark>eventfd 只能用来传递有事件发生而不能传递具体的数据</mark>，当需要write的时候，可以随便往eventfd写入一个uint64_t类型的数据，read的时候也是读一个uint64_t的数据，这样就可以实现消息的通知，而不用传递具体的数据，</p><p>在muduo库中 结合epoll 来使用，subloop监视自己的eventfd，查询mainloop是否有新的连接事件发生，是的话，mainloop会往eventd写入数据，subloop也会从epoll_wait 状态中唤醒从而 dopendingcallback处理新连接事件</p><h3 id="用法">用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span>       efd;</span><br><span class="line">   <span class="type">uint64_t</span>  u;</span><br><span class="line">   <span class="type">ssize_t</span>   s;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s &lt;num&gt;...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   efd = <span class="built_in">eventfd</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">       <span class="built_in">err</span>(EXIT_FAILURE, <span class="string">&quot;eventfd&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; argc; j++) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;Child writing %s to efd\n&quot;</span>, argv[j]);</span><br><span class="line">           u = <span class="built_in">strtoull</span>(argv[j], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                   <span class="comment">/* strtoull() allows various bases */</span></span><br><span class="line">           s = <span class="built_in">write</span>(efd, &amp;u, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>));</span><br><span class="line">           <span class="keyword">if</span> (s != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line">               <span class="built_in">err</span>(EXIT_FAILURE, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Child completed write loop\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Parent about to read\n&quot;</span>);</span><br><span class="line">       s = <span class="built_in">read</span>(efd, &amp;u, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>));</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>))</span><br><span class="line">           <span class="built_in">err</span>(EXIT_FAILURE, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;Parent read %&quot;</span>PRIu64<span class="string">&quot; (%#&quot;</span>PRIx64<span class="string">&quot;) from efd\n&quot;</span>, u, u);</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">       <span class="built_in">err</span>(EXIT_FAILURE, <span class="string">&quot;fork&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展">扩展</h2><h3 id="文件描述符fd">文件描述符fd</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库-mysql</title>
      <link href="/2024/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/"/>
      <url>/2024/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="基础">基础</h1><p>server层 + 存储引擎层</p><p>server层 负责 连接管理，缓存命中， 词法句法分析，预处理 执行…</p><p>解析器 优化器</p><p>存储引擎层 负责具体的查询IO</p><h3 id="查询流程">查询流程</h3><p>客户端连接到连接池， 查询缓存（命中率比较低，一般不用），解析器 词法分析 构建语法树，预处理器判断表和字段是否存在，优化器计算执行成本，负责确定执行计划，执行器负责和引擎层交互，执行具体的 内存写 和 磁盘IO</p><h3 id="acid">ACID</h3><p>A 原子性 - 事务 + undolog</p><p>I 隔离性 - 隔离级别 + MVCC</p><p>D 持久性 redolog + 刷盘持久化</p><p>C 一致性 A + I + D =》保证了 C consistency</p><h1 id="索引">索引</h1><p>为什么要索引？</p><ul><li>大大减少了服务器需要扫描的数据量，从而大大加快数据的检索速度</li><li>避免排序和创建临时表</li><li>索引可以将随机IO变成顺序IO</li></ul><p>但是索引的维护和创建需要时间，以及索引需要占用额外的存储空间</p><h3 id="b树">B树</h3><p>一种多叉 自平衡树，每个节点分多叉，每个节点都存放真实的数据</p><p>缺点</p><ul><li>查询效率不稳定，不利于优化器计算执行成本</li><li>树的高度有待降低</li><li>范围查询力不从心，查询的范围未必在这个节点上</li></ul><p>为了解决这些，引入了B+树</p><h3 id="b-树">B+树</h3><ol><li>真实数据下放到叶子节点，强迫所有查询都要走到叶子，统一查询成本</li><li>数据下放到叶子节点，非叶子节点就有多余空间可以存放更多的索引和节点位置</li><li>在叶子节点真实数据之间使用链式结构前后连接， 支持范围查询</li></ol><p>实际的数据之存放在叶子结点里面，非叶子节点只存放索引值，</p><p>一般一个数据库有<font color='blue'>多个树</font>，有一个主键索引（聚簇索引）构成的树叶子节点存放数据，还有其他索引（二级索引 或者联合索引）构成的树，叶子节点存放主键值</p><p>所以查询流程是 如果涉及到二级索引， 先去索引表查主键，然后用主键去查实际的数据</p><p><strong>索引下推</strong> 可以在联合索引遍历的过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><blockquote><p>select * from table where a &gt; 2 and b = 1;</p><p>只有a可以用到索引，那判断b的时候是回表还是就地判断呢？</p><p>mysql5.6 引入索引下推优化之后， 可以就地判断</p></blockquote><p><strong>覆盖索引</strong> 当需要查询的东西在索引树的就可以取得，不用回表 就是 索引覆盖</p><p>如 select id from table where name = ‘jack’; 假设对name设立了索引</p><h4 id="索引区分度">索引区分度</h4><p>建立联合索引的时候，要把区分度大的字段放在前面， 这样区分度大的字段更有可能被更多的SQL使用到</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>区分度</mtext><mo>=</mo><mfrac><mtext>一个字段值的种类</mtext><mtext>行数</mtext></mfrac></mrow><annotation encoding="application/x-tex">区分度 = \frac{一个字段值的种类}{行数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">种</span><span class="mord cjk_fallback">类</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><blockquote><p>性别 可能就是区分度比较差的字段，男女比例应该是对半开，就不适合放在联合索引的前面， 因为如果搜哪个值都可以得到一半的结果，这样还不如不索引，直接扫全表</p></blockquote><h3 id="什么时候需要创建索引">什么时候需要创建索引</h3><p>优点 查询效率高 缺点 需要占用物理空间，并且维护索引表也需要开销</p><h4 id="什么时候要用">什么时候要用</h4><ol><li><p>字段唯一性限制</p></li><li><p>经常使用where查询的字段</p></li><li><p>经常使用group by和order by</p></li></ol><h4 id="什么时候不需要索引">什么时候不需要索引</h4><ol><li><p>区分度低</p></li><li><p>数据经常变动的字段</p></li><li><p><code>where</code> <code>group by</code>  <code>order by</code>用不到的字段</p></li></ol><h3 id="优化索引">优化索引</h3><h4 id="前缀索引优化">前缀索引优化</h4><p>使用某个字段中字符串的前几个字符建立索引，目的是为了减少索引字段的大小</p><p><strong>局限性：</strong></p><p>order by无法使用前缀索引</p><p>无法把前缀索引用作覆盖索引</p><h4 id="覆盖索引优化">覆盖索引优化</h4><p>将需要查询的信息也做成索引，这样就不用回表，可以直接使用覆盖索引返回</p><h4 id="主键索引最好是自增的">主键索引最好是自增的</h4><p>提高页面利用效率</p><h4 id="索引最好设置为not-null">索引最好设置为NOT NULL</h4><p>NULL会导致优化器的优化难度更大，count 会忽略NULL的行</p><h4 id="防止索引失效">防止索引失效</h4><ul><li>模糊匹配</li><li>查询的时候对索引列做了 计算， 函数， 类型转换</li><li>联合索引的最左匹配原则，按照最左优先的方式进行匹配</li><li>WHERE子句中，如果OR前面的条件列是索引列，而在OR之后的条件列不是索引列，则索引失效</li></ul><h1 id="事务">事务</h1><p>使用事务来保证执行事件的原子性</p><h3 id="事务特性">事务特性</h3><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p><ul><li>原子性(Atomicity)，一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样</li><li>一致性(Consistency)，是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态</li><li>隔离性(Isolation) 数据库允许多个并发事务同时对其数据进行读写和修改的能力</li><li>持久性(Durability) 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h3 id="并行事务会引发什么问题？">并行事务会引发什么问题？</h3><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p><p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p><h4 id="脏读">脏读</h4><p>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p><h4 id="不可重复读">不可重复读</h4><p>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p><h3 id="幻读">幻读</h3><p>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p><p>三种现象的严重性排序</p><p><font color='blue'><strong>脏读 &gt; 不可重复读 &gt; 幻读</strong></font></p><h3 id="事务的隔离级别有哪些？">事务的隔离级别有哪些？</h3><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>隔离水平 高低排序</p><p><font color='blue'>串行化 &gt; 可重复读 &gt; 读已提交 &gt; 读未提交</font></p><table><thead><tr><th></th><th>串行化</th><th>可重复读</th><th>读已提交</th><th>读未提交</th></tr></thead><tbody><tr><td>可能发生的现象</td><td>无</td><td>幻读</td><td>幻读 不可重复读</td><td>幻读 不可重复读 脏读</td></tr><tr><td>注释</td><td>级别最高，一把大锁</td><td>默认的级别</td><td>事务提交之后才能被人看到</td><td>还没提交之后，他的变更就可以被人看到</td></tr></tbody></table><p>所以要解决脏读，就需要隔离级别在读提交以上，要解决不可重复读，就要隔离级别在可重复读上，要解决幻读，提升级别为串行化，但是不建议，使用可重复读就可以很大程度避免幻读现象的发生</p><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">文章 (opens new window)</a>）</strong>，解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>四种隔离级别的实现：</p><ul><li>读未提交，不做操作，直接读取即可</li><li>串行化， 一把大锁</li><li>读提交和可重复读，他们是通过Read view（读视图）来实现的，区别在于创建Read View的时机不同，读提交是在每个语句执行前都重新生成一个Read View，而可重复读，是在事务启动的时刻创建了一个Read view，整个事务过程中都在使用这个read view</li></ul><blockquote><p>注意，开启事务并不意味着启动了事务，在mysql中有两种开启事务的命令，分别是：</p><ul><li><p>begin/start transaction</p></li><li><p>start transaction with consistent snapshot</p><p>第一种 只有在执行这个命令之后，再执行一条selevt语句，才是真正启动事务的时机</p><p>第二种 马上启动事务</p></li></ul></blockquote><h3 id="read-view-在mvcc-如何工作">Read View 在MVCC 如何工作</h3><h4 id="read-view-中的4个重要字段">read view 中的4个重要字段</h4><ul><li>m_ids： 指的是创建Read View**<code>时</code><strong>，当前数据库中“活跃事务”的事务id</strong>列表**，活跃事务 就是 启动了 但是还没有提交的事务</li><li>min_trx_id: 指的创建Read View时， 当前数据库中 活跃事务 中事务id 最小事务，<font color = 'blue'>也就是m_ids列表的最小值</font></li><li>Max_trx_id:并不是m_ids的最大值，而是创建Read View时当前数据库中应该给下一个事务的id值，<font color='blue'> 也就是全局事务中最大的事务id值+1</font></li><li>creator_trx_id: 指的是创建该Read View<strong>事务id</strong></li></ul><h4 id="聚簇索引记录中的两个隐藏列">聚簇索引记录中的两个隐藏列</h4><p>在表中，每条记录除了保存的数据之外，还有两个隐藏列，追加在末尾，trx_id, roll_pointer</p><table><thead><tr><th>id</th><th>name</th><th>…</th><th>trx_id</th><th>roll_pointer</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>指向undo日志</td></tr></tbody></table><ul><li>trx_id， 当一个事务对某条聚簇索引记录<font color='blue'>进行改动时</font>，就会把该事务的id记录在trx_id隐藏列中</li><li>roll_pointer，每次对某条聚簇索引进行改动时，就会把旧版本的记录写入到undo日志中，这个隐藏列是一个指针，指向每一个旧版本记录，可以通过它来回滚</li></ul><p>在创建Read view 之后， 记录中的trx_id可以划分成这三种情况</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240806231328.png" alt=""></p><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的trx_id值小于当前Read view 中的<code>min_trx_id </code>值，表示这个版本的记录是在创建当前 Read view 前已经提交的事务发生的，所以该版本的记录对当前事务可见</li><li>如果记录的trx_id值大于等于当前Read view中的<code>max_trx_id</code>值，表示这个版本的记录是在创建Read view后才启动的事务生成的，所以该版本的记录对当前事务不可见</li><li>如果记录的trx_id值在当前Read view 的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断trx_id是不是在<code>m_ids</code>列表：<ul><li>记录的trx_id在 m_ids列表中，表示这个版本记录的活跃事务还没提交，对该版本的记录不可见</li><li>不在列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见</li></ul></li></ul><p>这种通过 <font color='blue'>版本链 来控制并发事务访问同一个记录时的行为</font>就叫MVCC(多版本并发控制)</p><h4 id="可重复读是如何工作的">可重复读是如何工作的</h4><p>可重复读 是在启动事务时 生成一个Read View，然后整个事务期间都在使用这个Read View。</p><h4 id="读提交是如何工作的">读提交是如何工作的</h4><p>在每次读取数据时，都会生成一个新的Read View</p><h4 id="mysql可重复读隔离级别-完全解决幻读了吗？-并没有">Mysql可重复读隔离级别，完全解决幻读了吗？ - 并没有</h4><h4 id="什么是幻读">什么是幻读</h4><blockquote><p>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row</p></blockquote><p>当一个事务的同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题，</p><p>假设一个事务在T1时刻和T2时刻分别执行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test WHERE id &gt;100;</span><br></pre></td></tr></table></figure><p>途中没有执行其他任何语句（或者执行了也可以，英文定义只是说了时间不同结果不同），只要这两个时刻执行产生的结果集不同，就发生了幻读问题</p><h4 id="快照读是如何避免幻读的">快照读是如何避免幻读的</h4><p>事务开启时创建一个Read View，整个事务使用的都是这个read view，保证了事务过程中每次查询的数据都是一样的</p><h4 id="当前读是如何避免幻读的">当前读是如何避免幻读的</h4><p>msyql除了普通查询时快照读，其他的都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据然后在进行进一步的操作。</p><p>且 select for update这种查询语句是当前读</p><p>如果在可重复读隔离级别下，没有实现锁，那么就会在事务期间出现幻读的现象，-&gt; 为了解决可重复读隔离级别使用当前读 而造成的幻读问题，引出来的间隙锁</p><p>例如对id范围（3，5） 加了间隙锁，这样试图插入id为4的事务操作就会失败，就可以防止幻读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM t_stu WHERE id &gt; 2 for update;</span><br></pre></td></tr></table></figure><p>这条语句就会对id 范围为 (2,+∞] 加上 next-key lock (next-key lock 时间隙锁+记录锁的组合)</p><p>然后如果有其他事务B试图插入数据，会发现插入的范围已经加锁，于是事务B会生成一个插入意向锁，同时进入等待状态，知道事务A提交了事务，这样就避免了事务B插入新纪录而导致事务A发生幻读的现象。</p><h4 id="可重复读隔离级别发生幻读的场景">可重复读隔离级别发生幻读的场景</h4><h5 id="1">1</h5><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><h5 id="2">2</h5><p>除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录</p><h1 id="锁">锁</h1><h3 id="全局锁">全局锁</h3><h4 id="使用">使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock </span><br></pre></td></tr></table></figure><p>这样，整个数据库就处于只读状态，这时其他线程执行数据的增删改insert delete update，表结构的更改alter table drop table等语句 都会被阻塞</p><p>如果要释放全局锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><h4 id="应用场景">应用场景</h4><p>主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样</p><h4 id="缺点">缺点</h4><p>加上全局锁，意味着整个数据库都是只读状态。</p><p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><h4 id="有什么方式可以避免影响业务？">有什么方式可以避免影响业务？</h4><p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><h3 id="表级锁">表级锁</h3><h5 id="有哪些">有哪些</h5><p>表锁，元数据锁，意向锁，AUTO-INC锁</p><h5 id="表锁">表锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line">lock tables t_student write;</span><br></pre></td></tr></table></figure><p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>会话退出后，也会释放所有表锁</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能</p><h5 id="元数据锁-mdl">元数据锁（MDL）</h5><p>不需要显式地使用MDL，当对数据库表进行操作的时候，会自动给表加上MDL</p><ul><li>对一张表进行CRUD（create read update delete）操作的时候，加的是MDL读锁</li><li>做结构变更操作的时候，加的是MDL写锁</li></ul><p>MDL 是为了保证用户对表执行CRUD操作的时候，防止其他线程修改表的结构。</p><blockquote><p>当有线程在执行select语句的时候（加MDL锁）期间，如果有其他线程需要修改表的结构（申请MDL写锁），那么会被阻塞，知道执行完select语句（释放MDL读锁）</p><p>当有其他线程对表结构进行变更（加MDL写锁）期间，如果有其他线程执行了CRUD操作（申请MDL读锁），那么就会被阻塞， 直到表的结构变更完成（MDL写锁释放）</p></blockquote><h5 id="意向锁">意向锁</h5><ul><li>在使用innoDB引擎的表里对某些记录加上共享锁之前， 需要现在表级别加上一个 <code>意向共享锁</code></li><li>对某些记录加上独占锁之前，需要先在表级别加上一个<code>意向独占锁</code></li></ul><p>也就是当执行 插入 更新 删除操作的时候，需要先对表加上 <code>意向独占锁</code>然后对该记录加独占锁</p><p>普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p>不过，select 也是可以对记录加共享锁和独占锁的</p><p>意向锁的目的是为了<font color='blue'>快速判断表里是否有记录被加锁</font></p><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h5 id="auto-inc锁">AUTO-INC锁</h5><p>表的主键 通常都是设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMNET</code>属性来实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h3 id="行级锁">行级锁</h3><p>InnoDB 引擎是支持行级锁的，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对读取的记录加共享锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁</span><br><span class="line">select ... for update;</span><br></pre></td></tr></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。</p><p><mark> 共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</mark></p><p>行级锁的类型主要由三类</p><ul><li>Record Lock 记录锁，也就是仅把一条记录锁上；</li><li>Gap Lock 间隙锁，锁定一个范围，但是不包含记录本身</li><li>Next-key Lock，上面二者的组合，锁定一个范围，并且锁定记录本身</li></ul><h5 id="record-lock">Record Lock</h5><p>锁住的是一条记录，记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><p><font color = 'blue'> 也就是只有s与s可以兼容</font></p><p>当事务执行commit 之后， 事务过程中生成的锁都会被释放。</p><h5 id="gap-lock">Gap Lock</h5><p>间隙锁 只存在于 可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><h5 id="next-key-lock">Next-key Lock</h5><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录</p><p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p><h5 id="插入意向锁">插入意向锁</h5><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p><h3 id="mysql是如何加锁的？">Mysql是如何加锁的？</h3><h5 id="什么sql语句会加行级锁？">什么sql语句会加行级锁？</h5><p>普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 加共享锁 （S锁）</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁 （ X锁）</span><br><span class="line">select ... for update;</span><br><span class="line"></span><br><span class="line">//这两种 查询 会加锁的语句称之为锁定读。</span><br></pre></td></tr></table></figure><p><strong>除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)</strong></p><h5 id="mysql是如何加行级锁的？">mysql是如何加行级锁的？</h5><p>加锁的对象是索引， 加锁的基本单位是next-key lock，<mark background color='pink'>next-key 是前开后闭区间，而间隙锁是前开后开区间。</mark></p><p>但是，next-key lock 在一些场景下会退化成记录锁或者间隙锁</p><blockquote><p>在使用记录锁或者间隙锁就能避免幻读现象的场景下，next-key lock 就会退化成记录锁或间隙锁。</p></blockquote><h6 id="唯一索引等值查询">唯一索引等值查询</h6><ul><li><p>当查询的记录是存在的时候，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock <font color='blue'>会退化成 记录锁</font></p></li><li><p>不存在的时候， 在索引树找到第一条大于该查询记录的记录之后，将该记录的索引中的next-key lock <font color = 'blue'>会退化成 间隙锁 </font></p></li><li></li></ul><h6 id="唯一索引范围查询">唯一索引范围查询</h6><h6 id="非唯一索引等值查询">非唯一索引等值查询</h6><h6 id="非唯一索引范围查询">非唯一索引范围查询</h6><h6 id="没有加索引的查询">没有加索引的查询</h6><h1 id="日志">日志</h1><p>三种日志</p><ul><li>Undo log 回滚日志， innoDB 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要用于事务回滚和MVCC</li><li>redo log（重做日志）：innoDB 存储引擎层生成的日志，实现了事务中的<mark>持久性</mark>，主要用于掉电等故障恢复</li><li>binlog 归档日志， 是server层生成的日志， 主要用于数据备份和主从复制</li></ul><h3 id="undo-log？">undo log？</h3><p>我们在执行一条“增删改“语句的时候，虽然没有输入begin开启事务和commit提交事务，但是mysql会 <strong>隐式</strong> 开启事务，来执行对应的语句，执行完成就自动提交事务</p><p>执行一条语句是否自动提交事务，是由 <code>autocommit</code> 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。</p><blockquote><p>那么 考虑一个问题，一个事务在执行过程中，在还没有提交事务之前，如果mysql发生了崩溃，要如何回滚到事务之前的数据呢？</p></blockquote><p>如果每次在事务执行的过程中，都记录下回滚事需要的信息到一个日志，那么在事务执行中途发生了mysql崩溃之后，就可以通过这个日志回滚到事务之前的数据。</p><p>实现这一机制的就是 <code>undo log</code>,<font color = 'blue'> 它保证了事务的ACID特性中的原子性</font></p><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 <code>roll_pointer</code> 指针和一个<code> trx_id</code> 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><p>另外 undo log 还有一个作用， 就是通过 ReadView + undo log 实现MVCC</p><p>因此 undo log 的两大作用：</p><ul><li>实现事务回滚， 保障事务的原子性</li><li>实现MVCC的关键之一 ReadView + undo log 的版本链</li></ul><h3 id="redo-log">redo log</h3><p>为了效率，mysql的数据读写都是先对内存操作，buffer pool的，内存不可靠，所以需要持久化到硬盘，</p><p>所以写数据的时候 先更新内存，然后将修改持久化到redo log中，这个时候更新就算ok了</p><p>后台线程会把内存的dirty pae 刷盘，当系统crash的时候，虽然内存的数据丢失了，但是redolog已经持久化好了，只要mysql重启之后，数据就可以保持一致</p><p><font color='blue'>结合前面的undo log， 数据的写入是这样的，在开启事务之后， sql的每个操作回先写undo log，方便回滚，然后写buffer pool， 持久化到redo log中， 后台线程找时间去把dirty page刷入磁盘中</font></p><p><font color='red'>在内存修改undo页面后 也需要记录对应的redo log</font></p><p>Redo log 保证的事务完成之后的数据</p><p>undo 是为了回滚 所以 是记录的事务开启之前的数据状态</p><p><mark>redo + undo 就可以把数据库从异常状态恢复到稳定一致的某个状态，也就是 所以的事务要么是已经执行完毕 要么是还没开始执行，而不是有事务执行到中间然后crash 的状态</mark></p><p>redo log 也不是直接写入磁盘，而是有自己的redo log buffer，默认大小是16MB，通过<code>innodb_log_Buffer_size</code>参数设置</p><h4 id="redo-log-刷盘">redo log 刷盘</h4><p>时机</p><ol><li>mysql正常关闭的时候</li><li>redo log buffer记录的量大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>总的redo buffer size的时候，触发</li><li>后台每隔一秒 持久化一次</li><li>每次事务提交的时候都将redo buffer 持久化，通过  <code>innodb_flush_log_at_trx_commit</code>参数控制</li></ol><h4 id="checkpoint机制-redo-log">checkpoint机制 + redo log</h4><p>redo log 把所有磁盘IO操作都记录了下来，但是不会删除，所以就会有已经持久化的操作还留在log中，如果重启从redolog头部开始处理，数据库就不一致了，所以有一个checkpoint 记录了还没写到磁盘的数据在redo log 的偏移</p><h3 id="binlog">binlog</h3><p>redo 和 undo 都是存储引擎层面的</p><p>binlog是server层的日志</p><p>MySQL 在完成一条更新操作后，Server层会生成一条bin log， 事务提交之后，会将该事务执行过程中产生的所有bin log 写入 binlog 文件</p><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><h4 id="redo-vs-bin">redo vs bin</h4><p>1、适用对象不同</p><p>bin是server层生成的日志，所有的存储引擎都可以使用</p><p>redo是innodb的 只有innodb可以使用</p><p>2、文件格式不同</p><p>bin的三种格式 <code>STATEMENT</code> <code>ROW</code> <code>MIXED</code></p><p>3、写入方式不同</p><p>binlog 是追加写入，一个文件写满了，就创建一个新的文件继续写，不会覆盖之前的日志，是<font color='blue'>全量的日志</font></p><p>Redo log 是循环写， 日志空间大小是固定的，全写满就从头覆盖开始，保存未被刷入磁盘的脏页日志</p><p>4、用途不同</p><p>bin 用于备份恢复，主从复制， 整个数据库被删除了，可以通过bin来恢复</p><p>redo 用于掉电恢复</p><h4 id="binlog-何时刷盘">binlog 何时刷盘</h4><p>事务执行的时候，先把日志写到binlog cache中，事务提交的时候，再把binlog写到binlog 文件中</p><p>由参数<code>sync_binlog</code>决定何时刷盘</p><ul><li>0 表示每次提交事务只是write到了内核，而没有fsync，fsync由os决定</li><li>1 表示 提交事务 write 到内核 然后马上fsync</li><li>N 表示 wirte到内核 累计到了N个之后再fsync</li></ul><h3 id="执行update语句的时候发生了什么？">执行update语句的时候发生了什么？</h3><p><code>UPDATE t_user SET name = 'jeyce' where id = '6'</code></p><ol><li><p>解析器负责解析，优化器负责计算出成本最小的执行计划，执行期负责具体执行（调用存储引擎的API），存储引擎负责具体IO操作</p><ul><li>如果这个数据页在buffer pool中，直接返回给执行器</li><li>不在，从磁盘读取</li></ul></li><li><p>执行器得到 <code>聚簇索引</code>记录之后，比较更新前后的值是否一致</p><ul><li>是 pass</li><li>否，把更新前的记录和更新后的记录都传给innoDB层，让innoDB执行更新操作</li></ul></li><li><p>开启事务，更新前，<font color='blue'>记录undolog</font> , 把旧值记录下来，方便回滚，<mark> 持久化成功之后，才真正开启事务</mark></p></li><li><p>innoDB开始更新记录，会先更新内存（同时标记为脏），然后将记录写入到redo log，这个时候更新就已经完成了，数据刷入内存的事情由后台IO线程去做（等到堆积一定的时间，就可以把随机IO 变成近似顺序IO，提高效率）</p></li><li><p>在一条更新语句执行完成之后，开始记录语句对应的binlog，记录到cache中，等到事务提交的时候统一刷新到硬盘</p></li><li><p>事务提交，「两阶段提交」</p></li></ol><h3 id="为什么需要两阶段提交？">为什么需要两阶段提交？</h3><p>事务提交之后，redo 和 binlog都需要持久化到磁盘，但是这两个是独立的，会出现半成功的状态，也就是一个写入了，一个还没写入</p><p><strong>两阶段提交</strong> 要么全部成功 要么全部失败</p><p>redo log prepate -&gt; 写binlog -&gt; redo log commit 两阶段提交</p><h4 id="情况1-redolog-prepare-binlog宕机">情况1 redolog prepare binlog宕机</h4><p>由于bin log失败，所以bin log也没有记录，且redo log没有commit ，于是两者状态一致，没问题</p><h4 id="情况2-redo-log-prepare-binlog成功-commit-失败">情况2 redo log prepare ，binlog成功，commit 失败</h4><p>此时 bin log 产生了记录，redo log 没有写入成功，数据暂时不一致。</p><p>但是不用担心，当 MySQL 重启时，会检查 redo log 中处于 prepare 状态的记录。在 redo log 中，记录了一个叫做 XID 的字段，这个字段在 bin log 中也有记录，MySQL 会通过这个 XID，如果在 bin log 中找到了，那么就 commit 这个 redo log，如果没有找到，说明 bin log 其实没有写成功，就放弃提交。</p><p>通过这样的机制，保证了 redo log 和 bin log 的一致性。</p><p><mark>两阶段提交是以binlog为事务提交成功的标志</mark></p><p>，因为binlog写入成功了，就意味着能在binlog中找到redolog相同的XID</p><h3 id="mysql的主从复制">mysql的主从复制</h3><p>使用binlog 来进行主从复制，一般是异步的</p><ul><li>主库写binlog日志，提交事务，并且更新本地存储数据</li><li>把binlog复制到所有从库上，每个从库把binlog写到暂存日志中</li><li>从库回放binlog 更新存储引擎的数据</li></ul><p>一主多从 一般是 一主 一从 一 备用主， 主负责写，从负责读</p><h2 id="为什么需要两阶段提交">为什么需要两阶段提交</h2><h1 id="内存">内存</h1><p>（innoDB）存储引擎的作用就是根据执行计划，来 向内存和磁盘写入数据</p><p>buffer pool 默认大小是128MB</p><ul><li>当读取数据时，如果数据存在bufferpool 中，客户端就会直接读取pool中的数据，否则再去访问磁盘</li><li>修改数据的时候，先修改buffer pool中数据所在的页，将其设置为dirty， 然后由后台线程将脏页写入到磁盘</li></ul><p>innoDB会把存储的数据划分为页，一个页的默认大小是16KB，所以buffer pool同样也按照页来划分</p><p>在mysql启动的时候， innoDB为Buffer pool申请一片连续的内存空间，按照16KB的大小划分出 页，</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> ACID </tag>
            
            <tag> CRUD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘HDD工作原理</title>
      <link href="/2024/08/09/%E7%A3%81%E7%9B%98HDD%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2024/08/09/%E7%A3%81%E7%9B%98HDD%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>磁盘HDD 工作原理</p><h2 id="结构">结构</h2><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240809203120.png" alt=""></p><h2 id="原理">原理</h2><p>磁盘高速旋转 使得表面有一层气流可以托起磁头在磁盘表面微米距离悬浮，</p><p>磁盘是刚性合金材料制成，表面涂抹有磁性材料，磁头通过感应或者修改磁性来读取写入数据</p><h2 id="性能参数">性能参数</h2><p>寻道时间 磁头移动到指定的磁道所用的时间</p><p>旋转延迟时间 等待指定的扇区从磁头下方旋转经过</p><p>数据传输时间 磁头读取数据， 数据传入内存用的时间</p><h3 id="调度-寻道-算法">调度（寻道）算法</h3><h4 id="fcfs-先来先服务算法">FCFS 先来先服务算法</h4><p>根据进程请求访问磁盘的先后顺序进行调度</p><p>请求序列：123，874，692，475，105，376，开始在345磁道上</p><p>最终的访问顺序是 <font color='blue'>345，123，874，692，475，105，376</font></p><p>磁头总共移动的磁道数= <font color='red'> 345-123 + 874-123 + 874-692 … = 2013</font></p><h4 id="sstf-最短寻找时间优先算法">SSTF 最短寻找时间优先算法</h4><p>优先处理与当前磁头最近的磁道（贪心）</p><p>未必能获得最优的平均寻道时间</p><p>请求序列：123，874，692，475，105，376，开始在345磁道上</p><p>最终的访问顺序是<font color='blue'>376，475，692，874，123，105；</font></p><p>移动的磁道数 是 <font color='red'>1298</font></p><p>缺点：可能导致<mark>饥饿</mark></p><p>​试想，磁头在100处， 现在来了一个101，800，99，102，98，103，97… SSTF算法会一直访问100附近的磁道请求，而相对较早来的800磁道请求一直得不到响应</p><h4 id="scan-扫描算法-也叫电梯算法">SCAN 扫描算法 也叫电梯算法</h4><p>只有磁头移动到外侧的时候才能往内部移动，移动到最内侧才能往外移动</p><p>请求序列：123，874，692，475，105，376，开始在345磁道上</p><p>假设还是345磁道，并且读写头正在朝着0移动</p><p>则访问顺序: <font color='blue'> 123,105,0,376,475,692,874</font></p><p>磁头移动的磁道数<font color='red'>（345-0） + （874 - 0） = 1219</font></p><p>缺点： 对于各个位置的磁道的响应频率不平均</p><p>假如 345向 0 移动的时候 出来一个346的请求，明明向后移动一下就可以访问，现在需要移动 2 * 345 ，延迟翻倍</p><h4 id="look">LOOK</h4><p>基于扫描算法 在磁头的移动方向上没有别的请求，就立即改变磁头移动方向</p><p>请求序列：123，874，692，475，105，376，开始在345磁道上</p><p>假设 345 往0移动</p><p>访问顺序  <font color='blue'>345， 123，105，   376，475，692，874</font></p><p>移动磁道数 <font color='red'>345-105 + 874-105 = 1009</font></p><h4 id="cscan-循环扫描算法-单项电梯">CSCAN 循环扫描算法 单项电梯</h4><p>只有磁头 朝 <strong>某个特定的方向</strong> 移动的时候才处理磁道访问请求，而返回的时候直接快速移动到起始位置而不处理任何读写请求</p><p>请求序列：123，874，692，475，105，376，开始在345磁道上 往0 移动</p><p>访问序列 <font color='blue'>345, 123, 105, 0, 999, 874,692,475,376</font></p><p>移动磁道数 <font color='red'> (345-0) + (999-0) + (999 - 376) = 1967</font></p><h4 id="c-look-单项look">C-LOOK 单项look</h4><p>基于循环扫描算法，在磁头移动方向上已经没有访问请求，理解返回固定方向起始位置处的第一个访问请求</p><p>请求序列：123，874，692，475，105，376，开始在345磁道上 往0 移动</p><p>访问顺序 <font color = 'blue'> 123, 105,874,692,475,376</font></p><p>移动磁道数 <font color='red'>(345 - 105) + (874-105) + (874-376) = 1507</font></p>]]></content>
      
      
      
        <tags>
            
            <tag> FCFS </tag>
            
            <tag> SSTF </tag>
            
            <tag> SCAN </tag>
            
            <tag> LOOK </tag>
            
            <tag> CSCAN </tag>
            
            <tag> CLOOK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>文章是参考 小林coding 的学习笔记，仅供参考个人学习使用！！！</p><h2 id="网络模型">网络模型</h2><p>三种模型 分别是OSI TCP/IP 五层模型</p><p>七层OSI 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层</p><blockquote><p>为什么要设计不同的layer？</p></blockquote><p>对于同一台设备的不同进程的通信，有很多方式 <font color = blue>管道，消息队列，信号，共享内存 </font>,  但是对于不同设备的进程间通信，就会使用到网络通信， 各种设备具有不同的特性，为了兼容，就协商出了一套通用的网络协议</p><p>网络的分层：</p><ol><li><strong>模块化设计</strong>：网络分层将整个网络系统分解为多个层次，每个层次都有特定的功能和责任。这种模块化设计使得网络结构更加清晰，降低了网络系统的复杂度，方便了系统的设计、开发和维护。</li><li><strong>标准化</strong>：每个网络层次都有相应的标准和协议，定义了该层次的功能、数据格式、传输方式等规范。这些标准和协议使得不同厂商的网络设备和软件可以互相兼容和通信，促进了网络设备的互联互通。</li><li><strong>提高可靠性</strong>：各层之间解耦合，由于每个层次都有明确的功能和责任，网络分层可以提高网络系统的可靠性。当一个层次出现问题时，只需修复该层次，而不会影响到其他层次，从而提高了网络系统的稳定性和可靠性。</li><li><strong>提高性能</strong>：网络分层可以使网络通信过程更加高效。每个层次只需关注自己的功能和责任，而不需要关心其他层次的具体实现细节，从而提高了网络通信的效率。</li><li><strong>降低成本</strong>：网络分层可以将网络系统分解为多个相对独立的模块，降低了系统设计、开发和维护的成本。此外，通过使用标准化的协议和技术，可以降低网络设备和软件的开发成本，提高了网络系统的经济效益。</li></ol><h2 id="tcp-ip-网络模型">TCP/IP 网络模型</h2><h4 id="应用层">应用层</h4><p>进程需要通信时，就把数据传给下一层，应用层只需要关注为用户提供功能，如HTPTP，FTP，Telnet，DNS, SMTP;</p><p>应用层不关心怎么传输，只负责把数据给传输层</p><p>工作在用户态</p><h4 id="传输层">传输层</h4><p>应用层的数据包会给传输层，传输层负责给应用层提供服务</p><h5 id="两个协议tcp和udp">两个协议TCP和UDP</h5><p>Transmission Control Protocol, 大部分应用使用的都是传输控制协议TCP，如HTTP，TCP面向连接，多了很多特性，保证可靠的交付，UDP不保证可靠交付，但是传输效率较高</p><blockquote><p>要实现可靠的UDP也可以，只需要在UDP上把TCP的特性实现一遍就行了，拥塞控制，流量控制，超时重传…</p></blockquote><p>要传输的数据可能很大，直接传不太方便，所以需要对数据包进行分块，TCP传输的数据是报文段，传输的数据大小超过了MSS（TCP最大报文段长度），就需要对数据包分块，这样即使有一个包丢失了，只需要重传丢失的即可。</p><p>传输层在接收方需要干的事情就是 负责处理下层送上的数据，去掉之前加上的头部，顺序重组，校验和… 然后上传给应用层</p><blockquote><p>如何区分是哪个应用呢？端口号</p><p>80 web服务器使用的端口号，22 ssh服务使用的端口号…</p></blockquote><h4 id="网络层">网络层</h4><p>传输层只负责传输过程的一些预处理，但实际上并不负责传输</p><p>实际上的网络环境十分复杂，有非常多的节点和设备，需要进行路径和节点的选择，这部分交给传输层做就有点冗余了，因此把这一部分分出来给网络层做，进一步解耦。</p><p>网络层最常使用的就是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP头部组成IP报文，如果IP报文超过了MTU（1500 bytes normally），就再次分段，得到一个IP报文段。</p><blockquote><p>网络层负责将数据传输到另外一个设备，世界上这么多设备，如何找到对方呢？网络层需要有 区分不同设备的编号 -&gt; <mark background-color="yellow">IP</mark></p></blockquote><p>网络号 主机号 子网掩码</p><p>在寻址过程中，先找到对应的网络号（先找到学校），再去找主机号（在找对应的人）</p><p>除了寻址，网络层还有一件事情就是路由，数据传输过程中，并不是一条网线走到黑，而是需要经过一系列的节点（交换机，路由器，转发），所以网络层需要通过路由算法来决定下一步走哪个节点</p><p>IP协议告诉你要去哪里，路由告诉你下一跳该去哪，一个是大局，一个是细节</p><h4 id="网络接口层">网络接口层</h4><p>加上了IP头部之后，交给网络接口层，在头部再加上MAC头部，封装成一个数据帧发送到网络上</p><p>IP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们就可以知道这个包要去哪，但是在以太网的世界中，是行不通的，</p><p>以太网是一种在局域网内将附近的设备连接起来进行通信的技术。以太网在区分设备的时候是通过MAC地址判断的，MAC就是设备网卡的硬件地址，出厂时唯一设定，</p><p>MAC头部是以太网使用的头部，包含接收方和发送方的MAC地址信息，可以通过ARP协议获取MAC地址，</p><p>网络接口层为网络提供 <strong>链路级别</strong> 传输的服务，负责在以太网，WIFI这样的底层网络上发送数据包，工作在网卡这个层次，使用MAC地址来标识网络设备</p><table><thead><tr><th>层级</th><th>地址类型</th><th>功能</th></tr></thead><tbody><tr><td>网络层 (IP)</td><td>IP地址</td><td>在网络中唯一标识设备</td></tr><tr><td>数据链路层</td><td>MAC地址</td><td>在同一局域网内唯一标识设备</td></tr></tbody></table><h4 id="总结">总结</h4><p><strong>上至下</strong></p><table><thead><tr><th style="text-align:center">layer</th><th style="text-align:center">数据包格式</th><th style="text-align:center">处理操作</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:center">数据包</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:center">报文段</td><td style="text-align:center">加上TCP头（校验和，ack，syn等等</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">ip报文</td><td style="text-align:center">加上ip头，加入目标地址ip原地址ip</td></tr><tr><td style="text-align:center">网络接口层</td><td style="text-align:center">MAC帧</td><td style="text-align:center">加上mac头，下一跳mac地址，帧头 帧尾</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center">01比特流</td><td style="text-align:center"></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240815165254.png" alt=""></p><p><strong>下至上</strong></p><table><thead><tr><th style="text-align:center">layer</th><th style="text-align:center">数据包格式</th><th style="text-align:center">处理操作</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:center">数据包</td><td style="text-align:center">处理数据</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:center">报文段</td><td style="text-align:center">去掉TCP头，按照序号重组，验证校验和… 发送给对应应用层端口号</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">ip报文</td><td style="text-align:center">去掉IP头尾 发送到上一层</td></tr><tr><td style="text-align:center">网络接口层</td><td style="text-align:center">MAC帧</td><td style="text-align:center">去掉mac帧 头尾，发送到上一层</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center">01比特流</td><td style="text-align:center"></td></tr></tbody></table><h2 id="数据包在网络中的传输-以http报文为例">数据包在网络中的传输（以HTTP报文为例）</h2><h4 id="http-hypertext-transfer-protocol">HTTP (Hypertext Transfer Protocol)</h4><p>首先要做解析 URL，从而生成发送给web服务器的请求信息</p><p><a href="http://web-server/dir/file.html">http://web-server/dir/file.html</a></p><table><thead><tr><th>协议名字</th><th>分隔符</th><th>服务器名字</th><th>目录名</th><th>…</th><th>文件名</th></tr></thead><tbody><tr><td>http</td><td>//</td><td>web-server</td><td>dir</td><td></td><td>file.html</td></tr><tr><td>https</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>Web-server : /-  <font color = "blue">根目录</font></p><p>​|-dir1</p><p>​|-dir2</p><p>​|-dir3- file.html</p><p>当没有指定文件的时候，返回的是根目录下的默认文件</p><p>对url进行解析之后，浏览器确定了服务器和文件名以及对应的协议， 根据这些信息就可以生成HTTP请求消息了。</p><h4 id="dns-domain-name-system-地址解析协议">DNS （Domain Name System） 地址解析协议</h4><p>web-server 一般是一个 域名 如 <a href="http://www.baidu.com">www.baidu.com</a> = <a href="http://www.baidu.com">www.baidu.com</a>. ，但是网络中的地址是IP地址，如何通过域名得到IP？ -&gt; <strong>DNS 协议</strong></p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>域名使用. 来分隔，实际上域名最后还有一个点. 表示根域名，根域名 <mark background-color = "yellow"> . </mark> ，顶级域名 <mark background-color="red">.com</mark> ,</p><p>域名的层级关系类似一颗树</p><ul><li>根DNS服务器 .</li><li>顶级域DNS服务器 .com</li><li>权威DNS服务器 <a href="http://Baidu.com">Baidu.com</a></li></ul><hr><p>域名解析的工作流程</p><ol><li>客户端首先发起一个DNS请求，问www.server.com的ip是什么，并且发送给本地的DNS服务器（也就是客户端TCP/IP设置中填写的DNS服务器地址，如114.114.114.114</li><li>本地域名服务器收到客户端的请求之后，如果缓存有www.server.com的记录，就直接返回，如果没有，本地DNS会去询问他的根域名服务器，根具有所有域名的IP，但并不能直接告诉，只能指路</li><li>根DNS收到本地请求之后，<a href="http://xn--oor206bvhj.com">发现有.com</a> ,于是回复 这个事情归 .com顶级域名服务器管理，你去问他吧</li><li>本地DNS收到了根返回的  .com顶级域名服务器 地址， 于是向他询问</li><li>顶级域com服务器 回复 给 负责www.server.com区域的权威DNS地址</li><li>本地 DNS 于是转向问权威 DNS 服务器：www.server.com对应的IP是啥， <a href="http://server.com">server.com</a> 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><blockquote><p>是否每次解析域名都要经过这么复杂的步骤？</p></blockquote><p>否，因为有缓存，缓存就发挥作用了，如果<em><strong>浏览器自身</strong></em>有这个域名对应的缓存，就直接返回，没有的话就去问<em><strong>操作系统的缓存</strong></em>，还没有就去<em><strong>hosts文件</strong></em>查看，再没有才去问<em><strong>DNS服务器</strong></em></p><p><font color = "blue"> 现在已经获得目的计算机的IP了，接下来数据包要怎么做呢？</font></p><p>协议确定 端口号其实也确定了， 这样目的IP + PORT 都确定了</p><ul><li>http 80</li><li>https 443</li></ul><h4 id="协议栈">协议栈</h4><p>获得目的IP之后，就可以把HTTP的传输工作交给操作系统的协议栈</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/202408151707404.png" alt=""></p><p>协议栈分为几个部分，分别承担不同的工作，上面负责委托下面工作，下面负责为上面提供服务</p><blockquote><p>GPT: 协议栈（Protocol Stack）是指在计算机网络中，一组按照层次结构组织的网络协议的集合。这些协议按照功能和责任被分成不同的层次，每一层都负责执行特定的功能，从物理层到应用层依次排列。协议栈的每一层都建立在下一层的基础上，并为上一层提供服务。</p></blockquote><p>应用程序 通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP</p><p>下半部分是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。traceroute ping 就是使用ICMP来实现的。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作</p><h4 id="tcp">TCP</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240817144558.png" alt=""></p><p>TCP协议 可靠传输 如何保证的？</p><ul><li><p>面向连接 能够建立可靠的连接</p></li><li><p>序列号 保证包的按顺序重组 有序性</p></li><li><p>确认号 + 超时重传</p></li><li><p>流量控制</p></li><li><p>拥塞控制</p></li><li><p>校验和 保证数据包的正确性</p></li></ul><p><code>URG</code> 表示有紧急消息</p><p><code>ACK</code> 表示回复</p><p><code>PSH</code> 表示接受端应当尽快把消息推送到应用层，而不是等待缓冲填满</p><p><code>RST</code> 表示重置连接</p><p><code>SYN</code> 表示发起一个连接</p><p><code>FIN</code> 结束连接</p><p><strong>窗口大小</strong>  用于发送速率控制，流量控制</p><p>如果应用层的请求消息比较长，超过了MSS的长度，TCP就会把数据包分块,然后再给网络层</p><ul><li>MSS 数据包的最大长度，超过这个长度会被传输层分段</li><li>MTU 网络包的最大长度，以太网一般为1500bytes，超出这个长度会被网络层（IP） 分段</li></ul><p>linux下可以使用<code>netstat -napt</code>来查询tcp连接的状态</p><h4 id="ip">IP</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240814171844.png" alt=""></p><p><code>协议</code> 0x06 表示TCP  0x17表示UDP</p><blockquote><p>当客户端有多个网卡的时候，就会有多个IP地址，这个时候如何选择IP？</p></blockquote><p>根据路由表来选择，<code>route -n</code> 查看路由表，网络号匹配就直接走这张卡，否则直接走默认网卡<a id="计算机路由"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.120.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0</span><br><span class="line">0.0.0.0         192.168.120.240 0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><p>步骤：</p><ul><li>IP地址与Genmask 与 之后的结果与 Destination比较，一致的话就选择这张网卡来发送数据</li><li><font color='blue'>有一个特殊的Genmask 0.0.0.0 是默认网卡</font></li></ul><h4 id="mac">MAC</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240815173202.png" alt=""></p><p>MAC头部是在以太网内部使用的头部，目的是为了在以太网内部区分不同的主机</p><p>协议类型只有两种</p><ul><li>0800 IP协议</li><li>0806 ARP协议</li></ul><p>发送方MAC地址 从网卡读出来就好了，接收方的MAC地址从何而来？<strong>ARP （Address Resolution Protocol）</strong> 通过在局域网内广播接收方的IP地址，接收方收到信息之后，就知道有人在找自己这个IP的MAC地址，于是就回复自己的MAC地址给他</p><p>为什么这个时候已经可以使用ip地址来通信了，还要使用mac地址？</p><blockquote><p>我猜测原因之一是因为 局域网内的IP地址可能会发生变化，比如DHCP，所以需要使用MAC地址，出厂就写好在网卡的ROM里面</p></blockquote><p>为了提高效率， ARP同样也有缓存，在需要填写mac地址时，先使用接收方的IP地址去查ARP的缓存，如果有，直接取出，没有再广播询问</p><p>可以使用<code>arp -a</code>来查询arp缓存</p><h4 id="网卡">网卡</h4><p>工作在网络接口层 （数据链路层 + 物理层）</p><p>网卡驱动程序 前面<font color='blue'> 经过重重封装之后的数据包</font> 复制到自己的缓冲区，然后<font color='red'>加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</font>FCS</p><p>然后网卡驱动程序 驱动物理硬件 将数据转换成01信号发送出去</p><h4 id="交换机-二层网络设备">交换机 二层网络设备</h4><p>工作在数据链路层（MAC）</p><p>数据包到达交换机的网口，电信号-&gt;01信号，恢复出原来的数据，通过头部的分界符提取出一条信息 + 尾部的FCS作校验</p><p>然后将数据放入自己的缓冲区 ，这部分与计算机网卡一致，<font color='blue'>区别在于交换机的端口不具有MAC地址</font>, 交换机有多个端口， 内部维护一张 <font color='blue'>MAC地址 与 端口的 映射表</font></p><p>查询接收方的MAC地址对应的端口 ，然后转发给对应的端口</p><blockquote><p>如果映射表没有保存某个MAC地址对应的端口映射关系怎么办？ <mark> 每个端口都发 </mark></p></blockquote><p>如果接收方的MAC地址是一个广播地址，交换机 <font color='blue'>也会把包发送到所有端口</font></p><ul><li>MAC地址中的 FF:FF:FF:FF:FF:FF</li><li>IP地址的255.255.255.255</li></ul><h4 id="路由器-三层网络设备">路由器 三层网络设备</h4><p>工作在网络层 有IP地址和MAC地址</p><p>数据包到了交换机之后，如果是发给局域网内部的，就由交换机发给局域网内部的端口，如果是发给局域网之外的， 就转发给路由器</p><p>同样的，路由器将电信号-&gt;数字信号，根据分界符区分消息，FCS校验数据，解析MAC头部，是发给自己的则加入自己的缓冲区，否则丢弃</p><p><mark>然后去掉MAC头部</mark> ,解析IP头部得到IP地址，查路由表，得到吓一跳的信息，重新构建MAC帧头帧尾巴，再次封装，继续往下一跳发送，与前面计算机路由表一样<a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%B7%AF%E7%94%B1">点击这里回顾</a>，同样是选择符合的IP地址的网卡（的MAC）地址发送出去，如果没有对应的路由，选择默认的路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.120.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth1</span><br><span class="line">10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth2</span><br><span class="line">0.0.0.0         192.168.120.240 0.0.0.0         UG    0      0        0 eth3</span><br></pre></td></tr></table></figure><p>有两种情况：</p><ol><li>符合的那一行的 Gateway 是一个IP，说明还需要继续转发，并且下一跳的IP地址就是这个网关</li></ol><p>​因此，路由器此时要做的事情是，去ARP缓存查这个IP的MAC地址，如果ARP缓存没有，则广播…, 然后封装MAC帧，继续转发，<mark>注意：路由器是不会动IP包的，只是查看IP的目的地址</mark></p><ol start="2"><li>符合的那一行的GateWay 是一个空的，说明这个时候这个路由器已经是最接近目的地的一个路由器了，是<font color='blue'>最后一站了</font>,于是 路由器 会去ARP缓存<mark>查IP包中目的地址IP的MAC地址</mark>，如果ARP缓存没有，则广播…, 然后封装MAC帧，往下一跳转发（下一跳可能是一个交换机，也可能是就是目的计算机本身）</li></ol><p><font color='blue'><strong>在数据包转发的过程中，交换机，路由器，都不会动IP包里面的数据，动的只是MAC帧，在不断的改变下一跳的MAC地址，不断地转发从而到达目的地</strong></font></p><blockquote><p>转发的过程中，源IP地址和目的IP地址是不会改变的，前提是<mark>没有使用NAT （Network Address Translation）</mark></p></blockquote><h2 id="tcp">TCP</h2><h3 id="首部格式">首部格式</h3><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240817144558.png" alt=""></p><p><code>序列号</code> - 乱序问题</p><p><code>确认应答号</code> ACK- 丢包问题</p><p><code>首部长度</code> 因为选项字段的存在，所以TCP头部的长度可能是变长的，所以需要这个字段来区分数据部的长度</p><blockquote><p>TCP数据的长度 = IP总长度 - IP 首部 - TCP首部</p></blockquote><p><font color='blue'>面向连接的 可靠的 基于字节流的传输层通信协议</font></p><p>和UDP的区别</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td></td><td>面向连接的</td><td>无连接的</td></tr><tr><td></td><td>一对一的两点服务</td><td>一对一，一对多，多对多</td></tr><tr><td>可靠性</td><td>可靠的数据传输</td><td>尽最大努力的交付，不保证可靠交互</td></tr><tr><td>首部开销</td><td>开销较大，没有选项字段是20个字节</td><td>固定的8字节</td></tr><tr><td>传输效率</td><td>有流量控制（双方）和拥塞控制（网络），效率较低</td><td>没有这两个，即使网络拥堵了，UDP照样发</td></tr><tr><td>传输方式</td><td>流式传输，没有边界，容易粘包</td><td>一个包一个包发送，有边界，</td></tr><tr><td>分片不同</td><td>在传输层如果数据包大于MSS，会进行分段，然后再给到网络层</td><td>不分段，直接甩给网络层，IP层发现大雨1500字节，会自己分段</td></tr><tr><td>应用场景</td><td>FTP文件传输，HTTP/HTTPS</td><td>DNS，视频/音频通话，广播通信</td></tr></tbody></table><h3 id="三次握手过程">三次握手过程</h3><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240817165911.png" alt=""></p><ol><li>SYN置1</li><li>SYN-ACK SYN置1 ACK置1</li><li>ACK 置1</li></ol><p>TCP是保证可靠性和流量控制的某些状态信息的组合，包括socket（IP+port） 序列号 和窗口大小</p><p><mark> 第三次握手就已经可以携带数据了，前两次是不可以的</mark></p><p>在linux系统中查看TCP状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt</span><br></pre></td></tr></table></figure><h3 id="为什么是三次？不是两次-？四次？">为什么是三次？不是两次 ？四次？</h3><p>三次才能保证双方具有接收和发送的能力，才能阻止重复历史连接的初始化，才可以同步双方的初始序列号，避免资源浪费</p><blockquote><p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion. —RFC 793</p></blockquote><p>两次无法避免历史连接初始化当前的连接的问题</p><p>而四次就有点冗余了</p><h4 id="同步双方序列号">同步双方序列号</h4><p>第一个包seq包发送出去要得到服务器的回应才知道 同步了客户端的seq</p><p>第二个包要得到客户端的回应才知道 同步了服务器的seq</p><p>所以是三次</p><h4 id="避免资源浪费">避免资源浪费</h4><p>如果只有两次握手，服务端每次收到一个SYN都得预先分配资源，<font color='blue'> 因为服务器没办法知道客户端是否收到了自己回复的ACK报文</font></p><p>如果客户端发送的SYN阻塞了，从而导致多个SYN到达服务器端，就会出现服务器建立多个连接，浪费资源</p><p>什么是同步和异步？</p><h3 id="三次握手问题汇总">三次握手问题汇总</h3><h4 id="为什么序列号要随机初始化？">为什么序列号要随机初始化？</h4><p>防止上一条连接的消息发到这一条连接的接收窗口里面来</p><p>如果每次初始化都是从固定的序号开始的话就会出现这个问题</p><h4 id="起始序列号如何计算出来的？">起始序列号如何计算出来的？</h4><p>ISN = C+ hash(localIP,localPort,remoteIP,remotePort)</p><p>C是一个计时器的计数值， 每4us + 1</p><h4 id="为什么tcp层还需要mss？">为什么TCP层还需要MSS？</h4><p>保证重传的效率</p><h4 id="第一次握手丢失-发生了什么？">第一次握手丢失，发生了什么？</h4><p>客户端 重传SYN，<mark>而且序列号也是一样的 </mark>，超时重传</p><p>由内核参数 <code>tcp_syn_retries</code>控制 默认是5次重传机会</p><p>第一次重传在1s之后，第二次在2s之后，第三次在4s之后，每次超时的判断时间翻倍，当第五次重传结束之后，等待32s还没有回应，就不再发送SYN包，断开TCP连接</p><p>耗时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>16</mn><mo>+</mo><mn>32</mn><mo>=</mo><mn>63</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">1+2+4+8+16+32 = 63s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">3</span><span class="mord mathdefault">s</span></span></span></span></p><h4 id="第二次握手丢了-会发送什么？">第二次握手丢了，会发送什么？</h4><p>原则是不会重传ACK，所以还是客户端重传SYN，但是第二条报文是也是SYN报文，还是会重传SYN-ACK报文</p><p>由内核参数<code>tcp_synack_retries</code>控制 默认是 5，</p><p>也就是两边都会重传，<font color='blue'>双向奔赴了属于是</font></p><h4 id="第三次握手丢了-会发生什么？">第三次握手丢了，会发生什么？</h4><p>服务器重传SYN-ACK报文</p><h3 id="什么是syn攻击？">什么是SYN攻击？</h3><h4 id="前置知识">前置知识</h4><p>Linux内核会为TCP握手维护两个队列，<font color='blue'>半连接队列 SYN队列，和全连接队列 accpet 队列</font></p><p>收到SYN报文之后，服务器就会处于SYN-RCVD状态，创建一个半连接对象，加入到SYN队列，发送SYN-ACK报文，收到第三次握手ACK之后，就会将半连接对象移除，在accpt创建一个新的连接对象</p><p>应用通过<code>accept()</code>函数，来从accept取出连接对象</p><p><strong>既然是队列，就会有长度</strong>，当队列被塞满了，就会丢弃后续收到的报文</p><p>所以</p><h4 id="syn攻击是什么？">SYN攻击是什么？</h4><p>就是通过伪造不同的IP + PORT 发送SYN报文，填满服务器的半连接队列，从而让服务器无法响应正常的连接</p><h4 id="应对">应对</h4><h5 id="增大tcp半连接队列">增大TCP半连接队列</h5><p>指标不治本</p><h5 id="减少syn-ack重传次数">减少SYN-ACK重传次数</h5><p>通过减少无用的半连接对象在队列里面呆的时间，指标不治本</p><h5 id="调大netdev-max-backlog">调大netdev_max_backlog</h5><p>调大网卡的暂存队列，等于将压力分散给网卡，祸水东引:smiling_imp::smiling_imp::smiling_imp:</p><h5 id="开启tcp-syncookies">开启tcp_syncookies</h5><p>开启这个功能可以在不使用SYN半连接队列的情况建立连接</p><ol><li>当半连接队列满了，后续的SYN包不会丢弃，而是根据算法计算出一个<code>cookie</code>值</li><li>将<code>cookie</code>放到第二次握手报文的序列号里面</li><li>服务器端接收到客户端的应答报文，根据cookie值检查ACK报文的合法性，如果是合法的，就直接新建一个连接放到accept队列，相当于绕过了SYN队列</li></ol><p><code>net.ipv4.tcp_syncookies</code>0 关闭 1 SYN队列满员在启用 2无条件开启</p><h3 id="滑动窗口和流量控制">滑动窗口和流量控制</h3><h4 id="滑动窗口">滑动窗口</h4><p>发送方维护一个发送窗口，接收方维护一个接收窗口，结合累计确认ACK的方式来流量控制</p><p>接收方会回复自己可用的窗口大小给接收方，以便接收方来控制接下来发送的数据，发送方的窗口大小 = min(cwnd，接收方的窗口大小)；</p><blockquote><p>问题</p><p>如果接收方回复一个ACK，附带通知窗口为0, <mark>窗口关闭</mark> 也即当前接收端繁忙，暂停接受数据，然后处理完当前的数据之后， 回复ACK，再更新窗口window = 100； 这个时候这个ACK丢失了，会发生什么？</p><p><mark> 因为ACK是不会重传的，所以这个时候，接收端在等对面的数据，而发送方在等对面的窗口恢复通知，死锁了</mark></p></blockquote><p>解决办法，在接收到0 窗口ACK报文的时候，发送端启动一个计时器，定时发送一个<strong>窗口探测报文（Window probe）</strong>，以此来打破死锁</p><h5 id="糊涂窗口综合症">糊涂窗口综合症</h5><p>如果接收方太忙了，来不及处理数据，就会导致接收方窗口越来越小，最后导致接收方一有甚至一个字节的空虚，发送方都会选择发送这一个字节的数据，那么，就会导致<font color='blue'>发送这个数据的开销特别大，（各种协议的头部开销20字节+）</font></p><p>出现问题的原因是</p><ul><li>接收方会通告小窗口</li><li>发送方会发送小数据</li></ul><p>所以解决方法</p><ul><li>接收方 如果发现窗口值小于某个值，就直接返回0，窗口直接关闭了</li><li>发送方 使用Nagle算法，累计小数据到达一定的规模发送</li></ul><h3 id="拥塞控制">拥塞控制</h3><p>流量控制是用于  控制发送方和 接受方直接的数据控制</p><p>快重传 在接到 同一个 seq的ACK三次之后，就不会等待超时计时器到达，而是直接重传，提高效率</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240927000620.png" alt=""></p><h4 id="慢开始">慢开始</h4><p>每次收到一个包，设置拥塞窗口<code>cwnd</code>指数增长，直到到达慢开始门限<code>ssthresh</code></p><h4 id="拥塞避免">拥塞避免</h4><p>到达慢开始门限之后，开始执行拥塞避免算法，线性增大拥塞窗口</p><h4 id="拥塞发生">拥塞发生</h4><p>什么时候判断为拥塞？丢包 ，发生了超时重传，就认为网络发生了拥塞</p><p>这个时候执行的操作是</p><ul><li><code>ssthresh</code> 设置为当前 <code>cwnd/2</code></li><li>cwnd重置为初始值（1，也可能是其他值）</li></ul><h4 id="快速恢复">快速恢复</h4><p>为了防止上述重新慢启动的算法带来的速率瞬时下降的问题，引入了快重传 快恢复</p><p>快重传，当接收方发现丢失了一个中间数据包的时候，发送三次前一个包的ACK，于是发送端就会快速重传，不必等待超时器计数到达，</p><p>TCP会认为这种情况网络没有发生拥塞，因为发生拥塞了，不会收到三个ACK</p><p>于是这个时候执行的算法是</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">cwnd = cwnd / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ssthresh = cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span></li></ul><p>也就是<code>ssthresh</code>设置为当前的一半，然后从这个地方开始拥塞避免算法， 线性增长</p><h3 id="半连接队列？-一次tcp连接到发包的全过程">半连接队列？ 一次TCP连接到发包的全过程</h3><h4 id="建立连接">建立连接</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240925234722.png" alt=""></p><p>服务端在<code>socket() -&gt; bind() -&gt; listen()</code> 之后会在内核维护两个队列，一个是半连接队列syn queue， 和全连接队列accpet queue，</p><h5 id="syn-queue半连接队列">syn queue半连接队列</h5><p>在服务器收到SYN报文之后，服务器的状态变成<code>SYN_RCVD</code>，此时会将这个连接的信息放到半连接队列，</p><p>服务器回复SYN+ACK，然后为这个连接开启一个定时器，超时未收到就会触发重传，重传次数由<code>tcp_synack_retries</code>决定</p><blockquote><p>syn floods 攻击就是通过伪造大量的SYN报文，打满服务器的syn队列，从而使得正常的连接无法建立</p><p>解决- syn-cookie</p><p><font color='blue'>面试题：为什么有的时候客户端connect连接不上？？？</font></p><p>1、服务端没有listen</p><p>2、服务端死锁出问题了</p><p>3、syn queue 或者 accept被打满了，可以调大参数</p></blockquote><h5 id="accept-queue-全连接队列">accept queue 全连接队列</h5><p>包含了服务端所有完成三次握手，但是还没有被应用调用accept取走的连接队列，</p><p>此时的socket处于<code>ESTABLISHED</code>状态，每次accept会取走对头的一个元素，如果队列为空， accept会阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p><code>backlog</code>参数的作用就是设置全连接队列，但是不完全由这个决定，全连接队列的大小取决于<code>min(backlog, somaxconn)</code>, <code>somaxconn</code>是一个os级别的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -lnt | grep :9000 查看全连接队列的大小和等待accept 的连接个数</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240926005254.png" alt=""></p><p>Recv-Q 表示accept 队列排队的连接个数(也就是还有这么多个连接等着应用程序调用accept），Send-Q表示全连接队列 的总大小</p><p>在不同状态的时候 Recv-Q 和 Send-Q的含义不一样</p><p>如果是<font color='blue'>LISTEN状态 Recv-Q就是等待accpet的连接 Send-Q就是全连接队列的总大小</font></p><p><font color ='red'>其他状态则是 Recv-Q Send-Q 表示该连接在内核空间中当前读缓冲区和写缓冲区的直接大小。</font></p><h4 id="发包-收包">发包 收包</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240926160420.png" alt=""></p><p>1️⃣网卡接收数据包到网卡缓冲区</p><p>2️⃣网卡通过DMA 将数据拷贝到内核中的<code>RingBugffer</code>, (作为缓冲区，缓解网卡速度大于CPU的问题)</p><p>3️⃣拷贝完成时候，网卡产生硬件中断irq，通知CPU/kernel有新的数据到达</p><p>4️⃣内核收到中断之后，唤醒<code>ksoftirq</code>内核线程来处理软中断</p><p>5️⃣<code>ksoftirq</code> 唤醒之后，调用网卡驱动在内核注册的NAPI poll接口，从RingBuffer提取数据包，生成skb（Socket Buffer）数据，用sk_buffer表示</p><p>6️⃣内核协议栈处理，IP层解析IP地址，查询路由表是否需要转发，否则上传，传输层负责内容校验…</p><p>7️⃣处理完之后，数据包放到socket接收缓冲区，应用程序随后利用系统调用从缓冲区读取数据，完成从数据接收</p><blockquote><p>skb 存放的是网络数据包，整个网络协议栈使用的其实都是这个skb，只不过head和tail在不同的层会追加或者去除</p><p>Ring Buffer 放的是sk_buff描述符， 也就是DMA实际写入的时候sk_buff的描述符</p></blockquote><h2 id="四次挥手">四次挥手</h2><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240817181120.png" alt=""></p><p><font color='blue'>主动关闭连接的才有 TIME_WAIT状态</font></p><p>当客户端使用<code>close</code>函数关闭连接，收到<code>ACK</code>报文之后，客户端就会处于<code>FIN_WAIT2</code>状态，在这个状态需要等待服务器发送<code>FIN</code>报文，</p><p>对于<code>close</code>函数关闭的连接，由于无法在发送和接收数据，所以<code>FIN_WAIT2</code>状态不可以持续太久，由<code>tcp_fin_timeout</code>控制了这个状态下连接的持续时长，默认是60s，也就是60s还没收到FIN报文，客户端（主动关闭方）的连接就会直接关闭</p><p>如果主动关闭方使用的是<code>shutdown</code>函数关闭连接，那么只关闭了发送方向，接收方向并没有关闭，也就是这个时候主动关闭方还可以接受数据</p><p>此时，如果主动关闭方一直没有收到第三次挥手，那么主动关闭方的连接将会一直处于<code>FIN_WAIT2</code>的状态</p><h3 id="丢失汇总">丢失汇总</h3><h4 id="第一次挥手丢失">第一次挥手丢失</h4><p>当客户端调用close函数之后，就会向服务端发送FIN报文，进入<code>FIN_WAIT_1</code>状态，第一次丢失了，重发第一次，重传次数由<code>tcp_orphan_retries</code>参数控制，如果超过这个次数，就直接进入<code>close</code></p><h4 id="第二次挥手丢失">第二次挥手丢失</h4><p>还是客户端重传第一次挥手的报文</p><h4 id="第三次挥手丢失">第三次挥手丢失</h4><p>重传第三次挥手，由参数<code>tcp_orphan_retries</code>控制</p><p>当服务器收到客户端的FIN报文之后，内核会自动回复ACK，同时连接处于CLOSE_WAIT状态，它表示等待应用进程调用close函数来关闭连接</p><p>调用了close函数，才会发送FIN报文，同时连接进入LAST_ACK状态，等待客户端返回ACK来确认连接关闭，收不到ACK 就会重传FIN，无论是因为FIN丢失导致的还是ACK丢失导致的，由参数<code>tcp_orphan_retries</code> 控制</p><h4 id="第四次挥手丢失">第四次挥手丢失</h4><p>在客户端收到第三次挥手的FIN之后，就会回复ACK，然后进入<code>TIME_WAIT</code>状态，</p><p>在linux系统，<code>TIME_WAIT</code>状态会持续2<code>MSL</code>(报文最大生存时间)，<mark>目的是为了给自己的ACK报文到达对面和丢失的情况下对面重传预留出时间</mark>,如果处于这个状态的时候又收到了FIN，那么就重置计时器</p><blockquote><p>linux 系统下2ML 默认是60s</p></blockquote><h3 id="time-wait相关">TIME_WAIT相关</h3><p><mark>主动关闭方才有TIME_WAIT状态</mark></p><h4 id="为什么需要有time-wait状态？">为什么需要有TIME_WAIT状态？</h4><h5 id="为了防止历史连接中的数据-被后面相同四元组的连接错误的接收">为了防止历史连接中的数据，被后面相同四元组的连接错误的接收</h5><p>2MSL刚好可以使得 当前连接的所有消息<mark> 消散于网络中</mark>，再出现的数据包一定是新的连接的数据包而不是旧的</p><h5 id="为了保证被动关闭连接的一方能够被正确的关闭">为了保证被动关闭连接的一方能够被正确的关闭</h5><p>也就是等待2MSL使得最后的<code>ACK</code>能被对端收到，即使<code>ACK</code>丢失了，2MSL也预留出了重发<code>FIN</code>到达的时间，也就是最终目的是保障<code>ACK</code>一定能被对方收到，从而使得对端正确关闭</p><h4 id="time-wait过多有什么危害？">TIME_WAIT过多有什么危害？</h4><p>占用系统资源，文件描述符，内存资源，cpu资源等等</p><p>占用端口资源</p><p>服务端 TIME_WAIT过多一般只会占用系统资源，因服务器一般只监听一个端口</p><h4 id="address-already-in-use">Address already in use???</h4><p>原因就是TIME_WAIT 要等待2MSL才会彻底释放端口</p><p>应对 ：</p><ol><li>打开net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps选项</li></ol><p>​可以复用处于TIME_WAIT的socket为新的连接所用</p><ol start="2"><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用SO_LINGER</li></ol><p>但是最好不要越过TIME_WAIT, 以免出现意料之外的问题</p><h4 id="服务器出现大量的time-wait状态">服务器出现大量的TIME_WAIT状态</h4><p>因为服务器自己主动断开了很多TCP连接</p><p>什么情况下服务器会主动断开？？？</p><ul><li>HTTP没有使用长链接 1.0 默认是关闭长链接的，也就是Connnection:close <font color='blue'>一般是服务器主动关闭</font></li><li>HTTP长连接超时 虽然是长链接，但是太久没发消息了，也会断开</li><li>HTTP长链接的请求数量到达上限 也就是这条连接 发送的请求数量太多了，可以在nginx中的<code>keepalive_requests</code>参数中设置，就会主动断开</li></ul><h3 id="服务器出现大量的close-wait状态？">服务器出现大量的close_wait状态？</h3><p>被动关闭方，</p><p>close_wait 就是 等待程序调用close 函数 所以 叫close_wait</p><p>TCP服务端的流程：</p><ol><li>创建服务器socker，bind绑定，listen监听</li><li>socket注册到epoll</li><li>epoll_wait等待连接到来，accpet获取已连接的socketfd</li><li>将已连接的socket注册到epoll</li><li>epoll_wait</li><li>关闭连接时候，调用close</li></ol><p><font color='blue'>一般是epoll没有监听这个socket 的事件，或者就没有监听这个socket 或者 close逻辑被跳过了</font></p><h4 id="tcp保活机制-心跳机制">TCP保活机制 心跳机制</h4><p>TCP连接上长时间没有消息发送，就会给对端发送一个探测报文，探测对方是不是已经宕机了。</p><p>默认是关闭的 setsockopt SO_KEEPALIVE</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@4fda3f4c76aa:/usr/local/include# sysctl -a | grep keepalive</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 75</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">net.ipv4.tcp_keepalive_time = 7200</span><br></pre></td></tr></table></figure><p>默认每隔7200s,(2h)发送一个空的报文段，探测对方是否在线</p><p>如果探测没有响应，延迟75s继续发包</p><p>总共探测9次 ，还没有响应就直接断开了 释放socketfd ——&gt;但是业务还有相关的资源需要释放</p><p>一方面2h太久了</p><p>另外一方面为了正确释放资源，在应用层也需要设计心跳机制探测对端是否在线，从而释放资源</p><p>而且，再来看一个场景，如果只靠TCP的保活机制，如果客户端业务层发送死锁，不能正常处理业务，但是TCP保活机制却一直告诉server 客户端在线，于是尝试给客户端发消息，但是却得不到客户端业务上的响应，这就有问题</p><p>所以综合这两点 还需要在业务层上实现心跳机制</p><h3 id="socket编程">Socket编程</h3><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240818131636.png" alt=""></p><p>客户端connect成功返回是在第二次握手之后，服务端accept返回是在第三次握手之后</p><h3 id="none"></h3><h2 id="负载均衡">负载均衡</h2><h4 id="普通哈希">普通哈希</h4><p>对客户端的IP+port 进行哈希 ，然后的得到的 值 对服务器集群的数量进行取模， 也就是hash(ip+port) % num, 即可得到由哪台服务器提供服务</p><p>问题：一旦要对 服务器集群进行扩容和缩容，就会出现原有的<strong>哈希映射失效，数据需要重新分配</strong>，在集群数量比较多的时候，这是非常繁琐麻烦的</p><h4 id="一致性哈希">一致性哈希</h4><p>Hash(ip+port) % 2^32 对固定的数字取模，而不是对服务器集群的数量取模，</p><p>两个步骤：1、 先对 集群服务器的每个节点（IP）做一次哈希，然后可以得到这个节点在<strong>哈希环</strong>上的位置</p><p>​    2、 客户端发起请求， 进行哈希，然后在哈希环上顺时针遇到的第一个节点就是提供服务的节点</p><p>问题：当需要缩容的时候，需要缩容的节点可能在哈希环上是很多客户端选择的节点，把这个服务器节点A从哈希环上去掉，就会发生 这个A顺时针往下的一个节点B突然接收到A所负责的这部分请求，从而导致B崩溃 <mark>本质原因是，节点在哈希上的分布可能是不均匀的</mark> ，这样在容灾和扩容的时候，容易产生雪崩式的连锁反应</p><p><font color=' blue'>一致性哈希的含义就是满足一致性原则，这样即使扩容缩容，数据还是能正常获取到，当服务器增加或者减少的时候，只会影响到附近的节点，而不会影响所有的节点</font></p><p>nginx没有虚拟节点的机制，但是可以通过模拟来实现</p><p>也就是nginx如果一台服务器宕机了，这台服务器所有的请求都会发到 这台服务器在哈希环顺时针的下一个位置</p><h4 id="虚拟节点">虚拟节点</h4><p>在哈希环上引入虚拟节点， A-01，A-02，A-03， B-01，B-02，B-03，C-01，C-02，C-03，遇到虚拟节点的就会去找虚拟节点对应的真实节点， 虚拟节点在哈希环上是均匀分布的</p><p>虚拟节点是均匀分布的，所以实际的物理机器处理的请求也是均衡的</p><p>当A服务器要下线的时候，A的虚拟节点承载的请求会被均衡分配到BC的虚拟节点，也就是分给不同的服务器处理而不是一致性哈希只给一台服务器处理，这样就<strong>分散了压力</strong>，分散压力主要看的是虚拟节点的映射关系</p><h2 id="ping和icmp协议">PING和ICMP协议</h2><p>ping是一个 TCP/IP工具， 常用于检测网络的联通情况和分析网络速度 根据域名得到服务器IP</p><p>ping是通过ICMP协议实现的</p><p>ICMP（Internet Control Messsage Protocal）用于TCP/IP网络中发送控制消息</p><p>是IP协议的一部分，但是从体系结构来讲，是位于IP层（网络层）之上，因为需要IP报文来完成任务</p><p>也就是当主机收到一个指明上层协议是ICMP的协议的IP数据报的时候，它会分解出数据报的内容给ICMP，就像分界数据报文的内容给TCP和UDP一样</p><p>ICMP的主要功能有两个</p><ul><li>确认<strong>IP包能否成功到达目标地址</strong></li><li>进行网络诊断 如 ping 和traceroute</li></ul><p>ICMP 在 IP报文的协议类型中是 1 TCP 是 6 UDP 是17</p>]]></content>
      
      
      
        <tags>
            
            <tag> 哈希环 </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> 路由器 </tag>
            
            <tag> 交换机 </tag>
            
            <tag> 一致性哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/08/08/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/08/08/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>图论</p><p>参考灵神！\灵神!/</p><h2 id="最短路算法-dijkstra">最短路算法 dijkstra</h2><p>给定一个图(<font color='blue'>有向图 无向图均可以</font>) <code>g[i][j]</code>表示 i 到 j 这条边的边权，如果没有这条边，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">g[i][j] = \infin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></p><p>定义<code>dis[i]</code> 表示起点<code>k</code>到节点<code>i</code>的最短路长度，<code>dis[k] = 0</code>, 其余<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">dis[i] = \infin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> 为还未计算</p><p><mark>目标计算出最终的dis数组</mark></p><ol><li><p>首先更新<font color='blue'>起点k到其邻居的最短路</font>，也即<code>dis[y] = g[k][y] </code></p></li><li><p>然后取除了起点k之外的<code>dis[i]</code>的最小值，假设最小值对应的节点是3，这时可以断言，<font color = 'blue'><code>dis[3]</code> 是 k 到 3 的最短路径</font>，反证法：如果还有比<code>dis[3]</code>更短的路径，则必定是k - &gt; u -&gt; …  -&gt; 3, 也就是</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>g</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mo>&gt;</mo><mi>g</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g[k][u] + ... +  g[u][3]  &lt; dis[3] =&gt; g[k][u] = d[u] &lt; dis[3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span></span></span></span></span></p><p>,<mark>（这一步的前提是没有负数边权）</mark> 则选最小值应该选的是u 而不是3，矛盾了，也就是原命题成立 <mark><code>dis[3]</code> 是 k 到 3 的最短路径</mark></p></li><li><p>用已经是最小值的<code>dis[3]</code>去更新3周围的距离，如果<code>dis[3] + g[3][y] &lt; dis[y]</code> 更新<code>dis[y] = dis[3] + g[3][y] </code>, 否则不更新</p></li><li><p>取除了3，k之外的<code>dis[i]</code>的最小值，重复2，3步骤，由数学归纳法知，这一做法可以得到 k 到任意一点的 最短路</p></li></ol><h3 id="朴素dijkstra-适用于稠密图">朴素Dijkstra 适用于稠密图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵 对称</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, INT32_MAX)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">done</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//init</span></span><br><span class="line">dis[k<span class="number">-1</span>] = <span class="number">0</span>; <span class="comment">// k 到 k 距离 0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(done[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span> || dis[i] &lt; dis[idx])&#123;</span><br><span class="line">      x = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(idx == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// -1表示全遍历完了</span></span><br><span class="line">  done[idx] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; n;y++) &#123;</span><br><span class="line">    dis[y] = <span class="built_in">min</span>(dis[y], dis[idx] + g[idx][y]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆优化dijkstra-适用于稀疏图">堆优化Dijkstra 适用于稀疏图</h3><p>寻找最小值使用最小堆来完成，插入元素后自动排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, INT32_MAX)</span></span>;</span><br><span class="line">dis[k<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; qp;</span><br><span class="line">pm.<span class="built_in">emplace</span>(k<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!qp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  <span class="keyword">auto</span> [idx, dx] = pq.<span class="built_in">top</span>();</span><br><span class="line">  pq.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="keyword">if</span>(dx &gt; dis[idx])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> y =<span class="number">0</span>; y &lt; n;y++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[idx][y] == INT32_MAX) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> new_dis = dx + g[idx][y];</span><br><span class="line">    <span class="keyword">if</span>(new_dis &lt; dis[y])&#123;</span><br><span class="line">      dis[y] = new_dis;</span><br><span class="line">      qp.<span class="built_in">emplace</span>(y, new_dis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么需要判断 <code>dx &gt; dis[idx]</code> ?</p><p>对于同一个x 例如先入堆一个比较大的dis[x] = 10; 后面又把dis[x]更新成5，之后这个5会先出堆，然后再把10出堆，<font color='blue'> 10出堆的时候没必要更新周围的最短路，因为5出堆的时候已经更新过了，10出堆不可能比5更新得更短</font></p><h3 id="并查集">并查集</h3><p><mark>关键词 查询一个元素是否在一个集合中，无向图…</mark></p><p>合并 查询 集合， 常用来解决连通性问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Djikstra </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++对象 性能优化</title>
      <link href="/2024/08/04/c++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2024/08/04/c++%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="c-对象的优化">c++ 对象的优化</h1><h2 id="test示例">Test示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> m_val;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> val): <span class="built_in">m_val</span>(val)&#123;&#125;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t):<span class="built_in">m_val</span>(t.m_val)&#123;&#125;  <span class="comment">//涉及到构造的使用的都是构造函数</span></span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">    m_vat = t.m_val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t = <span class="built_in">Test</span>(<span class="number">30</span>); <span class="comment">//用临时对象拷贝构造一个新对象的时候 c++会进行优化， 也就是不产生临时对象，使用产生临时对象的方式直接产生新对象</span></span><br></pre></td></tr></table></figure><h2 id="显隐式类型转换">显隐式类型转换</h2><h3 id="显式类型转化">显式类型转化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="built_in">Test</span>(<span class="number">30</span>);</span><br><span class="line">t = (Test)<span class="number">30</span>;</span><br></pre></td></tr></table></figure><h3 id="隐式类型转化">隐式类型转化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="number">30</span>; <span class="comment">// int -&gt; Test</span></span><br></pre></td></tr></table></figure><h2 id="临时对象作为返回值的注意事项">临时对象作为返回值的注意事项</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test *p = &amp;<span class="built_in">Test</span>(<span class="number">10</span>); <span class="comment">//过了这条语句，临时对象被析构，指针变为野指针，</span></span><br><span class="line"><span class="comment">// 所以指针指向临时对象（匿名对象）是不安全的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Test &amp;p = <span class="built_in">Test</span>(<span class="number">10</span>)； <span class="comment">//过了这条语句，临时对象并不会被析构，因为引用实际上是别名，也就是临时对象（匿名对象）变成了有名对象</span></span><br><span class="line">  <span class="comment">// 所以可以使用 引用来管理 临时对象</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="构造顺序">构造顺序</h2><p>全局变量首先构造，静态变量在第一次遇到的时候构造</p><p>析构 静态 倒数第二析构 全局 最后析构 这俩在数据段上，在程序运行结束的时候析构</p><h2 id="逗号表达式">逗号表达式</h2><p>逗号表达式（1，2，3，4，5，…, n）=  n</p><blockquote><p>使用逗号运算符是为了把几个表达式放在一起。</p><p>整个逗号表达式的值为系列中最后一个表达式的值。</p><p>从本质上讲，逗号的作用是将一系列运算按顺序执行。</p></blockquote><h2 id="实参-形参">实参 -&gt; 形参</h2><p>函数调用 实参 -》 形参 是初始化 ？ 还是赋值？</p><p>答案：<font color='blue'>初始化</font>, 赋值是要两个对象都存在才能赋值</p><h2 id="对象调用例子">对象调用例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test <span class="title">GetObject</span><span class="params">(Test t)</span> <span class="comment">// 不能返回局部的或者临时对照的指针或引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">  <span class="function">Test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Test t1;</span><br><span class="line">  Test t2;</span><br><span class="line">  t2 = <span class="built_in">GetObjecet</span>(t1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test <span class="built_in">GetObject</span>(Test &amp;t)&#123;</span><br><span class="line">  <span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">  <span class="comment">// Test tmp(val);</span></span><br><span class="line">  <span class="comment">// return 0;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Test</span>(val); <span class="comment">//构造一个临时对象</span></span><br><span class="line">&#125;<span class="comment">// 临时对象需要在main 栈帧上构造一个新的对象</span></span><br><span class="line"><span class="comment">// 触发关键词 ， 用临时对象拷贝构造一个新对象 ，c++ 优化</span></span><br><span class="line"><span class="comment">// 不构造临时对象，直接构造 新的对象</span></span><br><span class="line"><span class="comment">// 也就是直接在 main函数的栈帧上 调用 Test(int)</span></span><br><span class="line"><span class="comment">// 这样又少了两个 函数的构造 tmp的 构造和析构</span></span><br></pre></td></tr></table></figure><p>函数调用过程</p><ol><li>line 9 Test(int)</li><li>Line 10 Test(int)</li><li>Line 11 line 1 实参 形参 Test(const Test &amp;) 拷贝构造初始化 不是赋值</li><li>line 4 Test(int)</li><li>line 5 局部变量在 main函数的栈帧上 Test(const Test &amp;) 构造一个临时对象</li><li>line 6 tmp 析构</li><li>line 6 形参 t 析构</li><li>line 11 赋值操作</li><li>line12  上一行的匿名对象（临时对象） 析构</li><li>Line13 t2 析构</li><li>Line13 t1析构</li></ol><h2 id="对象优化-总结">对象优化 总结</h2><ol><li><p>函数参数传递过程中，对象优先按引用传递，不要值传递 -&gt; 优化结果：<font color = 'blue'> 函数的形参 构造 和 析构被优化掉 -2</font></p></li><li><p>函数返回对象的时候，应该优先返回一个临时对象，而不是返回一个已经定义过的对象。 优化结果：<font color = 'blue'> 函数已经定义过的 构造 和 析构被优化掉 -  2</font></p></li><li><p>对象的定义和初始化尽量放在一起做！接受返回值是对象的函数调用的时候，优先按照初始化的方式接受，不要按赋值的方式接收</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test t2;</span><br><span class="line">t2 = <span class="built_in">GetObject</span>(t1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test t2 = <span class="built_in">GetObject</span>(t1); <span class="comment">//触发关键词 ，用临时对象拷贝构造一个新的对象， c++ 优化，直接构造新的对象</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="右值引用">右值引用</h2><h4 id="左值">左值</h4><p>左值 有内存 或 有名字</p><p>右值 无名字 或 无内存 临时量</p><p>左值引用 绑定 左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">20</span>; <span class="comment">//错误 无法将右值绑定在左指引用上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">20</span>; <span class="comment">// 可以</span></span><br><span class="line"><span class="comment">/* --&gt;</span></span><br><span class="line"><span class="comment">int tmp = 20;</span></span><br><span class="line"><span class="comment">const int &amp;c = tmp; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;d = <span class="number">20</span>; <span class="comment">//可以</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int tmp = 20;</span></span><br><span class="line"><span class="comment">int &amp;&amp;d = tmp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//也就是4 和 10 的底层都是一样的，都是使用临时量先保存，再赋值，</span></span><br><span class="line"><span class="comment">// 但是 4 不能改临时量的值</span></span><br><span class="line"><span class="comment">// 10 可以改</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;d = b; <span class="comment">// 错误 无法将左指绑定在右值引用上</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;d = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;f = d;<span class="comment">// 错误 一个右值引用本身是一个左值，不能被右值引用绑定</span></span><br></pre></td></tr></table></figure><h4 id="例子">例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">CMystring</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CMystring</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      mptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">strcpy</span>(mptr, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      mptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">      *mptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">CMystring</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(mptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span>[] mptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">CMystring</span>(<span class="type">const</span> CMystring&amp; str)&#123;</span><br><span class="line">    mptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.mptr) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(mptr, str.mptr);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> CMystring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CMystring &amp;str)&#123; <span class="comment">//赋值运算符重载</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;src)&#123;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">delete</span>[] mptr;</span><br><span class="line">   mptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.mptr) + <span class="number">1</span>];</span><br><span class="line">   <span class="built_in">strcpy</span>(mptr, str.mptr);</span><br><span class="line">   <span class="keyword">return</span> * <span class="keyword">this</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* <span class="built_in">c_str</span>() <span class="type">const</span> &#123;<span class="keyword">return</span> mptr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* mptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CMystring <span class="title">getString</span><span class="params">(CMystring &amp;str)</span></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">  <span class="function">CMystring <span class="title">tmp</span><span class="params">(str)</span></span>; <span class="comment">//如果字符串很长，在这里就需要在构造函数疯狂复制</span></span><br><span class="line">  <span class="keyword">return</span> tmp; <span class="comment">//然后有需要复制完了， tmp 又直接被丢弃了</span></span><br><span class="line">  <span class="comment">//有没有方法可以直接将tmp 的内存 直接 移动给 新的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">CMystring <span class="title">str1</span><span class="params">(<span class="string">&quot;111111111111111&quot;</span>)</span></span>;</span><br><span class="line">  CMystring str2;</span><br><span class="line">  str2 = <span class="built_in">getString</span>(str1);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右值引用">右值引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMystring</span>(CMystring &amp;&amp;str)&#123; <span class="comment">//右值引用构造，如果传入的值是一个临时变量，编译器就会调用这个构造函数</span></span><br><span class="line">  m_ptr = str.mptr;</span><br><span class="line">  str.mptr = <span class="literal">nullptr</span>; <span class="comment">// 直接将这部分的堆区指针移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMystring&amp; <span class="keyword">operator</span>=(CMystring &amp;&amp;str)&#123;</span><br><span class="line">  <span class="comment">// 右值引用参数的赋值重载函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span>[] mptr; <span class="comment">//赋值 两个对象都存在，需要先把本对象的资源先释放</span></span><br><span class="line">  </span><br><span class="line">  mptr = str.mptr;</span><br><span class="line">  str.mpter = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 就实现了临时对象的资源转移，提高了效率</p><h4 id="额外加入一个-的重载">额外加入一个 + 的重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CMystring <span class="keyword">operator</span>+(<span class="type">const</span> CMystring &amp;lhs, <span class="type">const</span> CMystring &amp;rhs)&#123;</span><br><span class="line">  <span class="type">char</span> *ptmp = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lhs.mptr) + <span class="built_in">strlen</span>(rhs.mptr) + <span class="number">1</span>]; <span class="comment">// 这里的new 没有delete 会泄漏, 每次执行+都会泄漏一次</span></span><br><span class="line">  <span class="built_in">strcpy</span>(ptmp, lhs.mptr);</span><br><span class="line">  <span class="built_in">strcat</span>(ptmp, rhs.mptr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CMystring</span>(ptmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//改进 </span></span><br><span class="line"><span class="comment">// 所以不能返回临时变量了，只能返回局部对象</span></span><br><span class="line">CMystring <span class="keyword">operator</span>+(<span class="type">const</span> CMystring &amp;lhs, <span class="type">const</span> CMystring &amp;rhs)&#123;</span><br><span class="line">  <span class="type">char</span> *ptmp = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lhs.mptr) + <span class="built_in">strlen</span>(rhs.mptr) + <span class="number">1</span>]; </span><br><span class="line">  <span class="built_in">strcpy</span>(ptmp, lhs.mptr);</span><br><span class="line">  <span class="built_in">strcat</span>(ptmp, rhs.mptr);</span><br><span class="line">  <span class="function">CMystring <span class="title">tmpstr</span><span class="params">(ptmp)</span></span>;</span><br><span class="line">  <span class="keyword">delete</span>[] ptmp;</span><br><span class="line">  <span class="keyword">return</span> tmpStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次改进， 上述还是有多余的拷贝</span></span><br><span class="line">CMystring <span class="keyword">operator</span>+(<span class="type">const</span> CMystring &amp;lhs, <span class="type">const</span> CMystring &amp;rhs)&#123;</span><br><span class="line">  CMystring tmpStr;</span><br><span class="line">  tmpStr.mptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lhs.mptr) + <span class="built_in">strlen</span>(rhs.mptr) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(ptmp, lhs.mptr);</span><br><span class="line">  <span class="built_in">strcat</span>(ptmp, rhs.mptr);</span><br><span class="line">  <span class="keyword">return</span> tmpStr; <span class="comment">//这一步会调用右值拷贝构造函数，从而提高效率，tmpStr 会被编译器认为是临时对象</span></span><br><span class="line">  <span class="comment">//这里 直接34 行优化了一次拷贝，直接把tmp Str的资源给了 34 行的str3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  CMystring str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  CMystring str2 = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  CMystring str3 = str1 + str2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器相关">容器相关</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  CMystring str1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  vector&lt;CMystring&gt; vec;</span><br><span class="line">  vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  vec.<span class="built_in">push_back</span>(str1); <span class="comment">//普通拷贝构造</span></span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="built_in">CMystring</span>(<span class="string">&quot;bbbb&quot;</span>)); </span><br><span class="line">  <span class="comment">// “bbbb” -&gt;CMystring 普通构造</span></span><br><span class="line">  <span class="comment">// 临时对象右值拷贝构造s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="move-forward">move forward</h4><p>右值引用本身是一个 左值</p><p>如果参数是一个右值引用，要继续往里面传， 就可能需要把<font color='blue'>右值引用 </font> (左值) 转换成右值 继续往里面传</p><p><strong>move 左值 强制转换成 右值</strong> 得到右值类型</p><blockquote><p>底层实现其实就是一个强制类型转换</p></blockquote><h4 id="引用折叠">引用折叠</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Ty &amp;&amp;val)</span></span>&#123;<span class="comment">// 类型推导</span></span><br><span class="line">  <span class="comment">// A CMystring&amp;  = Ty &amp;&amp;val; =&gt; Ty = CMysting&amp; , CMystring&amp; + &amp;&amp; val = CMystring&amp; val 引用折叠</span></span><br><span class="line">  <span class="comment">// B CMystring&amp;&amp; = Ty &amp;&amp;val =&gt; Ty = CMystring&amp;&amp;, CMystring&amp;&amp; + &amp;&amp; val = CMystring&amp;&amp; val 引用折叠</span></span><br><span class="line">  <span class="comment">// 所以 模版类型推导 + 引用折叠=&gt; 左值还是左值，右值还是右值，两者的写法就合并了</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">  </span><br><span class="line">  _allocator.<span class="built_in">construct</span>(_last, val);<span class="comment">// 但是这个的val始终是左值，如何进一步匹配？</span></span><br><span class="line">  <span class="comment">// _allocator.construct(_last, std::forward&lt;Ty&gt;(val);</span></span><br><span class="line">  </span><br><span class="line">  _last++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">CMystring <span class="title">str1</span><span class="params">(<span class="string">&quot;aaaa&quot;</span>)</span></span>;</span><br><span class="line">  vec.<span class="built_in">push_back</span>(str1); <span class="comment">// CMystring&amp; A</span></span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="built_in">CMystring</span>(<span class="string">&#x27;bbbb&#x27;</span>)); <span class="comment">//CMystring&amp;&amp; B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forward">forward</h4><p>类型的完美转发，能够识别左值和右值</p><p>上面代码的9行就是使用forward ，然后往里调用的时候，就会判断val到底是左值还是右值 ，从而调用不同版本的construct函数，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Ty &amp;&amp;val)</span></span>&#123;<span class="comment">// 类型推导</span></span><br><span class="line">  <span class="comment">// A CMystring&amp;  = Ty &amp;&amp;val; =&gt; Ty = CMysting&amp; , CMystring&amp; + &amp;&amp; val = CMystring&amp; val 引用折叠</span></span><br><span class="line">  <span class="comment">// B CMystring&amp;&amp; = Ty &amp;&amp;val =&gt; Ty = CMystring&amp;&amp;, CMystring&amp;&amp; + &amp;&amp; val = CMystring&amp;&amp; val 引用折叠</span></span><br><span class="line">  <span class="comment">// 所以 模版类型推导 + 引用折叠=&gt; 左值还是左值，右值还是右值，两者的写法就合并了</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">    <span class="built_in">expand</span>();</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">  _allocator.<span class="built_in">construct</span>(_last, std::forward&lt;Ty&gt;(val);</span><br><span class="line">  </span><br><span class="line">  _last++;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">construct</span>(T* p, Ty &amp;&amp;val)&#123;</span><br><span class="line">  <span class="built_in">new</span> (p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val));</span><br><span class="line">&#125;</span><br><span class="line">                       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">  CMystring <span class="built_in">str1</span>(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">  vec.<span class="built_in">push_back</span>(str1); <span class="comment">// CMystring&amp; A</span></span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="built_in">CMystring</span>(<span class="string">&#x27;bbbb&#x27;</span>)); <span class="comment">//CMystring&amp;&amp; B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="智能指针">智能指针</h1><p>裸指针因为 程序员设计的原因，还是可能会发生资源泄漏</p><p>-&gt; 智能指针 保证能做到资源的自动释放</p><p><font color = 'blue'>利用栈上的对象出作用域自动析构的特点，来做到资源的自动释放</font></p><p>CSmartPtr<int> *p = new CSmartPtr<int>  (new int); delete p;</p><p>这里的p实际上还是裸指针</p><h2 id="智能指针的实现">智能指针的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>):<span class="built_in">mptr</span>(ptr) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">CSmartPtr</span>() &#123;<span class="keyword">delete</span> mptr;&#125;</span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *mptr;&#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> mptr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T *mptr;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="comment">//无论是发生异常还是正常执行，析构函数都会自动释放资源</span></span><br><span class="line">  *ptr1 = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Test&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">CSmartPtr&lt;Test&gt; <span class="title">cp</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">  cp-&gt;<span class="built_in">test</span>();</span><br><span class="line">  <span class="comment">// 指向操作符的解析</span></span><br><span class="line">  <span class="comment">//cp-&gt;test() ---- (cp-&gt;()).test();</span></span><br><span class="line">  <span class="comment">// 也就是-&gt;是不带参数的 ，他直接返回一个 指针，再去调用裸指针的-&gt;()方法；</span></span><br><span class="line">  <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// return -1;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="这个智能指针存在的问题">这个智能指针存在的问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">  <span class="comment">//这个智能指针 析构的时候会发生崩溃</span></span><br><span class="line">  <span class="comment">// 原因 浅拷贝</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 但是如果自己实现深拷贝 会给用户 使用带来疑惑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不带引用计数的智能指针如何解决浅拷贝问题带来的二次释放问题">不带引用计数的智能指针如何解决浅拷贝问题带来的二次释放问题</h2><h3 id="auto-ptr">auto_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">  <span class="comment">//这里的拷贝函数 为了防止浅拷贝问题</span></span><br><span class="line">  <span class="comment">//ptr2 拷贝构造的时候会实现资源的转移，</span></span><br><span class="line">  <span class="comment">//也就是执行完毕之后， ptr1变成空指针了</span></span><br><span class="line">  </span><br><span class="line">  *ptr2 = <span class="number">20</span>;</span><br><span class="line">  cout &lt;&lt; *ptr1 &lt;&lt; endl; <span class="comment">//报错</span></span><br><span class="line">  <span class="comment">//不推荐使用auto_ptr</span></span><br><span class="line">  <span class="comment">// 只适合在 在简单的 场景下使用</span></span><br><span class="line">  <span class="comment">// vector&lt;auto_ptr&lt;int&gt;&gt; vec1;</span></span><br><span class="line">  <span class="comment">// vector&lt;auto_ptr&lt;int&gt;&gt; vec2;</span></span><br><span class="line">  <span class="comment">// 不要这样用，🙅，非常危险，auto_ptr，结合容器，危险！⚠️</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scope-ptr">scope_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scoped_ptr</span>(<span class="type">const</span> scoped_ptr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">scoped_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> scoped_ptr&lt;T&gt; &amp;) = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>解决方法，直接不允许你拷贝构造了！！</p><p>用的也比较少</p><blockquote><p>编译器会报错，尝试引用已经删除的函数</p></blockquote><h3 id="unique-ptr">unique_ptr</h3><p>推荐使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&lt;T&gt; &amp;) = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是提供了右值拷贝构造和 赋值</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;T&gt; &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(unique_ptr&lt;T&gt; &amp;&amp;) = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样也删除了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;<span class="comment">// 这里用户使用的使用必须使用std::move 这样也就确保了用户知道这里会发生资源转移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而上面的 auto_ptr是没有任何提示的 </span></span><br><span class="line"><span class="comment">//auto_ptr&lt;int&gt; ptr1(new int);</span></span><br><span class="line"><span class="comment">// auto_ptr&lt;int&gt; ptr2(ptr1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_ptr&lt;int&gt; p1(new int);</span></span><br><span class="line"><span class="comment">unique_ptr&lt;int&gt; p2(p1); //这里会报错，因为这个方法被删除了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">getUniPtr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(getUniPtr())</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p3;</span><br><span class="line">p3 =  <span class="built_in">getUniPtr</span>();<span class="comment">// 正是由于右值拷贝构造的存在，这些方法都是才能对的</span></span><br></pre></td></tr></table></figure><h2 id="带引用计数的智能指针">带引用计数的智能指针</h2><p>特点 多个智能指针可以管理同一个资源</p><p>带引用计数 给每一个对象资源 匹配一个引用计数</p><p>智能指针 -&gt; 资源的时候 -&gt; 引用计数 + 1</p><p>智能指针 -&gt; 不使用资源的时候 -&gt; 引用计数 -1 -&gt; ==0 释放资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefCnt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RefCnt</span>(T *ptr = <span class="literal">nullptr</span>):<span class="built_in">mptr</span>(ptr)  &#123;</span><br><span class="line">    <span class="keyword">if</span> (mptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      mcount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addRef</span><span class="params">()</span> </span>&#123;mcount++;&#125; <span class="comment">// 增加资源的引用计数</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">delRef</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> --mcount;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *mptr;</span><br><span class="line">  <span class="type">int</span> mcount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 智能指针加入这个 类作为成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CSmartPtr</span>(T *ptr = <span class="literal">nullptr</span>):<span class="built_in">mptr</span>(ptr) &#123;</span><br><span class="line">  <span class="keyword">if</span>(mptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      mref = <span class="keyword">new</span> <span class="built_in">RefCnt</span>&lt;T&gt;(mptr);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">CSmartPtr</span>() &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="number">0</span> == mref-&gt;<span class="built_in">delRef</span>())&#123;</span><br><span class="line">        <span class="keyword">delete</span> mptr;</span><br><span class="line">      mptr = <span class="literal">nullptr</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CSmartPtr</span>(<span class="type">const</span> T&amp; ptr)&#123;</span><br><span class="line">    mptr = ptr;</span><br><span class="line">    mref = ptr.mref;</span><br><span class="line">    mref-&gt;<span class="built_in">addRef</span>(); <span class="comment">//增加引用计数</span></span><br><span class="line">  &#125;</span><br><span class="line">  CSmartPtr&amp; <span class="keyword">operator</span>=(CSmartPtr &amp;ptr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;ptr)&#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == mref-&gt;<span class="built_in">delRef</span>())&#123;</span><br><span class="line">      <span class="keyword">delete</span> mptr;</span><br><span class="line">      mptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mptr = ptr;</span><br><span class="line">    mref = ptr.mref;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *mptr;&#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> mptr;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *mptr;</span><br><span class="line">  RefCnt&lt;T&gt; *mref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    CSmartPtr&lt;<span class="type">int</span>&gt; ptr3 = ptr2;</span><br><span class="line"></span><br><span class="line">    *ptr1 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2 &quot;</span> &lt;&lt; *ptr2 &lt;&lt; <span class="string">&quot; ptr3 &quot;</span> &lt;&lt; *ptr3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述这个RefCnt类明显是不支持多线程操作的</p><h3 id="shared-ptr">shared_ptr</h3><p>强智能指针 可以改变资源的引用</p><p>循环引用，造成资源无法释放 ，资源泄漏</p><h4 id="规则">规则</h4><ul><li><p><font color='blue'>定义的时候使用强智能指针 (也就是最开始 定义资源的地方，使用shared)</font></p></li><li><p><font color='blue'>引用的时候使用使用弱智能指针</font></p></li></ul><h3 id="weak-ptr">weak_ptr</h3><p>弱智能指针 不会改变资源的引用</p><p>只是一个观察者，不能够使用资源，没有提供* -&gt; 的重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wptr;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sptr = wptr.<span class="built_in">lock</span>(); <span class="comment">// 使用lock方法提升强指针</span></span><br><span class="line"><span class="keyword">if</span>(sptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  sptr-&gt;<span class="built_in">test</span>(); <span class="comment">// 这个时候就可以调用资源， 而且这个时候被提升为强指针</span></span><br><span class="line">  <span class="comment">// 外部析构也无法影响到这里的执行。 安全！！🔐！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//否则就是提升失败了，就是资源已经被释放掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强弱指针关系">强弱指针关系</h3><p>weak_ptr 监视-&gt; shared_ptr监视 -&gt; 资源（内存）</p><h3 id="多线程访问共享对象的线程安全问题">多线程访问共享对象的线程安全问题</h3><p>多进程的时候如何判断共享对象仍然存活？？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler01</span><span class="params">(weak_ptr&lt;A&gt; pw)</span></span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::choro::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="comment">// 使用A对象的时候，必须先判断是否存活</span></span><br><span class="line">  shared_ptr&lt;A&gt; sp = pw.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">if</span>(sp != <span class="literal">nullptr</span>)&#123; <span class="comment">//存活才能调用</span></span><br><span class="line">    sp-&gt;<span class="built_in">testA</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A对象已经析构，无法访问， &quot;</span> &lt;&lt; endl; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(handler01, weak_Ptr&lt;A&gt; (p))</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::choro::<span class="built_in">seconds</span>(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>析构了资源还能访问吗？</p><p>delete 实际上只是把资源还给了操作系统，但是这部分的内存不会被抹除（除非操作系统立马把这部分内存分配给了其他地方） 也就是析构完了之后，资源还会存在一会，但是你不知道操作系统什么时候会分配给别人</p><p>所以delete之后再次使用时不安全的，所以delete之后 指针一般都要置为空，防止访问</p></blockquote><h2 id="智能指针的删除器-deletor">智能指针的删除器 deletor</h2><h3 id="为什么还要有删除器？">为什么还要有删除器？</h3><p>智能指针能够保证资源的绝对释放</p><p>默认的释放方式都是 delete</p><p>但是并不是 所有资源都是 delete， 比如数组 delete[]</p><p>文件资源 使用free 等等</p><p>所以需要定义删除器 来指导智能指针正确释放资源！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">unique_ptr</span>()&#123;</span><br><span class="line">  <span class="comment">// 智能指针的 析构函数 是一个函数对象的调用 </span></span><br><span class="line">  <span class="built_in">deletor</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 默认的函数对象 就是delete</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">default_delete</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法">用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mydeletor</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *ptr)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call Mydeletor.operator()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFiledeletor</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *ptr)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call MyFiledeletor.operator()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fclose</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>])</span></span>; <span class="comment">//这个时候无法正确释放资源</span></span><br><span class="line">  unique_ptr&lt;<span class="type">int</span>， Mydeletor&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ptr2</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]); <span class="comment">//这样才能正确释放资源！</span></span><br><span class="line">  </span><br><span class="line">  unique_ptr&lt;FILE, MyFiledeletor&lt;FILE&gt;&gt; <span class="built_in">fp</span>(<span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;w&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='blue'>为什么需要结合funcion来使用？？</font></p><p>deletor 只在智能指针定义的时候 用到了 不够优雅，deletor一多，就很麻烦</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// lambda 表达式 </span></span><br><span class="line">  unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span> (<span class="type">int</span> *)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>], </span><br><span class="line">                                              [](<span class="type">int</span> *p)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">                                                cout &lt;&lt; <span class="string">&quot;call lambda release array &quot;</span> &lt;&lt; endl;</span><br><span class="line">                                                <span class="keyword">delete</span>[] p;</span><br><span class="line">                                              &#125;);</span><br><span class="line">  unique_ptr&lt;FILE, function&lt;<span class="type">void</span> (FILE *)&gt;&gt; <span class="built_in">ptr1</span>(<span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;w&quot;</span>), </span><br><span class="line">                                              [](FILE *p)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">                                                cout &lt;&lt; <span class="string">&quot;call lambda release file&quot;</span> &lt;&lt; endl;</span><br><span class="line">                                                <span class="built_in">fclose</span>(p);</span><br><span class="line">                                              &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c-function">C++ function</h1><h2 id="lambda表达式的实现原理">lambda表达式的实现原理</h2><p>c++函数对象的升级版 -&gt; lambda表达式</p><h3 id="函数对象的缺点">函数对象的缺点</h3><p>使用在泛型算法参数传递 比较性质/自定义操作 优先级队列</p><p>函数对象都是在 类定义的时候用到过，后面就没用了，不优雅，非常臃肿，函数对象一多，起名字都是问题～</p><h3 id="lambda表达式的语法">lambda表达式的语法</h3><p>[捕获外部变量] (形参列表) -&gt;返回值 {函数实现};</p><p>如果返回值是void ，则可以不写</p><p>也就是直接[…] (…) {…}</p><p>[] 表示不捕获任何外部变量</p><p>[=] 表示以值传递的方式捕获外部所有变量</p><p>[&amp;] 表示以引用的方式</p><p>[this] 捕获外部this指针</p><p>[=, &amp;a] 以传值的方式捕获外部所有变量，但是a是引用的方式</p><p>[a,b] 以传值的方式捕获 a b</p><p>[a, &amp;b]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func1 = []()-&gt;<span class="type">void</span> &#123;cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line"><span class="built_in">func1</span>();</span><br><span class="line"><span class="comment">// lambda表达式和下面这个函数对象是等价的</span></span><br><span class="line">TestLambda01&lt;&gt; t1;</span><br><span class="line"><span class="built_in">t1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLambda01</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="built_in">func2</span>(<span class="number">20</span> + <span class="number">30</span>);</span><br><span class="line"> <span class="comment">//等价</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLambda02</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果[] 有需要捕获的参数 ，则 相当于对象有成员函数需要传入， 也就是有构造函数的实现</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">class TestLambda03&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">TestLambda03(...) &#123;...&#125;</span></span><br><span class="line"><span class="comment">  void operator()(int a, int b) const&#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLambda04</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TestLambda03</span>(<span class="type">int</span> a, <span class="type">int</span> b) :<span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = ma;</span><br><span class="line">    ma = mb; </span><br><span class="line">    mb = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ma;</span><br><span class="line">  <span class="type">int</span> mb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二者等价 会报错，因为是常方法，不可以修改成员变量的值</span></span><br><span class="line"><span class="keyword">auto</span> func3 = [a,b]()-&gt;<span class="type">void</span>&#123; </span><br><span class="line">  <span class="type">int</span> tmp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何修改 加上mutable 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func3 = [a,b]()-&gt;<span class="type">void</span> <span class="keyword">mutable</span> &#123; </span><br><span class="line">  <span class="type">int</span> tmp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLambda04</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TestLambda03</span>(<span class="type">int</span> a, <span class="type">int</span> b) :<span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = ma;</span><br><span class="line">    ma = mb; </span><br><span class="line">    mb = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> ma;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> mb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func3 = [&amp;a,&amp;b]()-&gt;<span class="type">void</span>&#123; <span class="comment">// 这个时候就不用mutable 也不报错 </span></span><br><span class="line">  <span class="type">int</span> tmp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLambda05</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TestLambda03</span>(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b) :<span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = ma;</span><br><span class="line">    ma = mb; </span><br><span class="line">    mb = tmp; <span class="comment">//这里修改了 是 引用的值，const只是限制了引用（也就是指针）不能修改， 但是这里是直接修改了内存的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> &amp;ma;</span><br><span class="line">  <span class="type">int</span> &amp;mb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), []()-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 65 按序插入序列，要找第一个小于65的数组</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find_if</span>(vec.begin, vec.<span class="built_in">end</span>(), </span><br><span class="line">                  [](<span class="type">int</span> a)-&gt;<span class="type">bool</span>&#123;<span class="keyword">return</span> a &lt; <span class="number">65</span>;&#125;);</span><br><span class="line"></span><br><span class="line">for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a)&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;);</span><br></pre></td></tr></table></figure><h2 id="lambda的应用实践">lambda的应用实践</h2><blockquote><p>既然lambda表达式只能用在语句当中，如果想跨语句使用之前定义好的lambda表达式，怎么办？用什么类型来表示lambda表达式？</p><p>lambda表达式 -&gt; 函数对象</p><p>使用function类型来表示函数对象的类型 bind1st/bind2nd bind 绑定器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">map&lt;<span class="type">int</span>, function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;&gt; caculateMap;</span><br><span class="line">caculateMap[<span class="number">1</span>] = [](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a +b;&#125;;</span><br><span class="line">caculateMap[<span class="number">2</span>] = [](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a - b;&#125;;</span><br><span class="line">caculateMap[<span class="number">3</span>] = [](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a * b;&#125;;</span><br><span class="line">caculateMap[<span class="number">4</span>] = [](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a / b;&#125;;</span><br></pre></td></tr></table></figure><h3 id="智能指针">智能指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;FILE, function&lt;<span class="type">void</span>(FILE*)&gt;&gt; <span class="built_in">ptrr1</span>(<span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;w&quot;</span>), [](FILE *pf) &#123;<span class="built_in">fclose</span>(pf);&#125;);</span><br></pre></td></tr></table></figure><h3 id="优先级队列">优先级队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Data</span>(<span class="type">int</span> val1 = <span class="number">01</span>, <span class="type">int</span> val2 = <span class="number">10</span>):<span class="built_in">ma</span>(val1), <span class="built_in">mb</span>(val2)&#123;&#125;</span><br><span class="line">  <span class="comment">//bool operator&gt;(const Data &amp;a)&#123;return ma &gt; a.ma;&#125;</span></span><br><span class="line">  <span class="comment">//bool operator&lt;(const Data &amp;a) &#123;return ma &lt; a.ma;&#125;</span></span><br><span class="line">  <span class="type">int</span> ma;</span><br><span class="line">  <span class="type">int</span> mb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  priority_queue&lt;Data&gt; queue;<span class="comment">//这样则使用的内置的operator 重载函数实现的比较 ，不够灵活 ，重载函数使用的什么规则，比较的规则就是什么。。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第二种方法</span></span><br><span class="line">  priotity_queue&lt;Data, vector&lt;Data&gt; , function&lt;<span class="type">bool</span> (Data&amp;, Data&amp;)&gt;&gt; <span class="built_in">max_queue</span>([](Data &amp;d1, Data&amp; d2)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d1.ma &gt; d2.ma;</span><br><span class="line">  &#125;);</span><br><span class="line">  queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">  queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">  queue.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>,<span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda表达式">lambda表达式</h3><p>用的话就可以直接在需要用的地方定义， 且不会在代码中产生额外的累赘的类型。。</p><h2 id="模板的完全特例化和非完全-部分-特例化">模板的完全特例化和非完全（部分）特例化</h2><p>编译器的自动推导不一定是我们想要的结果，</p><p>所以需要对模版进行特例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">templte&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">compare</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>*a, <span class="type">const</span> <span class="type">char</span>*b)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">compare</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  <span class="built_in">compart</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>); <span class="comment">// T const char * ,编译器推演的类型是 const char *, 最终比较的是 两个指针的地址，而不是字符串的字典序， 所以需要 对模版特例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>() &#123;cout &lt;&lt; <span class="string">&quot;call Vector template init&quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对char * 类型提供的完全特例化版本 </span></span><br><span class="line"><span class="comment">// 完全特例化 类型完全确定</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="type">char</span> *&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>() &#123;cout &lt;&lt; <span class="string">&quot;call vector&lt;char *&gt; template init&quot;</span><span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  //对指针类型提供的部分特例化版本</span></span><br><span class="line"><span class="string">  // 部分特例化 类型范围是比 源模版 小一点的</span></span><br><span class="line"><span class="string">template&lt;typename Ty&gt;</span></span><br><span class="line"><span class="string">class Vector&lt;Ty*&gt;&#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">  Vector() &#123;cout &lt;&lt; &quot;call Vector&lt;Ty*&gt; init&quot; &lt;&lt; endl;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">template&lt;typename R, typename A1, typename A2&gt;</span></span><br><span class="line"><span class="string">class Vector&lt;R(*)(A1, A2)&gt; //函数指针类型</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> public:</span></span><br><span class="line"><span class="string">  Vector() &#123;cout &lt;&lt; &quot;call Vector&lt;R(*)(A1, A2)&gt; init&quot; &lt;&lt; endl;&#125; </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">int main()&#123;</span></span><br><span class="line"><span class="string">  vector&lt;int&gt; vec1;</span></span><br><span class="line"><span class="string">  vector&lt;char *&gt; vec2;</span></span><br><span class="line"><span class="string">  vector&lt;int *&gt; vec3;</span></span><br><span class="line"><span class="string">  vector&lt;int(*) (int, int)&gt; vec3;</span></span><br><span class="line"><span class="string">  vector&lt;int (int,int)&gt; vec4; //调用的是&quot;call Vector template init&quot;  源模板</span></span><br><span class="line"><span class="string">  // 也就是 int(*) (int ,int) 和 int(int,int)有所区别</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="模版的实参推演">模版的实参推演</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">   cout &lt;&lt;<span class="string">&quot; func&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function函数对象类型的实现原理">function函数对象类型的实现原理</h2><h3 id="例子">例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="type">void</span> hello&lt;string str&gt;&#123;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;R&lt;A1&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*PFUNC)(A1);</span><br><span class="line">  <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc)&#123;&#125;</span><br><span class="line">  <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A1 arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _pfunc(arg);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  PFUNC _pfunc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样写起来 好像 不同的函数 返回值是确定的 只有一个，但是形参列表是多种多样的，</span></span><br><span class="line"><span class="comment">// 这样岂不是要写很多myfunction??? 太捞了 捞的淌口水</span></span><br><span class="line"><span class="comment">// c++11----&gt; 可变参数列表 ... </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... A&gt;<span class="comment">// ...表示可变参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;R&lt;A1...&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*PFUNC)(A...);</span><br><span class="line">  <span class="built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc)&#123;&#125;</span><br><span class="line">  <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A... arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _pfunc(arg...); <span class="comment">//表示传递一组参数 ... 可变参数列表</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  PFUNC _pfunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// funcion&lt;void(string)&gt; func1 = hello;</span></span><br><span class="line">  myfunction&lt;<span class="built_in">void</span>(string)&gt; func1 = hello;</span><br><span class="line">  <span class="built_in">func1</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用了可变参数列表的 函数模版实现之后， 无论参数有多少，都会匹配到 这个可变参数模版的实现 由编译器来保障 类型的推演</span></span><br><span class="line">  myfunction&lt;<span class="built_in">int</span> (<span class="type">int</span>, <span class="type">int</span>)&gt; func2 = sum;</span><br><span class="line">   myfunction&lt;<span class="built_in">int</span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; func3 = sum3;</span><br><span class="line">   myfunction&lt;<span class="built_in">int</span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> )&gt; func4 = sum4;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="function的应用实例">function的应用实例</h2><h3 id="为什么要使用function？">为什么要使用function？</h3><p>函数对象 lambda表达式 只能使用在一条语句中</p><p>就可以使用function把这些 东西的 类型保存下来 成为一个变量 这样后面还可以使用</p><ul><li><p>用函数类型实例化function</p></li><li><p>通过function调用operator() 方法时， 要传入对应的参数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello2</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// function 类模版的定义要求 用一个函数类型 实例化function</span></span><br><span class="line">  <span class="function">function&lt;<span class="title">void</span> <span class="params">()</span>&gt; <span class="title">func</span><span class="params">(hello1)</span></span>;</span><br><span class="line">  <span class="comment">// function&lt;void ()&gt; func = hello1;</span></span><br><span class="line">  <span class="built_in">func1</span>(); <span class="comment">//func1.operator();</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  function&lt;<span class="type">void</span> (string)&gt; func2 = hello2;</span><br><span class="line">  <span class="built_in">func2</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">//func2.operator()(string str) ;</span></span><br><span class="line">  </span><br><span class="line">  function&lt;<span class="type">int</span> (<span class="type">int</span>, <span class="type">int</span>)&gt; func <span class="number">4</span>= [](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b;&#125; ;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">func4</span>(<span class="number">100</span>,<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的成员方法-function">类的成员方法+function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello2</span><span class="params">(string str)</span></span>&#123; <span class="comment">// void (*pfunc)(string)</span></span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//成员方法的调用必须依赖一个对象 和普通的函数直接使用函数名调用不同 void (Test::*pfunc)(string)</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span> </span>&#123;cout &lt;&lt; str &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  function&lt;<span class="type">void</span> (Test*, string)&gt; func5 = &amp;Test::hello;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">func</span>(&amp;<span class="built_in">Test</span>(),<span class="string">&quot;Call Test::hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c函数指针和function的区别">c函数指针和function的区别</h2><p>lambda 表达式</p><p>c函数指针只能 指向 <font color = 'blue'>绑定器标定的函数对象  + 普通的函数</font></p><p>而function可以指向 lambda表达式，更为灵活</p><h2 id="bind1st-bind2nd">bind1st&amp;&amp;bind2nd</h2><p>bind1st operator() 的第一个形参 变量 绑定成一个确定的值</p><p>bind2nd operator()的第二个形参变量 绑定成一个确定的值</p><p>c++ 11 从Boost库引入了bind绑定器和function函数对象机制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorothm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">#<span class="function">Incldue&lt;functional&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">//默认从小到大！</span></span><br><span class="line">  <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="type">int</span>&gt;);</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//把70 按照顺序插入到vec容器中 找第一个小雨70的函数</span></span><br><span class="line">  <span class="comment">// greator()</span></span><br><span class="line">  <span class="comment">// less() 都是 二元函数对象</span></span><br><span class="line">  <span class="comment">// 绑定器 + 二元函数对象 =&gt; 一元函数对象</span></span><br><span class="line">  <span class="comment">// bind1st + greator: bool operator() (70, const _ty&amp; _right)</span></span><br><span class="line">  <span class="comment">// bind2nd + less: bool operator() (const _ty&amp; _left, 70);</span></span><br><span class="line">  <span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="number">70</span>, <span class="built_in">greator</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">  <span class="comment">// auto it2 = find_if(vec.begin(), vec.end(), bind2nd(less&lt;int&gt;(), 70);</span></span><br><span class="line">  <span class="keyword">if</span>(it1 != vec.<span class="built_in">end</span>())&#123;</span><br><span class="line">vec.<span class="built_in">insert</span>(it1,<span class="number">70</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="bind实现原理">bind实现原理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(; fitst != last; ++first)&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">comp</span>(*first) )&#123;</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_mybind1st</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  _mybind1st(Compare comp, T val)</span><br><span class="line">    :_comp(comp), _val(val)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _comp(_val, second); <span class="comment">//对二元函数对象进行封装，固定了一个参数， 底层干事的还是原来的二元函数对象</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Compare _comp;</span><br><span class="line">  T _val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenam Compare, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_mybind1st&lt;Compare, T&gt; <span class="title">mybind1st</span><span class="params">(Compare comp, <span class="type">const</span> T &amp;val)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 直接使用函数模板，好处是可以进行 类型的推演</span></span><br><span class="line">  <span class="keyword">return</span> _mybind1st&lt;Compare, T&gt;(comp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it1 = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">mybind1st</span>(<span class="number">70</span>, <span class="built_in">greator</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind-function-实现线程池">bind + function 实现线程池</h2><p>c++11 bind绑定器 -&gt; 返回的结果还是一个函数对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; std &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">bind</span>(&amp;Test:test, <span class="built_in">Test</span>())();</span><br><span class="line">  cout &lt;&lt; <span class="built_in">bind</span>(sum, placeholders::_1, placeholders::_2)(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">  </span><br><span class="line">  function &lt;<span class="type">void</span> (string)&gt; func1 = <span class="built_in">bind</span>(hello, placeholders::_1); <span class="comment">// bind返回的binder就被复用了</span></span><br><span class="line">  <span class="built_in">func1</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">func1</span>(<span class="string">&quot;hello shanghai&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Thread</span>(function&lt;<span class="built_in">void</span>()&gt; func) :_func(func)&#123;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function">thread <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(_func)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  function&lt;<span class="type">void</span>()&gt; _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TheadPool</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ThreadPool</span>()&#123;&#125;</span><br><span class="line">  ~<span class="built_in">ThreadPool</span>()&#123;</span><br><span class="line">    <span class="comment">//释放Thread类占用的堆资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> _thread:_pool)&#123;</span><br><span class="line">      <span class="keyword">delete</span> _thread;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">startPool</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">      _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;TheadreadPool::runInThread, <span class="keyword">this</span>, i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; size;i++)&#123;</span><br><span class="line">_handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(thread &amp;t:_handler)&#123;</span><br><span class="line">      t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;Thread*&gt; _pool;</span><br><span class="line">  vector&lt;thread&gt; _handler;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">runInThread</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call runInThread id:&quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 对象 </tag>
            
            <tag> 左值 &amp;&amp; 右值 </tag>
            
            <tag> forward完美转发 </tag>
            
            <tag> 智能指针 </tag>
            
            <tag> functional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态和动态链接</title>
      <link href="/2024/08/04/%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/08/04/%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="程序的翻译">程序的翻译</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240803195742.png" alt=""></p><h4 id="预处理阶段-c-i">预处理阶段<code>.c -&gt; .i</code></h4><p>主要处理 # 开头的命令， #define 宏展开 #ifdef #include</p><p>例如#include &lt;stdio.h&gt;命令告诉预处理器读取系统头文件</p><p>stdio.h的内容,并把它直接插人程序文本中</p><h4 id="编译阶段-i-s">编译阶段<code>.i -&gt; .s</code></h4><p>编译器ccl 将文本文件hello.i 翻译成文本文件hello.s</p><h4 id="汇编阶段-s-o">汇编阶段<code>.s -&gt; .o</code></h4><p>汇编器as将hello.s 翻译成机器语言指令序列（二进制），生成一种叫做 可重定位目标程序.o</p><h4 id="链接阶段-o-elf">链接阶段<code>.o -&gt; elf</code></h4><p>hello.o  此时只有一个main函数 并没有 printf的函数的 具体 指令</p><p>printf函数,它是每个C编译器都提供的标准C库中的一个函数。 printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中(c库给的）,而这个文件必须以某种方式合并到我们的hello.o程序中。链接器(linker)就负责处理这种合并，它将 hello 这个程序 需要的函数 和 变量 和  hello 本身 链接在一起 成为一个 可执行目标文件（ELF文件）</p><h4 id="elf文件">ELF文件</h4><p><strong>TODO…</strong></p><h2 id="静态链接">静态链接</h2><p>将所有需要用到的代码 和 数据 复制到 可执行文件中，静态地链接。</p><p>就是一个可执行文件是完整的，其运行过程中的所有 <strong>函数</strong> <strong>数据</strong> 都在 可执行文件本身可以找到，对外部没有任何依赖</p><p>这样的程序 只要计算机的架构是一样的，就可以运行</p><h4 id="目标文件">目标文件</h4><p>有三种 可重定位目标文件 可执行目标文件 共享目标文件</p><h4 id="可重定位目标文件">可重定位目标文件</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804184945.png" alt=""></p><p>text段 代码段 已编译程序的机器代码</p><p>rodata 只读数据 如printf 的 格式串</p><p>data 已经初始化的全局和静态C变量</p><p>.bss 未初始化的全局和静态C变量</p><p>.symtab <font color = 'blue'> 符号表 </font> 存放程序中定义和引用的函数和全局变量的信息</p><p>.rel.text 一个text节中位置的列表，指示linker需要在链接的时候修改这些位置</p><p>.ret.data 被模块引用或定义的所有全局变量的重定位信息</p><p>.debug 调试符号表，局部变量和类型定义，定义和引用的全局变量，以及原始的C源文件， -g选项 编译程序时会生成</p><p>.line .strtab</p><p><font color='blue'>linker 通过 .rel 节中的信息来合并多个可重定位目标文件，生成一个可执行目标文件</font></p><h4 id="缺点是什么？">缺点是什么？</h4><p>如果一个函数 被很多程序广泛地使用，例如libc中的printf，如果每个用到了它的程序都要复制他到程序本身—&gt; 那么内存中就会出现printf中的成千上万个副本！<font color='red'>内存占用高！</font></p><p>另外的缺点是，对任何标准函数的任何改变，无论是多么小的改变，都要求重新编译，并且使用了这个函数的程序也要<font color='red'>重新编译，非常麻烦</font></p><h2 id="动态链接">动态链接</h2><p>动态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libsum.so sum.c</span><br></pre></td></tr></table></figure><p>PIC position independt code 位置无关代码</p><p>通过在运行时链接来减少程序的实际大小，被共享的so库在内存中只会存在一份，节省了内存空间，<mark>代码段是复用 共享的，数据段是各个程序都有一段</mark></p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804202643.png" alt=""></p><p>优点：可以热更新，占用内存小</p><p>共享库模块可能被加载到内存地址的任何地址，程序如何访问共享库的函数和数据？？</p><p>通过PIC 位置无关代码实现</p><p>在程序加载的时候，动态链接器需要做的是在程序加载的时候</p><ul><li><p>重定位lib的文本和数据到某个内存段，</p></li><li><p>重定位程序中所有对lib中定义符号的引用</p></li></ul><h3 id="pic">PIC</h3><p>可以加载 而无需重定位的代码称之为位置无关代码，原理， so模块加载到内存中是整个一起加载的，所以<mark>so模块内部的数据段和代码段的相对位置是不变的</mark></p><h4 id="got-global-offset-table">GOT（global offset table）</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804214614.png" alt=""></p><p>在数据段上有一个GOT表，用来存放 这个模块中使用的 <mark>全局变量或者 全局函数 </mark> 的地址 , 编译器还会为每个条目生成一个重定位记录，加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的<font color='blue'>绝对地址</font></p><p>也就是 so内部函数 对 变量 以及函数的引用是通过 pc相对寻址 间接寻址来 实现的 ，利用的是so内部代码段和数据段的 相对距离不变的性质，而GOT段放的是实际的地址 ，在程序加载的时候，动态链接器 会 解析这些符号 并且 改写GOT段的相关条目 从而使得它包含目标的正确的<font color='blue'>绝对地址</font></p><h4 id="plt-procedure-linkage-table">PLT（procedure linkage table）</h4><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804221126.png" alt=""></p><p>PLT是 一个模块调用了 定义在共享库中的任何函数 ，那么他就有自己的GOT 在数据段 PLT 在代码段</p><h5 id="lazy-binding">Lazy binding</h5><p>一个库中的函数并不是都会被使用到，所以使用延迟绑定，将函数的解析延迟到第一次调用到调用该函数的时候</p><p>PLT 是一个jump 跳到GOT去取函数的地址， 动态链接器在函数第一次调用的时候替换掉 GOT中的对应项，使得GOT中放的是正确的函数地址</p><h4 id="experiment">experiment</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;10 + fixed_num = %d\n&quot;</span>, <span class="built_in">sum</span>(<span class="number">10</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;10 - fixed_num = %d\n&quot;</span>, <span class="built_in">minus</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="case-1">case 1</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sum.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fixed_num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sum.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + fixed_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*minus.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MINUS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MINUS_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fixed_num = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*minus.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minus.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - fixed_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared -o libsum.so sum.c</span><br><span class="line">g++ -fPIC -shared -o libminus.so minus.c</span><br><span class="line">g++ -o test main.c -L. -lsum -lminus</span><br></pre></td></tr></table></figure><p>这种情况 会直接报错，<code>redefinition of &quot;fixed_num&quot;</code>, 报错阶段在 编译阶段 也就是 <code>.i -&gt; .S</code> 的过程中 , <code>.c/.cpp -&gt; .i </code>这个 过程是不会报错的，只是复制，并不会作检查。</p><h5 id="case2">case2</h5><h5 id="none"></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sum.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fixed_num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sum.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + fixed_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*minus.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MINUS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MINUS_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*minus.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minus.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> fixed_num = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - fixed_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候</p><p>两个全局变量 起作用的是 在头文件中声明过的全局变量，无论其在头文件中赋值还是源文件中赋值</p><h5 id="case3">case3</h5><h5 id="none"></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sum.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*sum.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sum.c&quot;</span></span></span><br><span class="line"><span class="type">int</span> fixed_num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + fixed_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*minus.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MINUS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MINUS_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*minus.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minus.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> fixed_num = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - fixed_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个都在 源文件中，这个可能属于是为定义的行为，但是一种表现是与链接的顺序有关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -fPIC -shared -o libsum.so sum.c</span><br><span class="line">g++ -fPIC -shared -o libminus.so minus.c</span><br><span class="line">g++ -o test main.c -L. -lsum -lminus</span><br></pre></td></tr></table></figure><p>这种情况 使用的是sum 的fixed_num全局变量</p><h5 id="启示：">启示：</h5><p><mark>编写共享库的时候，最佳实践应该是在头文件中声明 在源文件中赋值；</mark></p>]]></content>
      
      
      
        <tags>
            
            <tag> 静态链接 </tag>
            
            <tag> 动态链接 </tag>
            
            <tag> GOT和PLT </tag>
            
            <tag> 程序加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mhy8.3 笔试回顾</title>
      <link href="/2024/08/03/mhy_%E7%AC%94%E8%AF%95/"/>
      <url>/2024/08/03/mhy_%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>mhy8.3 笔试回顾</p><h2 id="选择题">选择题</h2><h3 id="流水线的执行时间计算">流水线的执行时间计算</h3><blockquote><p>有8个磁盘块需要处理，现在有一个缓存大小和一个磁盘块一样，磁盘块搬移到缓存需要80ms， 缓存搬移到cpu需要40ms，cpu处理这个磁盘块的数据需要60ms，流水线架构需要多长时间完成？</p><p>如果换成双缓存，需要多长时间？</p></blockquote><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240805100655.png" alt=""></p><p>所以答案是 (80 + 40) * 8 + 60  = 1020 ms</p><p>如果是双缓冲的话是多少呢？</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240805100819.png" alt=""></p><p>所以答案是 80 * 8 + 40 + 60 = 740 ms</p><p>总结</p><p>把图画出来 分析清楚各个stage如何链接就可以了</p><p>流水线的思想就是 <font color = 'blue'>一个过程如果可以被划分成实际的多个小过程，就可以使用流水线，使得每个模块都尽量不空转😈，进而提升吞吐率</font></p><p>距离就是 洗衣服40min-烘干30min-折叠衣服20min</p><p>如果有5桶衣服，洗第一桶衣服走完整个流程 也就是折叠完第一桶衣服之后才去 提第二桶衣服放到洗衣机里面洗 （问题在哪？ 在折叠衣服的时候， 洗衣机没有人用！浪费时间）</p><p>还有笔者 小时候学校考的一道题， 大意是用一口锅烙饼，也是使用的流水线思想来提升效率；</p><h3 id="稳定的排序算法">稳定的排序算法</h3><h4 id="什么是稳定？">什么是稳定？</h4><p><strong>稳定的排序算法</strong>是一种在排序过程中<mark>不会改变具有相等键值的元素的相对顺序的算法。</mark></p><p>换句话说，如果在未排序的数据中有两个元素A和B，它们的值相等，并且在排序前A在B之前，那么在排序完成后A仍然会在B之前。</p><h4 id="稳定具体有哪些？">稳定具体有哪些？</h4><p><strong>冒泡排序（Bubble Sort）</strong>：</p><ul><li>每次比较相邻的元素并交换它们，直到整个数组有序。</li><li>稳定性：是稳定的，因为只有在前一个元素大于后一个元素时才会交换。</li></ul><p><strong>插入排序（Insertion Sort）</strong>：</p><ul><li>从数组的第二个元素开始，依次将每个元素插入到已经排序的部分中。</li><li>稳定性：是稳定的，因为只会将较大的元素向右移动，不会打乱相等元素的顺序。</li></ul><p><strong>归并排序（Merge Sort）</strong>：</p><ul><li>递归地将数组分成两部分，然后合并时保持稳定性。</li><li>稳定性：是稳定的，因为在合并过程中可以确保相等元素按原始顺序排列。</li></ul><p><strong>计数排序（Counting Sort）</strong>：</p><ul><li>使用额外的计数数组来记录每个元素的出现次数，然后依次将元素放回原数组。</li><li>稳定性：是稳定的，因为在放回元素时保持了它们的原始顺序。</li></ul><p><strong>基数排序（Radix Sort）</strong>：</p><ul><li>逐位排序，通常从最低有效位到最高有效位，使用稳定的子排序算法（如计数排序）。</li><li>稳定性：是稳定的，因为它依赖于稳定的子排序算法。</li></ul><h4 id="不稳定">不稳定</h4><p><strong>快速排序（Quick Sort）</strong>：</p><ul><li>基于分治法，选择一个主元，然后对数组进行划分。</li><li>不稳定性：分区过程中，可能会打乱相等元素的顺序。</li></ul><p><strong>堆排序（Heap Sort）</strong>：</p><ul><li>基于堆数据结构，首先构建最大堆，然后不断提取最大元素。</li><li>不稳定性：由于堆的重构过程，可能会打乱相等元素的顺序</li></ul><p><strong>希尔排序（shell sort）:</strong></p><p>​ 基于插入排序的 不稳定</p><h4 id="寄">寄！</h4><h3 id="异常捕获">异常捕获</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derivedException</span> : <span class="keyword">public</span> MyException &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">deriveexception</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException &amp;e)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyException&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(derivedException &amp;e)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;derivedException&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会输出什么信息？</p><p>只会输出 <code>&quot;MyException&quot;</code></p><h4 id="为什么？-异常处理的顺序：">为什么？ -  <strong>异常处理的顺序</strong>：</h4><p>在异常处理机制中，如果先捕获基类的异常，所有派生自它的异常也会被捕获，导致派生类的异常处理代码被跳过。因此，应该先捕获 <code>derivedException</code>，然后再捕获 <code>MyException</code>。</p><h4 id="寄">寄</h4><h3 id="tcp与udp">TCP与UDP</h3><h2 id="编程">编程</h2><h3 id="模拟">模拟</h3><blockquote><p>米小游有一个长度为 n 的数组，其中第 i 个元素为 ai。现在定义数组的价值是最大的相邻数字的乘积。例如数组为 [3,5,1,2] ，相邻元素的乘积分别是 3<em>5=15,5</em>1=5和1*2=2 ，则数组的价值是这些数字中的最大值，即 15。</p><p>现在米小游想要任选数组中的某两个相邻的元素进行交换（<strong>你必须使用这次交换机会</strong>），他想知道最大可以将数组的价值更改为多少</p></blockquote><p>从前往后遍历，两种情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>() ;i++)&#123;</span><br><span class="line">   ans = <span class="built_in">max</span>(ans, nums[i] * nums[i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a b c</p><p>对应于不换或者换相邻的两个 也就是计算 ab bc 的值，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i + <span class="number">2</span> &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">  ans = <span class="built_in">max</span>(ans, nums[i] * nums[i + <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应于 ac</p><p><mark>唯一需要注意的点就是，乘法可能结果很大，所以需要选用long long </mark></p><p>启示:</p><p><font color = 'blue'>对于C++的ACM模式而言，选用存储结果的数据类型可以直接使用long long，以后一定要注意返回的结果用什么类型的变量存储 </font></p><h3 id="dfs">dfs</h3><blockquote><p>商店里有 n个商品，分别编号为 1~n ，每个商品都有一个价值 vali和体积 wi，米小游有一个有一个 m 容量的背包，他能够装得下任意多个体积之和不超过 m 的商品。</p><p>米小游认为有些东西一起购买会带来灾难，比如可莉的角色立牌和蹦蹦炸弹的小手办，所以他设定了 k组互斥关系，每组关系给定两个数字 a,b，表示编号为 a 的商品和编号为 b的商品不能同时购买。</p><p>米小游希望装下的物品的价值之和最大，请你帮帮他求出最大价值。</p></blockquote><p>思路：商品数量很小（1 &lt; n &lt; 15) 直接暴力递归枚举 结合 set 判断是否 当前的物品和 之前选好的物品是否 冲突</p><p>代码略</p><h4 id="gto-博弈论">GTO 博弈论</h4><blockquote><p>米小游和派蒙在进行一场游戏。游戏在一个基环树（点数与边数相等的无向简单连通图）上进行，定义图中一个点的度数为与其相连的边数，二人轮流进行以下操作：</p><p>● 选择图中一个度数为 1 的点，删除这个点以及与这个点相连的边。</p><p>图中有一个特殊的点 x ，删除了点 x 的玩家即获得胜利。</p><p>现在，由米小游先进行操作。在双方都采取最优策略的情况下，胜者是谁？</p></blockquote><p>基环树 ： 在树的基础上+ 一个环</p><p><mark> 在双方都采取最优策略的情况下，胜者是谁？ </mark> 这种字眼就是GTO博弈论的题目，</p><p>找到一个规律就可以直接得出结论</p><p>对于本题</p><ul><li><p>如果x在环中，无论如何都删不掉，因为环上的点度数始终为2，无法破坏 ，结果必然是Draw</p></li><li><p>如果不在环中，则统计度数为奇数的个数cnt</p><ul><li>如果cnt是偶数个，</li><li>如果cnt是奇数个，</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试笔试记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流水线 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 异常处理 </tag>
            
            <tag> TCP UDP </tag>
            
            <tag> 面试 &amp;&amp; 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp</title>
      <link href="/2024/07/29/dp/"/>
      <url>/2024/07/29/dp/</url>
      
        <content type="html"><![CDATA[<p>dp</p><ol><li>选或者不选？</li><li>枚举选那个？</li></ol><h2 id="动态规划">动态规划</h2><p>构造问题</p><p>原问题是否可以拆分成问题 + 相似的子问题？</p><p>求解简单子问题 （初始化）</p><p>通过已知的问题来求解(dp 过程)</p><p>计算复杂度 时间复杂度在<mark>千万级别以内</mark>的就可以通过<br><font color='blue'>因此有时候也可以使用数据范围来推算方法</font>，如 m = 500,000, n = 500,000<br>可以推测能 通过 的算法的复杂度应该为 O(mlogn)</p><p>你已经学会了，现在来试试吧🤗🤗😈</p><blockquote><p>CF598E - pdd 实习笔试</p><p>给一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​​大小的chocolate Bar，每次可以横向或者竖向折断，这段的代价是截断长度的平方，求想吃大小为k的chocolate 块的话需要代价最少是多少？？？</p><p>给T组数据，T次查询</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>T</mi><mo>≤</mo><mn>40910</mn></mrow><annotation encoding="application/x-tex">1 \le T \le 40910</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">9</span><span class="mord">1</span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">1\le n,m \le30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>50</mn><mo separator="true">,</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1\le k \le min(50,n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p></blockquote><p>显然可以拆分，天然的子问题，<code>dp[i][j][l]</code> 表示从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>×</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \times j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的chocolate bar 拆分出 <code>l块</code>需要的代价</p><p>状态转移：</p><ul><li><p>$when \space i \times j &lt; l, dp[i][j][l] = inf $​</p></li><li><p>$when \space i \times j = l, dp[i][j][l] = 0 $​</p></li><li><p>竖向折断</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mo>−</mo><mi>k</mi><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><msup><mi>j</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>遍历</mtext><mi>x</mi><mtext>与</mtext><mi>k</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">dp[i][j][l] = min(dp[i][j][l], dp[i-x][j][l-kk] + dp[x][j][kk] + j^2), 遍历x与kk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">遍</span><span class="mord cjk_fallback">历</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">与</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p></li><li><p>横向折断</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>l</mi><mo>−</mo><mi>k</mi><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><msup><mi>i</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>遍历</mtext><mi>y</mi><mtext>与</mtext><mi>k</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">dp[i][j][l] = min(dp[i][j][l], dp[i][j-y][l-kk] + dp[i][y][kk] + i^2), 遍历y与kk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">遍</span><span class="mord cjk_fallback">历</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">与</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p></li></ul><p>复杂度分析</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>o</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>30</mn><mo>∗</mo><mn>30</mn><mo>∗</mo><mn>50</mn><mo>∗</mo><mo stretchy="false">(</mo><mn>60</mn><mo>∗</mo><mn>50</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>3</mn><mi>k</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">o(n*m*k) * o((n+m)*k) \leq 30*30*50 *(60*50) = 1e3kw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></p><h2 id="区间dp">区间dp</h2><p>常用于字符串，戳气球…</p><p>一般是三维 <code>dp[i][j][k]</code> 表示区间 [i,j] 内状态k 的方案数/…</p><p>但是有可能超时</p><p>所以结合 线段树， 树状数组 ，二分等等</p><h1 id="记忆化搜索">记忆化搜索</h1><p>dp是顺推导，自底向上</p><p>记忆化搜索是 自顶向下 递归 +  数组记忆</p><h2 id="数位dp">数位dp</h2><p>与数字有关</p><blockquote><p>例题 2801 统计范围内的步进数字数目</p><p>给定两个正整数low和high 计算 闭区间[low, high]之间的步进数字数目</p><p>步进数字: 相邻数位之间差的绝对值 是 1 ，</p><p>对 1e9 + 7 取模然后返回</p><p>1 &lt;= low, high &lt;= 10^100</p></blockquote><p>模版</p><p>f(i, pre, is_limit, is_num); 表示构造第i位及其之后数位的合法方案数量，</p><p>i , pre 根据题目要求决定是否需要，后两个必须</p><p>pre 前一位数位是什么？</p><p>is_limit 是否收到了最大数字n的限制，比如 123， 第一位取了1 ，第二位就收到了限制 ，0～2</p><p>is_num 前面是否有数字，如果前面没有数字，这一位也可以跳过，没有数字，可以是&gt;= 1的数字，也可以跳过， 如果前面有数字，这一位就取决于is_limit</p><p>递归入口</p><p>f(0, 0, true, false);</p><p>从s[0]开始枚举 ，</p><p>pre初始化成什么都可以，填第一个数的时候忽略了pre</p><p>一开始要受到n的约束</p><p>一开始没有填数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> m = s.<span class="built_in">size</span>(), memo[m][<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">memset</span>(memo ,<span class="number">-1</span>, <span class="built_in">sizeof</span>(memo));</span><br><span class="line">  function&lt;<span class="type">int</span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>, <span class="type">bool</span>)&gt; f = [&amp;](<span class="type">int</span> i, <span class="type">int</span> pre, <span class="type">bool</span> is_limit, <span class="type">bool</span> is_num) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == m) <span class="keyword">return</span> is_num;<span class="comment">// 长度满足，is_num为true表示前面的数据是合法非空的</span></span><br><span class="line">    <span class="keyword">if</span>(!is_limit &amp;&amp; is_num &amp;&amp; memo[i][pre] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i][pre];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!is_num)&#123; <span class="comment">//前面没有有效数字，这一位也跳过有多少种？</span></span><br><span class="line">    res = <span class="built_in">f</span>(i+<span class="number">1</span>, pre, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这一位不跳过了</span></span><br><span class="line">    <span class="type">int</span> up = is_limit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span> - is_num; d&lt;=up;d++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!is_num || <span class="built_in">abs</span>(d - pre) == <span class="number">1</span>)&#123;</span><br><span class="line">        res += <span class="built_in">f</span>(i+<span class="number">1</span>, d, d == up, <span class="literal">true</span>) % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!is_limit &amp;&amp; is_num) memo[i][pre] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calc(high) - calc(slow-1) 就是答案，但是slow - 1不好减</p><p>=》 calc(high) - calc(low) + valid(low);</p><p>Valid(low) 判断 low是否是步进数字，返回 1， 或者 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">result</span><span class="params">(string low, string high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">calc</span>(high) - <span class="built_in">calc</span>(low) + MOD + <span class="built_in">valid</span>(low)) % MOD; <span class="comment">// + MOD防止算出负数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充">补充</h3><ul><li><p>(a+b)%M = (a % m + b % m)%m</p></li><li><p>(a*b)%M = ((a%M) * (b%M)) % M</p></li><li><p>这里的f(i, pre, is_limit, is_num) 明明状态是4个，按道理记忆化递归的memo的维度也应该和函数的维度一样，为何memo只有 i和 pre两个维度？</p><p>因为 实际上这里做了简化，is_limit， is_num 有四种状态</p><table><thead><tr><th></th><th>is_limit:false</th><th>is_limit:true</th></tr></thead><tbody><tr><td>is_num:false</td><td>A</td><td>C</td></tr><tr><td>is_num:True</td><td>B</td><td>D</td></tr></tbody></table><p>A 与 C都是前面没有数字，受到限制与否不起作用，前面没有数字，则这种情况只会遍历一次，比如第一位不填，第二位也不填，后面再怎么递归也不会重新进入这种情况</p><p>B 代表前面有数字有不受到限制的情况，这实际上就是memo记录的东西</p><p>D 代表前面有数字的情况下，这一位也受到了限制，那么这种情况实际上也只会经过一次，没必要记忆，比如2344557， 第一位填2，第二位填3， 后面无论怎么递归都不会再次递归到第一位填2 ，第二位为3 的情况</p><p>也就是保存ACD这三种情况没必要，后面不会复用，只有保存B才有用，所以此刻的memo记录的就是memo[i] [pre] <mark style="background-color yellow"> 不受到约束的情况下第i位开始递归 前一位数字为pre的结果有多少种</mark></p><p><font color='blue'>(1,3,false,false) 表示i = 0填3 ，从i=1往后随便填的方案数量</font></p></li><li><p>什么情况下必须要有isNum参数</p><p>计算【0，n】中 有多少个数x满足：统计x的每个数位，要求0，1，2，3 ，9 的出现次数都是偶数，这种情况如果把前导0也算进去的话，就会和x中的0混在一起，没办法判断x中的0出现了几次</p><p>不需要isNum -&gt; 600 不含连续1 的非负整数</p></li></ul><blockquote><p>2367 统计特殊整数</p><p>一个正整数 每一个数位都是互不相同的，称为特殊整数，</p><p>给定n 求[1, n] 之间的特殊整数个数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">100010</span>;</span><br><span class="line">string num = <span class="built_in">to_string</span>(n);</span><br><span class="line"><span class="type">int</span> len = num.<span class="built_in">size</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">bool</span> is_limit, <span class="type">bool</span> is_num, <span class="type">int</span> mask)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_num) ans++; <span class="comment">//是一个有效的数字，统计个数</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!is_num)&#123; <span class="comment">// 前面不是一个有效的数字，可以跳过</span></span><br><span class="line">    <span class="built_in">dfs</span>(i + <span class="number">1</span>, <span class="literal">false</span>, <span class="literal">false</span>, mask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> up = is_limit ? num[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>; <span class="comment">//受到数位限制就是 num[i] - &#x27;0&#x27; 否则就是 9；</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> d = is_num ? <span class="number">0</span> : <span class="number">1</span>;d &lt; up;d++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((mask &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123; <span class="comment">// 表示这个数字没用过</span></span><br><span class="line">      <span class="built_in">dfs</span>(i+<span class="number">1</span>, d==up &amp;&amp; is_limit, <span class="literal">true</span>, mask | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*为什么 d = is_num ？ 0 ： 1；</span></span><br><span class="line"><span class="comment">  因为 该跳过的地方已经在第10行跳过了，接下来不能跳过，必须选</span></span><br><span class="line"><span class="comment">  is_num是有效的 则可以从 0 开始</span></span><br><span class="line"><span class="comment">  is_num无效意味着前面全部是前导0， 这里必须选一个有效数字 从1 开始，因为选0 已经被第10行的逻辑统计过了</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树形dp">树形DP</h2><h3 id="例题">例题</h3><h4 id="子树大小">子树大小</h4><blockquote><p>一颗n个节点的树（1为根节点），求以i为根的子树大小</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dp(n, 0);</span><br><span class="line"></span><br><span class="line">void dfs(node)&#123;</span><br><span class="line">if(node是叶子)&#123;dp[node] = 1; return;&#125;</span><br><span class="line">for(node的每个子节点leaf)&#123;</span><br><span class="line">dfs(leaf);</span><br><span class="line">df[node] += df[leaf]</span><br><span class="line">&#125;</span><br><span class="line">dp[node] += 1; //加上自己</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的平衡点">树的平衡点</h4><blockquote><p>一个n个点的树，求树的平衡点和删除平衡点之后最大子树的节点树，平衡点，指的是树中的一个点，删除该点，使得剩下的若干个连通块中，最大的连通块的块大小最少。</p></blockquote><p>树 删去一个点之后会产生 两颗树，或者一颗（删去叶子），或者三颗树</p><p><font color='blue'><strong>确定状态</strong></font> 设F[i] 为删除 i号点之后的最大连通块的大小。</p><p><font color='blue'><strong>状态转移</strong></font> F[i] = max(n - f[i], max(f[leaf]))  要么是父节点所在的连通块 n - f[i], 要么是子节点所在的连通块的最大值 max(f[leaf])</p><p>1、先 计算 子树大小</p><p>2、再对树 dfs一次 计算F[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 或者一次遍历</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> ans = n, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">  f[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v : u的每个子节点)&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(u, v);</span><br><span class="line">    f[u] += f[v];</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, f[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  mx = <span class="built_in">max</span>(mx, n - f[u]);</span><br><span class="line">  <span class="keyword">if</span>(ans &gt; mx) ans = mx, idx = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="没有上司的舞会-树的最大独立集">没有上司的舞会（树的最大独立集）</h4><blockquote><p>有n名职员，编号1～n， 他们的关系就像是一颗以老板为根的树，父节点就是子节点的直接上司，每个职工有一个快乐指数，用整数Hi给出，现在要召开一场周年庆功宴会，没有职工愿意和直接上司一起参会，在满足这个条件的前提下，主办方邀请一部分职工参加 是的所有参会职工的快乐指数综合最大，求最大值</p><p>快乐指数由 数据给出吧 ？也就是求树上的权值之和最大值， 但是要求 选的点是不相邻的</p></blockquote><p>分治法， 每个节点返回 不选自身 和 选自身 能取得的最大值是多少？由父节点负责汇总，最后由根节点得出答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">H</span><span class="params">(N, ?)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123; <span class="comment">// 返回值表示不选当前节点， 选当前节点</span></span><br><span class="line">  <span class="keyword">if</span>(u 是叶子) <span class="keyword">return</span> <span class="built_in">make_pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; (<span class="number">0</span>, H[u]); <span class="comment">// </span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>; <span class="comment">// a表示不选当前的u ，b 表示选</span></span><br><span class="line">  <span class="keyword">for</span>(v : u的每个节点)&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tmp = <span class="built_in">dfs</span>(v);</span><br><span class="line">    a += <span class="built_in">max</span>(tmp-&gt;firsts, tmp-&gt;second); <span class="comment">//不选当前u 就可以选或者不选 子节点都行</span></span><br><span class="line">    b += tmp-&gt;first; <span class="comment">// 选当前u 子节点就不能选了，</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">make_pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; (a, b+H[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tmp = <span class="built_in">dfs</span>(root);</span><br><span class="line">res = <span class="built_in">max</span>(tmp.first, tmp.second);</span><br></pre></td></tr></table></figure><h4 id="strategic-game-树的最小点覆盖">strategic game 树的最小点覆盖</h4><blockquote><p>一棵n个节点的树，每两个点之间至多一条边，如果在一个节点上放置一个兵，可以看守与其相连的边，最少需要几个兵，才能看守所有的边</p></blockquote><p>这道题 和 上一道题有点类似，i号点选或者不选 会影响子树的结果，但是上一题是 儿子和父亲不能同时选， <mark>这一题是儿子和父亲不能同时不选</mark>，否则就 出现了没有被覆盖的边！！</p><p><font color = 'blue'><strong>确定状态</strong></font></p><p><code>f[i][0]</code>为 在i上不放士兵 子树被看护 住的士兵数目</p><p><code>f[i][1]</code>为 在i上放士兵 子树被看护 住的士兵数目</p><p><font color = 'blue'><strong>状态转移</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">for</span>(v : u的所有叶子)&#123;</span><br><span class="line">  a += <span class="built_in">min</span>(f[v][<span class="number">0</span>], f[v][<span class="number">1</span>]); <span class="comment">//这个就是 u 放了士兵，那么子节点放与不放都无所谓，取最小即可</span></span><br><span class="line">  <span class="comment">//如果不放的话，就必须是子节点都放了士兵，才能确保u与所有子节点相连的边有人看护</span></span><br><span class="line">  b += f[v][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">f[u][<span class="number">0</span>] = b;</span><br><span class="line">f[u][<span class="number">1</span>] = a + <span class="number">1</span>; <span class="comment">// f[u][1]表示当前节点放 ，所以要 + 1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(u是叶子) f[u][<span class="number">0</span>] = <span class="number">0</span>, f[u][<span class="number">1</span>] = <span class="number">1</span>, <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(v : u的所有叶子)&#123;</span><br><span class="line">    a += <span class="built_in">min</span>(f[v][<span class="number">0</span>], f[v][<span class="number">1</span>]); <span class="comment">//当前节点放， 子节点可放可不放</span></span><br><span class="line">    b += f[v][<span class="number">1</span>]; <span class="comment">//当前节点不放 ，子节点必须放</span></span><br><span class="line">  &#125;</span><br><span class="line">  f[u][<span class="number">0</span>] = b;</span><br><span class="line">  f[u][<span class="number">1</span>] = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">min</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h4 id="cell-phone-network-树的最小支配集">Cell phone Network 树的最小支配集</h4><blockquote><p>给一个有n个点的树,每两个点至多只有一条边，如果在第i个点布置信号塔， 就可以让它和所有与之相连的点都收到信号，求至少多少个信号塔能让所有点都收到信号</p></blockquote><p><mark> 这个的约束 是 当前节点的 父节点和子节点不能同时不放 </mark></p><p><font color = 'blue'><strong>确定状态</strong></font></p><p><code>f[i][0]</code> 表示选点i，且以i为根的子树 每个点都覆盖的最少信号塔数量</p><p><code>f[i][1]</code> 表示不选点i，且以i为根的子树 每个点都覆盖的最少信号塔数量</p><p><code>f[i][2]</code>表示不选 i，但是 i没被子节点覆盖，也就是除了i之外的这棵子树都被覆盖住了的最少信号塔数量</p><p>初始化 对于叶子而言</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][<span class="number">0</span>] = <span class="number">1</span>, f[i][<span class="number">1</span>] = <span class="number">0</span>, d[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>对于每个节点 u</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>v</mi></munder><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f[u][0] = \sum_{v}{min(f[v][0],f[v][1],f[v][2])}  +  1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>v</mi></munder><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">f[u][2] = \sum_v{(f[v][1])}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></span></p><p><code>f[u][1]</code>的情况有些复杂，不选u，但是要求每个点都被覆盖，则 u的子节点必须有一个被选择，才能覆盖u，也就是 至少要有一个 <code>f[v][0]</code> 被选择 ,即 每个 v都从 <code>f[v][0]</code> 和<code>f[v][1]</code> 之间选择，但是至少有一个人要选择   <code>f[v][0]</code></p><p>分情况 ：</p><ul><li>如果 有一个人 满足  <code>f[v][0]</code>  &lt;= <code>f[v][1]</code>   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><msub><mo>∑</mo><mi>v</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[u][1] = \sum_v(min(f[v][1], f[v][0]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 因为此时一定有子节点 取了 <code>f[v][0]</code> ，满足<code>f[u][1]</code> 的条件</li><li>否则就是 所有子节点都是 <code>f[v][0]</code>  &gt;  <code>f[v][1]</code> ,那么 取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><msub><mo>∑</mo><mi>v</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[u][1] = \sum_v(min(f[v][1], f[v][0]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 一定导致全部取的<code>f[v][1]</code>， 这个时候， 选一个最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min_v(f[v][0])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 加入，保证满足条件，然后其余的全部选<code>f[v][1]</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  v[x] = <span class="number">1</span>;</span><br><span class="line">  f[x][<span class="number">0</span>] = <span class="number">1</span>, f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> tmp = inf;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; e[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="type">int</span> y = e[x][i];</span><br><span class="line">    <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y);</span><br><span class="line">    f[x][<span class="number">2</span>] += f[y][<span class="number">1</span>];</span><br><span class="line">    f[x][<span class="number">0</span>] += <span class="built_in">min</span>(f[y][<span class="number">0</span>], d[y][<span class="number">1</span>], f[y][<span class="number">2</span>]); <span class="comment">//重载版本</span></span><br><span class="line">    <span class="keyword">if</span>(f[y][<span class="number">0</span>] &lt;= f[y][<span class="number">1</span>])&#123;</span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      f[x][<span class="number">1</span>] += f[y][<span class="number">1</span>];</span><br><span class="line">      tmp = <span class="built_in">min</span>(tmp, f[y][<span class="number">0</span>] - f[y][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag) f[x][<span class="number">1</span>] += tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉苹果树-树上背包问题">二叉苹果树 树上背包问题</h4><blockquote><p>有一颗二叉苹果树，如果树有分叉，一定是分成两叉，即没有只有一个儿子的节点，这棵树一共有N个节点，标号1 ～ N，root为1，用一根树枝两端链接的节点编号来描述树，树枝太多了需要剪枝，但是一些树枝上有苹果，给定需要保留的树枝数量，求最多能留住多少苹果</p></blockquote><p>苹果是长在树枝上的，</p><ul><li><code>a[i].l</code>表示链接i 及其 左边儿子 树枝上的苹果数量</li><li><code>a[i].r</code>表示链接i 及其 右边儿子 树枝上的苹果数量</li></ul><p>题目要求在给定的保留的树枝数量时最多能留住苹果的数量 ，设<code>f[i][j]</code> 表示以i为根 保留j个树枝的最大苹果数量</p><p><font color='blue'><strong>状态转移</strong></font></p><ul><li><p>对于i 的左右子树都保留的情况, 则设其左子树和右子树分别保留x y个树枝，则有 x + y + 2 = j</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi><munder><mo><mi>m</mi><mi>a</mi><mi>x</mi></mo><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow></munder></mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo>−</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">f[i][j] = \underset{x\in[0,j - 2]}{max} (f[l][x] + f[r][j - 2 -x] + a[i].l + a[i].r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.716em;vertical-align:-0.966em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.3089999999999997em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mopen mtight">[</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathdefault">ma</span><span class="mord mathdefault">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.966em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></p></li><li><p>只保留左子树</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">f[i][j] = f[l][j-1] + a[i].l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></p></li><li><p>只保留右子树</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">f[i][j] = f[r][j-1] + a[i].r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></p></li><li><p>左右都不保留 这个时候 j = 0；</p></li></ul><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[i][0] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>​</p><p><font color = 'red'>如果不是二叉 ，k 叉怎么办？？</font></p><h4 id="树的直径">树的直径</h4><blockquote><p>给定一个有n个节点的树，树上的每个点有一个权值 ，定义一棵树的子链大小为：这个子链上所有节点的权值之和，求这棵树上最大子链的节点权值和</p></blockquote><p>Rinne Loves Edges</p><blockquote><p>R⁢i⁢n⁢n⁢e 最近了解了如何快速维护可支持插入边删除边的图，并且高效的回答一下奇妙的询问。 她现在拿到了一个 n 个节点 m⁡(m=n−1) 条边的无向连通图，每条边有一个边权 现在她想玩一个游戏：选取一个 “重要点” S ，然后选择性删除一些边，使得原图中所有除 S 之外度为 1 的点都不能到达 S。<br>定义删除一条边的代价为这条边的边权，现在 R⁢i⁢n⁢n⁢e 告诉你他选取的“重要点” 是谁，她想知道完成这个游戏的最小的代价，这样她就能轻松到达 r⁢k⁢1 了！作为回报，她会让你的排名上升一定的数量。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 记忆化搜索 </tag>
            
            <tag> 数位dp </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP 专题</title>
      <link href="/2024/07/03/KMP/"/>
      <url>/2024/07/03/KMP/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是kmp">什么是KMP</h3><p>说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。</p><p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p><h3 id="kmp有什么用">KMP有什么用</h3><p>KMP主要应用在字符串匹配上。</p><p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p><h3 id="什么是前缀表">什么是前缀表</h3><p>用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配</p><p>那么前缀表：记录下标 i 之前（包括i）的字符串中，有多大长度的相同前缀后缀</p><blockquote><p>比如模式串 aabaaf ，f的位置的最长前缀后缀就是2</p></blockquote><p>前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力，</p><h4 id="最长相等前后缀">最长相等前后缀</h4><p>字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p><p>所以例子 <strong>a a b a a f</strong>的 前缀表是</p><p>​<strong>0 1 0 1 2 0</strong></p><h4 id="前缀表与next数组">前缀表与next数组</h4><p><strong>这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p><h3 id="如何构造next数组">如何构造next数组</h3><p>使用函数遍历一遍模式串从而得到next数组</p><p>这是统一 -1 的next数组</p><p><strong>i指向后缀末尾位置</strong></p><p><strong>j指向前缀末尾位置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next[i]表示i(包括i)之前最长相等的前后缀长度（其实就是j）</p><p>使用next数组，用模式串匹配文本串的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先调用 getNext函数获取前缀表</span></span><br><span class="line"><span class="comment">// j 是 当前已经得到 匹配的地方在模版串的 位置下标</span></span><br><span class="line"><span class="comment">// -1 表示还没得到匹配</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// 因为next数组里记录的起始位置为-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始，因这里的s是文本串</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配 </span></span><br><span class="line">        j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == (t.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="keyword">return</span> (i - t.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析">时间复杂度分析</h3><p>使用next数组对文本串和模式串进行匹配的时候，文本串是从前往后遍历的，遍历到最后就可以得到结果</p><p>所以时间复杂度为 遍历一次 文本串和模式串的时间 为 <font color = 'blue'>o(m+n);</font></p><p>如果是暴力匹配 则是 <font color = 'red'>o(m * n);</font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2024/06/25/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2024/06/25/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要使用智能指针？">为什么要使用智能指针？</h3><p>智能指针 帮助管理动态分配的内存的，可以帮助我们自动释放new出来的内存，从而避免内存泄露</p><blockquote><p>如果分配的动态内存都交给有生命周期的对象来处理，那么在对象过期的时候，让它的析构函数删除指向的内存，这似乎是一个好的方案？</p><p>智能指针就是通过这样的方法来解决指针自动释放的问题</p></blockquote><p>C++ 98 提供了 auto_ptr</p><p>C++11提供了unique_ptr, shared_ptr和weak_ptr</p><h3 id="auto-ptr">auto_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">auto_ptr&lt;类型&gt; 变量名字（<span class="keyword">new</span> 类型）</span><br><span class="line">  </span><br><span class="line">auto_ptr&lt;myclass&gt; <span class="built_in">ar</span>(<span class="keyword">new</span> myclass)</span><br></pre></td></tr></table></figure><p>智能指针 可以像正常指针一样使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;myclass&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> myclass())</span></span>;</span><br><span class="line"></span><br><span class="line">ptr-&gt;<span class="built_in">func</span>();</span><br><span class="line">(*ptr).<span class="built_in">func</span>(); <span class="comment">//都是合法的</span></span><br></pre></td></tr></table></figure><h4 id="三个常用函数">三个常用函数</h4><h5 id="get">get()</h5><p>获取智能指针托管的指针地址</p><p>但是一般不会使用也没必要去使用</p><h5 id="release">release()</h5><p>取消智能指针对动态内存的托管</p><h5 id="reset">reset()</h5><p>重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ptr</span>().<span class="built_in">reset</span>() <span class="comment">//释放掉智能指针托管的指针内存，并将其置为null</span></span><br><span class="line"><span class="built_in">ptr</span>().<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">myclass</span>()) <span class="comment">//释放掉智能指针托管的指针内存, 并更新其托管的指针</span></span><br></pre></td></tr></table></figure><h4 id="使用建议">使用建议</h4><ul><li>不要将auto_ptr 定义为全局变量或者指针</li><li>除非自己知道后果，不要吧auto_ptr智能指针赋值给同类型的另外一个智能指针</li></ul><h4 id="存在的问题">存在的问题</h4><p>c++11之后 auto_ptr已经被抛弃 使用unique_ptr代替</p><p>原因</p><ul><li><p>复制或者赋值都会改变资源的所有权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto_ptr 被C++11抛弃的主要原因</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，</span></span><br><span class="line"><span class="comment">// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。</span></span><br><span class="line">p1 = p2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在STL中使用autp_ptr存在重大风险，因为容器内的元素必须支持可复制和可赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;auto_ptr&lt;string&gt;&gt; vec;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m P3&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m P4&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用std::move修饰成右值，才可以进行插入容器中</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p3));</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p4));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec.at(0)：&quot;</span> &lt;&lt;  *vec.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec[1]：&quot;</span> &lt;&lt;  *vec[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 风险来了：</span></span><br><span class="line">vec[<span class="number">0</span>] = vec[<span class="number">1</span>];<span class="comment">// 如果进行赋值，问题又回到了上面一个问题中。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">//此处会发生数组越界或者说访问空指针 ，为什么？</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>不支持对象数组的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">array</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>;<span class="comment">// 不能这样定义</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="scoped-ptr">scoped_ptr</h3><p>与auto_ptr类似，能够非常方便删除创建的对象</p><p>scoped_ptr在获取对象所指空间的控制权之后，不能将本空间的控制权移交给他人，这就是与auto_ptr的区别，为什么不能移交？<br><font color='blue'>  拷贝构造和赋值被设置为了私有方法，或者直接 = delete </font><br><mark>与Unique_ptr的区别是 Unique_ptr可以结合 std::move 来实现资源所有权的转移， 而 scope_ptr 不能转移 </mark></p><h3 id="unique-ptr">Unique_ptr</h3><p>由于前述提到的auto_ptr的三个特性，c++11的unique_ptr被提出</p><h4 id="unique-ptr的特性">unique_ptr的特性</h4><ul><li>两个指针不能指向同一个资源<font color = 'blue'>unique </font></li><li>无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值</li><li>保存指向某个对象的指针，当它本身离开作用域时会自动释放资源</li><li>在容器中保存指针是安全的</li></ul><ol><li><p>无法左值复制赋值操作 ， 但是允许临时右值赋值和构造</p><p>因为两个指针不能指向同一个 资源，所以 <font color ='blue'> 左值赋值复制不被允许</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;11111&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;22222&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">p1 = p2 ; <span class="comment">// 禁止</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//禁止</span></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(std::move(p1))</span></span>;</span><br><span class="line">p1 = std::<span class="built_in">move</span>(p2); <span class="comment">//这两种就都可以，也是也auto_ptr赋值效果一样，所有权转移</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在STL容器中使用unique_ptr, 不允许直接赋值</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt; vec;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;111&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;222&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p3));</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p4));</span><br><span class="line"></span><br><span class="line">vec[<span class="number">0</span>] = vec[<span class="number">1</span>] ;<span class="comment">// 不允许直接赋值 ，同样也是指针的原因</span></span><br><span class="line">vec[<span class="number">0</span>] = std::<span class="built_in">move</span>(vec[<span class="number">1</span>]);  </span><br></pre></td></tr></table></figure><ol start="3"><li>支持对象数组的内存管理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">array</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>; 可以这样定义</span><br></pre></td></tr></table></figure><h3 id="shared-ptr">shared_ptr</h3><p>为了解决auto_ptr 和unique_ptr的排他性导致的问题—&gt; shared_ptr</p><p>如果需要多个指针变量共享怎么办？</p><blockquote><p>如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或者拷贝的时候，引用计数+1，当智能指针析构的时候，计数-1，如果计数为0，代表已经没有指针指向这块内存，那么管理的这个内存就会被释放，这就是 shared_ptr 采用的策略</p></blockquote><h4 id="use-count">use_count()</h4><p>获取shared_ptr的引用计数</p><h4 id="初始化">初始化</h4><ol><li><p>构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(up1)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>make_shared()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">shared_ptr&lt;string&gt; sp4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">shared_ptr&lt;Myclass&gt; sp5 = <span class="built_in">make_shared</span>&lt;Myclass&gt;(...);</span><br></pre></td></tr></table></figure></li><li><p>主动释放对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp1 = <span class="literal">nullptr</span>; <span class="comment">//引用计数-1，计数归0 内存释放</span></span><br><span class="line">sp1 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>重置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp1.<span class="built_in">reset</span>(); <span class="comment">//重置为空指针，计数-1</span></span><br><span class="line">sp1.<span class="built_in">reset</span>(sp2); <span class="comment">//重置为sp2，sp1计数-1，sp2计数+1，</span></span><br><span class="line">sp1.<span class="built_in">reset</span>(sp2,d) <span class="comment">//重置为sp2，并且使用d 作为删除器</span></span><br></pre></td></tr></table></figure></li><li><p>交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(up1, up2); <span class="comment">//交换 管理对象，但是原有的引用计数不变</span></span><br><span class="line">up1.<span class="built_in">swap</span>(up2);</span><br></pre></td></tr></table></figure></li></ol><h4 id="循环引用">循环引用</h4><p>当A引用了B，B又引用了A，这两个对象就会因为循环引用导致引用计数始终不为0，从而导致无法释放资源</p><h3 id="weak-ptr">Weak_ptr</h3><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作,</p><p><font color='blue'>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</font> 同时weak_ptr 没有重载*和-&gt;，</p><p>但可以<font color='red'>使用 lock 提升 </font>从而获得一个可用的 shared_ptr 对象。</p><p>也就是 weak_ptr 并不能直接使用，他只是保存了一个指针对象，需要使用的时候，需要使用<font color = 'blue'>lock()提升</font></p><h4 id="使用">使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr wp1;</span><br><span class="line"><span class="function">weak_ptr <span class="title">wp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">weak_ptr wp3 = wp2;</span><br><span class="line"></span><br><span class="line">wp2.<span class="built_in">use_count</span>(); <span class="comment">// 获取引用计数</span></span><br></pre></td></tr></table></figure><p>上面那种循环引用的问题就可以可以使用weak_ptr来解决，在类中使用弱指针来接管共享指针，在需要使用的时候就转换成共享指针去使用</p><h4 id="expired-函数">Expired 函数</h4><p>使用expired函数判断weak_ptr() 指针的合法性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true</span></span><br><span class="line"><span class="keyword">if</span>(!wp.<span class="built_in">expired</span>())&#123;</span><br><span class="line">  <span class="comment">// 有效，还有托管的指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 过期了，没有托管的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针使用的注意事项">智能指针使用的注意事项</h3><ul><li><p>不要把一个原生指针给多个智能指针管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(x)</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续释放的时候会发生二次释放堆区内存，报错</span></span><br><span class="line"><span class="comment">//或者以下形式：</span></span><br><span class="line">up1.<span class="built_in">reset</span>(x);</span><br><span class="line">up2.<span class="built_in">reset</span>(x);</span><br></pre></td></tr></table></figure></li><li><p>记得使用ptr.release()的返回值</p></li></ul><p>在调用u.release()时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就会泄漏</p><ul><li>禁止使用delete 智能智能get函数返回的指针</li></ul><p>如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放</p><ul><li><p>禁止用任何类型智能指针get 函数返回的指针去初始化另外一个智能指针！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt; <span class="type">int</span> &gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// 一个典型的错误用法 shared_ptr&lt; int &gt; sp4(sp1.get());</span></span><br><span class="line"><span class="comment">// 同样也会造成重复释放</span></span><br><span class="line"><span class="comment">// 推荐使用这个 shared_ptr&lt; int &gt; sp4(sp1);</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写muduo</title>
      <link href="/2024/06/09/muduo/"/>
      <url>/2024/06/09/muduo/</url>
      
        <content type="html"><![CDATA[<p>muduo网络库的重写</p><h1 id="目的">目的</h1><p>1、理解阻塞、非阻塞、同步、异步</p><p>2、理解Unix/Linux上的五种IO模型</p><p>3、epoll的原理以及优势</p><p>4、深刻理解Reactor模型5、从开源C++网络库，学习优秀的代码设计</p><p>6、掌握基于事件驱动和事件回调的epoll+线程池面向对象编程</p><p>7、通过深入理解muduo源码，加深对于相关项目的深刻理解</p><p>8、改造muduo，不依赖boost，用C++11重构</p><h1 id="知识储备">知识储备</h1><p>1、TCP协议和UDP协议</p><p>2、TCP编程和UDP编程步骤</p><p>3、IO复用接口编程select、poll、epoll编程</p><p>4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持</p><h1 id="阻塞-非阻塞-同步-异步">阻塞、非阻塞、同步、异步</h1><p>典型的一次IO的两个阶段 数据准备( 从设备缓冲区复制到 内核缓冲区 ）数据读写（从内核空间复制到用户空间）</p><p>数据准备： 根据系统IO操作的就绪状态</p><ul><li>阻塞  <font color='blue'>调用IO方法线程进入阻塞状态</font></li><li>非阻塞 <font color='gree'>不会改变线程的状态通过返回值判断</font></li></ul><p>ssize_t recv(int socked,void *buf, size_t len, int flags)</p><p>int size = recv(sockfd,buf,1024,0)</p><p>socketed 默认工作在阻塞模式， recv如果没有数据可以读 ，就会阻塞当前线程</p><p>非阻塞 recv 直接返回 通过返回值判断是否准备成功</p><p>​size = -1 表示错误 有两种情况 1、系统错误 2、非阻塞返回</p><p>所以要继续判断</p><p>​<strong>size = -1 &amp;&amp; errno = EAGAIN 非阻塞返回</strong></p><p>​size = 0 网络对端关闭了连接</p><p>​size &gt; 0  接收到的数据字节数</p><p>数据读写：根据应用程序和内核的交互方式</p><ul><li>同步 <font color = 'blue'>应用程序</font>使用recv 自己把数据从 从内核空间搬移到用户空间 <strong>recv 同步IO接口</strong> （阻塞或者非阻塞由sockfd决定）</li><li>异步 <font color='green'>操作系统</font>负责 从内核空间搬到用户空间<ul><li>sockfd 监听的端口</li><li>buf 用户程序存放数据的buf指针</li><li>sigio信号 通知数据读写完成</li><li>当操作系统使用  sigio 信号  <font color='red'><em><strong>通知</strong></em></font>  的时候表示 数据已经准备好了  （信号、回调</li><li>效率高但是编程复杂</li></ul></li></ul><p>​Linux异步IO接口 aio_read aio_write <strong>特殊API</strong></p><p>​同步IO select poll epoll</p><p><strong>陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步</strong></p><p><strong>IO。</strong></p><p>并发的同步和异步</p><p>同步 ： <strong>A等 B做完了 得到返回值 A 再继续执行</strong></p><p>异步 ：A告诉B 感兴趣的事件以及通知方式，A操作继续执行自己的业务逻辑，等B监听到了响应的事件发生，B  <font color='red'><strong>通知</strong></font>  A，A再处理，</p><p>Node.js 基于异步非阻塞模式下的高性能服务器</p><h1 id="unix-linux的五种io模型">Unix/Linux的五种IO模型</h1><h4 id="阻塞blocking-同步">阻塞blocking 同步</h4><table><thead><tr><th>应用进程read</th><th>系统调用----&gt;</th><th>内核</th></tr></thead><tbody><tr><td>阻塞…</td><td></td><td>内核准备数据</td></tr><tr><td>阻塞…</td><td></td><td>拷贝数据到用户进程空间</td></tr><tr><td>应用处理数据</td><td>&lt;----返回</td><td>拷贝成功</td></tr></tbody></table><p>进程阻塞于read</p><h4 id="非阻塞non-blocking-同步">非阻塞non-blocking 同步</h4><table><thead><tr><th>应用进程read</th><th>系统调用----&gt;</th><th>内核</th></tr></thead><tbody><tr><td>read</td><td>&lt;----- EAGAIN</td><td>准备数据</td></tr><tr><td>Read</td><td>&lt;----- EAGAIN</td><td></td></tr><tr><td>Read</td><td>&lt;----- EAGAIN</td><td></td></tr><tr><td></td><td></td><td>拷贝数据到用户进程空间</td></tr><tr><td>处理数据</td><td>&lt;----- 返回</td><td>拷贝完成</td></tr></tbody></table><p>进程调用read， 判断EAGAIN 反复调用</p><h4 id="io复用-io-multiplexing">IO复用 IO multiplexing</h4><p>在一个线程调用IO复用函数，可以监视一系列fd 是同步的IO接口</p><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td></td><td>数组 长度限制</td><td>链表无长度限制</td><td>红黑树</td></tr><tr><td></td><td>需要复制到内核</td><td>需要复制到内核</td><td>就是建立在内核内 无需复制</td></tr><tr><td></td><td></td><td></td><td>连接数量多 但是只有少部分是活跃连接</td></tr></tbody></table><h4 id="信号驱动signal-driven">信号驱动signal-driven</h4><p>上述三种在第一种阶段要么阻塞， 要么不阻塞但是需要轮询，但是信号启动时第一步不需要轮询，但是第二步是同步的，也就是数据从内核空间搬移到用户空间的话需要花费用户程序自己的时间去做</p><p>内核在第一个阶段是异步，在第二个阶段是同步，区别于非阻塞IO 是他提供消息通知机制，不需要用户进程不断轮询检查，减少了API的调用次数，提高效率</p><h4 id="异步asynchronous">异步asynchronous</h4><p>全都异步，第一步 第二步都是操作系统内核完成，效率高，但是编程复杂，出问题不好排查</p><p>典型的异步非阻塞状态，Node.js采用的网络IO模型。</p><h2 id="好的网络服务器设计">好的网络服务器设计</h2><p><font color='blue'>one loop per thread is usually a good model </font></p><p>这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p><p>event loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IOmultiplexing 一起使用，原因有两点：</p><ul><li><p>没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费CPU资源了。</p></li><li><p>IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO read()/write()/accept()/connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。</p></li></ul><p>所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其</p><p>中任何一个都没有办法很好的实现功能。</p><blockquote><p>epoll + fork不如epoll + pthread？</p></blockquote><p>强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的<strong>服务器惊群</strong>现象，功能十分强大</p><h2 id="reactor模型">reactor模型</h2><blockquote><p>The reactor design pattern is an event handling pattern for handling service requests</p><p>delivered concurrently to a service handler by one or more inputs. The service handler</p><p>then demultiplexes the incoming requests and dispatches them synchronously to the</p><p>associated request handlers.</p></blockquote><p><strong>重要组件</strong>：<strong>Event事件、Reactor反应堆、Demultiplex事件分发器、Evanthandler事件处理器</strong></p><h1 id="epoll">epoll</h1><h2 id="select的缺点：">select的缺点：</h2><p>1、单个进程能够监视的<strong>文件描述符的数量存在最大限制</strong>，通常是1024，当然可以更改数量，但由于</p><p>select采用<strong>轮询的方式扫描</strong>文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有</p><p>这样的定义：#define __FD_SETSIZE 1024</p><p>2、<strong>内核 / 用户空间内存拷贝</strong>问题，select需要复制大量的句柄数据结构，产生巨大的开销</p><p>3、select返回的是含有整个句柄的数组，<strong>应用程序需要遍历整个数组</strong>才能发现哪些句柄发生了事件</p><p>4、select的触发方式是<strong>水平触发</strong>，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程</p><h2 id="poll">Poll</h2><p>相比select模型，<strong>poll使用链表</strong>保存文件描述符，因此没有了监视文件数量的限制，但其他<strong>三个缺点依然存在。</strong></p><p>以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况</p><p>下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，</p><p>从内核/用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的</p><p>服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。</p><h2 id="epoll">epoll</h2><p>epoll把原先的select/poll调用分成以下3个部分：</p><p>1）调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）</p><p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p><p>3）调用epoll_wait收集发生的事件的fd资源</p><p>如此一来，要实现上面说的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这</p><p>个epoll对象中添加或者删除事件。同时，epoll_wait的效率也非常高，因为东西都放在内核空间，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><h2 id="lt模式">LT模式</h2><p>内核数据还没读完，就会一直上报数据</p><h2 id="et模式">ET模式</h2><p>内核数据只上报一次</p><h3 id="muduo采用的是lt"><strong>muduo采用的是LT</strong></h3><ul><li><p>不会丢失数据或者消息</p><ul><li>应用没有读取完数据，内核是会不断上报的</li></ul></li><li><p>低延迟处理</p><ul><li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li></ul></li><li><p>跨平台处理</p><ul><li>像select一样可以跨平台使用</li></ul></li></ul><h2 id="muduo网络库的核心模块">muduo网络库的核心模块</h2><p>Channel</p><h2 id="总结">总结</h2><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/%E9%87%8D%E5%86%99muduo.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CAS algorithm</title>
      <link href="/2024/05/23/CAS%E7%AE%97%E6%B3%95/"/>
      <url>/2024/05/23/CAS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>CAS（比较与交换，Compare and swap)</p><h2 id="有锁算法">有锁算法</h2><p>独占锁，假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。</p><p>缺点：</p><ul><li>产生竞争时，线程被阻塞等待，无法做到线程实时响应</li><li>dead lock</li><li>live lock</li><li>优先级反转</li><li>使用不当，造成性能下降</li></ul><h3 id="乐观锁与悲观锁">乐观锁与悲观锁</h3><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p><ol><li>乐观锁 <strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li><li>悲观锁 <strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久</li></ol><h2 id="cas算法">CAS算法</h2><p>CAS的语义是“我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际是多少？”</p><p>它是原子的操作</p><p>CAS是项<font color = 'blue'><em><strong>乐观锁</strong></em></font>技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><h2 id="cas引发的问题">CAS引发的问题</h2><h3 id="aba问题">ABA问题</h3><p>1、线程1 期望值为A，想更新为B</p><p>2、线程2 期望值为A，想更新为B</p><p>线程1 先执行， 但是线程2因为某种原因阻塞了，线程1将变量改成了B</p><p>这个时候线程3来了，他把变量从B 改回了 A，</p><p>线程2恢复执行，结果发现值就是A，于是 线程2 将 A改成了B，虽然线程2完成了他的操作，但是线程2并不知道发生了<font color='blue'>A-&gt;B-&gt;A </font> 的情况</p><p>解决方法，给变量加上版本标识，每次更新的时候版本标识+1；</p><p><font color='blue'>A-&gt;B-&gt;A </font>  ------&gt; <font color='blue'>A1-&gt;B2-&gt;A3 </font></p><h4 id="aba的危害">ABA的危害</h4><p>取钱，由于机器不好使，多点了几次取款操作，后台thread1， thead2工作，都是100 - 50，thread1工作成果 （100-&gt;50） ，thread阻塞，但是正好有人汇款给你（50+50=100） ，操作成功，余额变成100，这时候thread2 恢复执行，发现余额是100，继续执行100-50，于是本来余额应该是100， 结果却是50，钱没了！！！</p><h3 id="cas自旋带来的开销">CAS自旋带来的开销</h3><p>多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p><p>解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。</p><h3 id="只能保证一个共享变量的原子操作">只能保证一个共享变量的原子操作</h3><p><code>CAS</code>的原子操作只能针对一个共享变量。</p><p><strong>解决方法</strong>： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp learning</title>
      <link href="/2024/04/12/cpp/"/>
      <url>/2024/04/12/cpp/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>设计模式</p><h1 id="单例模式">单例模式</h1><p>是一种 <font color='blue'>创建型模式</font></p><p>常用到的有 <font color = 'gree'>日志模块 数据库模块</font></p><p>一个类创建对象，不管创建多少个对象，永远只能得到该类型一个对象的示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> SingleTon* <span class="title">getInstace</span><span class="params">()</span></span>&#123; <span class="comment">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> SinleTonl instance;<span class="comment">// 2. 定义唯一的类的实例对象</span></span><br><span class="line">  <span class="built_in">SingleTon</span>()&#123; <span class="comment">// 1 .构造函数私有化</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">SingleTon</span>(<span class="type">const</span> SingleTon&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SingleTon&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>; <span class="comment">//限制构造方式 只能是默认的私有构造</span></span><br><span class="line">&#125;;</span><br><span class="line">SingleTon SingleTon::instance; <span class="comment">//静态成员变量 类内声明 类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SingleTon* s1 = SingleTon::<span class="built_in">getInstance</span>();</span><br><span class="line">  SingleTon* s2 = SingleTon::<span class="built_in">getInstance</span>();</span><br><span class="line">  SingleTon* s3 = SingleTon::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是饿汉式，静态成员变量在数据段，还没调用，就直接生成了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下是懒汉式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入）</span></span><br><span class="line">  <span class="function"><span class="type">static</span> SingleTon* <span class="title">getInstace</span><span class="params">()</span></span>&#123; <span class="comment">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    instance  = <span class="keyword">new</span> <span class="built_in">SingleTon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> SinleTonl* instance;<span class="comment">// 2. 定义唯一的类的实例对象</span></span><br><span class="line">  <span class="built_in">SingleTon</span>()&#123; <span class="comment">// 1 .构造函数私有化</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">SingleTon</span>(<span class="type">const</span> SingleTon&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SingleTon&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>; <span class="comment">//限制构造方式 只能是默认的私有构造</span></span><br><span class="line">&#125;;</span><br><span class="line">SingleTon SingleTon::instance = <span class="literal">nullptr</span>; <span class="comment">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure><p>饿汉式单例模式 ：还没开始使用单例 就已经创建单例了 <font color='blue'><em><strong>线程安全</strong></em></font> 缺点 启动过程可能时间较长初始化</p><p>懒汉式单例模式 ：获取的时候才创建  不是线程安全的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全的 懒汉单例模式</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入</span></span><br><span class="line">  <span class="comment">// 加锁 保证原子性</span></span><br><span class="line">  <span class="function"><span class="type">static</span> SingleTon* <span class="title">getInstace</span><span class="params">()</span></span>&#123; <span class="comment">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class="line">    <span class="comment">// lock_guard&lt;std::mutex&gt; guard(mutex); // 锁的粒度太大了，每次获取单例都要加锁，效率低</span></span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex)</span></span>; <span class="comment">// 放小粒度，放到里面</span></span><br><span class="line">      <span class="comment">// 1.</span></span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">instance  = <span class="keyword">new</span> <span class="built_in">SingleTon</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2. instance  = new SingleTon();</span></span><br><span class="line">      <span class="comment">// 选1 还是 2 ？</span></span><br><span class="line">      <span class="comment">/* 缩小锁的粒度，就要锁 + 双重判断，否则 还是会发生竞态条件，比如选2</span></span><br><span class="line"><span class="comment">       有 A B 两个线程进来了，A，获得锁了，继续new， B未获得锁，等待</span></span><br><span class="line"><span class="comment">       A 释放锁， B获得锁，由于没有 双重判断， 导致instance又被new了一遍</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> SinleTonl *<span class="keyword">volatile</span> instance;<span class="comment">// 2. 定义唯一的类的实例对象 </span></span><br><span class="line">  <span class="built_in">SingleTon</span>()&#123; <span class="comment">// 1 .构造函数私有化</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">SingleTon</span>(<span class="type">const</span> SingleTon&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SingleTon&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>; <span class="comment">//限制构造方式 只能是默认的私有构造</span></span><br><span class="line">&#125;;</span><br><span class="line">SingleTon *<span class="keyword">volatile</span> SingleTon::instance = <span class="literal">nullptr</span>; <span class="comment">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure><p>其中 volatile 关键字 作用是为了防止cpu执行的时候加快多线程效率直接复制 instance的值，从而导致错误，加上volatile 之后，一旦有线程修改了这个值，其他线程就立马可见了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也是线程安全的懒汉单例模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleTon</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> SingleTon* <span class="title">getInstace</span><span class="params">()</span></span>&#123; <span class="comment">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class="line">    <span class="comment">// g+++ -o run singleTon.cpp gdb run</span></span><br><span class="line">    <span class="comment">// 函数静态局部变量的初始化，在汇编指令上已经自动加上线程互斥指令了</span></span><br><span class="line">    <span class="type">static</span> SingleTon instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> SinleTonl *instance;<span class="comment">// 2. 定义唯一的类的实例对象</span></span><br><span class="line">  <span class="built_in">SingleTon</span>()&#123; <span class="comment">// 1 .构造函数私有化</span></span><br><span class="line">      <span class="comment">//很多 构造代码，</span></span><br><span class="line">      <span class="comment">// 会不会有一个线程执行到一半 还没构造完成，然后有又有一个线程进来 构造？</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">SingleTon</span>(<span class="type">const</span> SingleTon&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SingleTon&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single&amp;) = <span class="keyword">delete</span>; <span class="comment">//限制构造方式 只能是默认的私有构造</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h1 id="工厂">工厂</h1><p>要工厂模式： 主要是封装了对象的创建</p><h2 id="简单工厂-simple-factory">简单工厂 Simple Factory</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Car</span>(string name): _name(name)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span>: <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Bmw</span>(string name) : <span class="built_in">Car</span>(name)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;获取一辆宝马&quot;</span> &lt;&lt; _name &lt;&lt; endl; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span>: <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BMW</span>(string name) : <span class="built_in">Car</span>(name)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;获取一辆奥迪&quot;</span> &lt;&lt; _name &lt;&lt; endl; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CarType</span>&#123;</span><br><span class="line">  BMW, AUDI</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Car* <span class="title">createCar</span><span class="params">(CarType ct)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ct)&#123;</span><br><span class="line">      <span class="keyword">case</span> BMW:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AUDI:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;para error&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Car *p1 = new Bmw(&quot;X1&quot;);</span></span><br><span class="line">  <span class="comment">// Car *p2 = new Audi(&quot;A6&quot;);</span></span><br><span class="line">  SimpleFactory *factory = <span class="keyword">new</span> <span class="built_in">SimpleFactory</span>();</span><br><span class="line">  Car *p1 = factory-&gt;<span class="built_in">createCar</span>(BMW);</span><br><span class="line">  Car *p2 = factory-&gt;<span class="built_in">createCar</span>(AUDI);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>违反了对修改封闭，对扩展开放</p><h2 id="工厂方法-factory-method">工厂方法 Factory Method</h2><p>在简单工厂上部加了一个抽象类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">BMWFactory</span><span class="params">()</span> : public Factory&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">AudiFactory</span><span class="params">()</span>: public Factory&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">OtherFactory</span><span class="params">()</span>: public Factory&#123;</span></span><br><span class="line">  <span class="comment">//对修改封闭， 对扩展开放了， 扩展 增加子类就可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂-abstract-factory">抽象工厂 Abstract Factory</h2><p>考虑产品 一类产品 一系列有关联的产品， 汽车 灯 座椅 车架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BmwLight</span>: <span class="keyword">public</span> Light&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;BMW Light&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiLight</span>: <span class="keyword">public</span> Light&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Audi Light&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法 -&gt;抽象工厂（对一组有关联关系的产品簇提供产品对象的统一创建）</span></span><br><span class="line"><span class="comment">// 把有关联的工厂方法 联合组成抽象工厂 提供多个产品的创建接口  也就是宝马的工厂不仅生产车架 也有车灯 座椅</span></span><br><span class="line"><span class="comment">// 缺点 抽象工厂的各个方法都必须实现，否则子类就还是抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>; </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Light* <span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂 ： 把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象</p><p>优点 客户不用自己创建对象，不用了解对象创建的详细过程</p><p>缺点 提供创建对象实例的接口函数不闭合 不能对修改关闭 对扩展开放</p><p>工厂方法：Factory 基类 提供一个纯虚函数（创建产品 ）定义派生类 （具体产品的工厂 ）负责创建对应的产品</p><p>优点 可以做到不同的产品，在不同的工厂创建，对修改关闭，扩展开放</p><p>缺点 实际上很多产品是有关联关系的， 属于一个产品簇，不应该放在不同的工厂进行创建，这样一不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护</p><p>抽象工厂 把有关联关系的 属于一个产品簇的所有产品的创建的接口函数，放在一个抽象工厂里面</p><p>派生类 （具体产品的工厂）应该负责创建该产品簇里面的所有产品</p><h1 id="观察者模式">观察者模式</h1><p>观察者 监听者模式（发布订阅模式） 行为型模式</p><p>主要关注的是对象的一对多的关系， 也就是多个对象都依赖一个对象，当该对象的状态发生变化时，其他对象都能接收到相应的通知</p><p>Eg： 一组数据 （数据对象） -&gt; 通过一组数据 -&gt;  曲线图（对象1） 柱状图（对象2） 圆饼图（对象3）</p><p>当数据对象改变时，对象1， 对象2 ，对象3，<font color = 'blue'>应该及时收到相应的通知！</font></p><p>Subject(主题) observer1 observer2 observer3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span> : <span class="keyword">public</span> Observer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(msgid)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer1 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer1 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer1 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> : <span class="keyword">public</span> Observer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(msgid)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer2 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer1 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer3</span> : <span class="keyword">public</span> Observer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(msgid)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer3 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer3 recv 3 msg&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;observer3 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(Observer* obser, <span class="type">int</span> msgid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//给主题 添加观察者</span></span><br><span class="line">    _subMap[msgid].<span class="built_in">push_back</span>(obser); <span class="comment">// msgid 原先有的话直接插入，没有的话会默认构造一个，然后再插入</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">despatch</span><span class="params">(<span class="type">int</span> msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//主题检测发生改变，通知相应的观察者对象处理事件</span></span><br><span class="line">    <span class="keyword">auto</span> it = _subMap.<span class="built_in">find</span>(msgid);</span><br><span class="line">    <span class="keyword">if</span>(it != _subMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">      <span class="keyword">for</span>(Observer *pObser : it-&gt;second)&#123;</span><br><span class="line">        pObser-&gt;<span class="built_in">handle</span>(msgid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, list&lt;Observer*&gt;&gt; _subMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="适配器模式">适配器模式</h1><p>结构型 模式</p><p>让不同的不兼容的接口可以在一起工作 为了避免重构代码 -&gt; 适配器模式</p><p>电脑接到投影仪 -&gt; VGA HDMI DP TypeC</p><p>类比 转接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VGA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV01</span> : <span class="keyword">public</span> VGA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过VGA接口投影&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑只支持VGA接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">playVideo</span><span class="params">(VGA *pVGA)</span></span>&#123; <span class="comment">//只支持VGA接口指针</span></span><br><span class="line">    pVGA-&gt;<span class="built_in">play</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在新进入了一批设备 支持HDMI</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HDMI</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV02</span>: <span class="keyword">public</span> HDMI&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过HDMI接口投影&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1 ： 换一个HDMI的电脑-&gt; 代码重构</span></span><br><span class="line"><span class="comment">//方法2 ： 买一个转接头-&gt; 添加 适配器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑只支持VGA 投影仪只支持HDMI 所以需要引入适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGAToHDMIAdapter</span> : <span class="keyword">public</span> VGA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VGAToHDMIAdapter</span>(HDMI *p): <span class="built_in">pHdmi</span>(p)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span>&#123; <span class="comment">//该方法相当于就是转接头，做不同接口的信号转换的</span></span><br><span class="line">pHdmi-&gt;<span class="built_in">play</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  HDMI *PHdmi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Computer c;</span><br><span class="line">  TV01 t;</span><br><span class="line">  c.<span class="built_in">playVideo</span>(&amp;t);</span><br><span class="line">  c.<span class="built_in">playViceo</span>(<span class="keyword">new</span> <span class="built_in">VGAToHDMIAdapter</span>(<span class="keyword">new</span> <span class="built_in">TV02</span>()));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="代理模式">代理模式</h1><p>结构型模式 Proxy 通过代理类，来控制实际对象（委托类）的访问权限</p><p>客户  助理Proxy 老板（委托类）</p><p>​客户和老板之间的权限控制</p><p><font color ='blue'>功能都是 委托类实现的， 代理类只是权限控制， 两者是组合关系</font></p><p>客户直接访问的是代理对象，由代理对象和委托类实现不同客户的功能权限控制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//免费电影</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// VIP电影</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMoveie</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 用券观看的电影</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span><span class="title class_">MyVideoSite</span>: <span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span>&#123; <span class="comment">//免费电影</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;观看免费电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span>&#123; <span class="comment">// VIP电影</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;观看VIP电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMoveie</span><span class="params">()</span></span>&#123; <span class="comment">// 用券观看的电影</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;观看券电影&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeVideoSiteProxy</span> : <span class="keyword">public</span> VideoSite&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">FreeVideoSiteProxy</span>()&#123;</span><br><span class="line">    pVideo = <span class="keyword">new</span> <span class="built_in">MyVideoSite</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">FreeVideoSiteProxy</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> pVideo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span>&#123; <span class="comment">//免费电影</span></span><br><span class="line">    pVideo-&gt;<span class="built_in">freeMovie</span>(); <span class="comment">// 通过代理对象的freeMovie， 来访问真正委托类对象的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span></span>&#123; <span class="comment">// VIP电影</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无权限&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMoveie</span><span class="params">()</span></span>&#123; <span class="comment">// 用券观看的电影</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无券&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">VideoSite *pVideo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VIPVideoSiteProxy</span> : <span class="keyword">public</span> VideoSite&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VIPVideoSiteProxy</span>()&#123;</span><br><span class="line">    pVideo = <span class="keyword">new</span> <span class="built_in">MyVideoSite</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">FreeVideoSiteProxy</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> pVideo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span></span>&#123;<span class="comment">//免费电影</span></span><br><span class="line">    pVideo-&gt;<span class="built_in">freeMovie</span>(); <span class="comment">// 通过代理对象的freeMovie， 来访问真正委托类对象的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span><span class="comment">// VIP电影&#123;</span></span></span><br><span class="line"><span class="function">    pVideo-&gt;<span class="title">vipMovie</span><span class="params">()</span></span>;<span class="comment">// 通过代理对象的vipMovie， 来访问真正委托类对象的方法</span></span><br><span class="line">&#125; </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMoveie</span><span class="params">()</span></span>&#123; <span class="comment">// 用券观看的电影</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无券&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">VideoSite *pVideo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="装饰器模式">装饰器模式</h1><p>Decorator 结构型模式</p><p><em><strong>装饰器 主要是增加现有类的功能</strong></em>， 但是增加现有类的功能还有一个方法 就是新增加一个子类 -&gt; 导致类的数量非常多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123; <span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//三个实体汽车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BWM 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AUDI</span> :<span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Audi 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span>:<span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Benz 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//装饰器 1 定速巡航</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator01</span>: <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteDecorator01</span>(Car *p): <span class="built_in">pCar</span>(p)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cour &lt;&lt; <span class="string">&quot;定速巡航&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自动刹车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator02</span>: <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteDecorator02</span>(Car *p): <span class="built_in">pCar</span>(p)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cour &lt;&lt; <span class="string">&quot;自动刹车&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//车道偏离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator03</span>: <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteDecorator03</span>(Car *p): <span class="built_in">pCar</span>(p)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cour &lt;&lt;<span class="string">&quot;车道偏离&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Car* pCar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2024/04/12/Docker/"/>
      <url>/2024/04/12/Docker/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>remain</title>
      <link href="/2024/04/12/remain/"/>
      <url>/2024/04/12/remain/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库-redis</title>
      <link href="/2024/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93-redis/"/>
      <url>/2024/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="why-redis？">Why redis？</h1><p>redis 是什么？ 是一种开源的、基于内存的数据结构存储系统，通常用作数据库缓存， <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver</p><p>磁盘IO的时间在10ms左右， 而内存的读写时间是100us左右，所以如果能把经常访问的数据放在内存中， 能够极大提高服务器对客户端的响应速度 – 缓存</p><p>那么加了缓存有什么缺点？？</p><ul><li>数据一致性问题</li><li>页面换入换处 - 也就是数据项的更新</li></ul><h2 id="memcache-vs-redis">Memcache vs redis</h2><ul><li><p>redis支持更多的数据结构</p></li><li><p>redis内存利用率高，对于简单的k-v 存储，memcache的利用率高</p></li><li><p>redis 是单核的 支持原生的集群模式</p></li></ul><h2 id="redis持久化">redis持久化</h2><h4 id="rdb-和aof-持久化">RDB 和AOF 持久化</h4><p>简单来说RDB：就是将Redis中的数据，每个一段时间，进行数据持久化</p><p>Redis将内存中的数据，存放到一个AOF文件中，但是因为Redis只会写一个AOF文件，因此这个AOF文件会越来越大。</p><p>AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在Redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集</p><p>AOF rewrite 压缩</p><p>RDB 实时性较差 AOF需要定时rewrite压缩，缺点就是恢复数据的时候比较慢，</p><p>一般是RDB + AOF混着用</p><h2 id="redis的线程模型">redis的线程模型</h2><p>类似一muduo库，一个主loop负责监听事件，然后分发给对应的事件处理器</p><h4 id="为什么单线程模型效率这么高？">为什么单线程模型效率这么高？</h4><ul><li>纯内存操作</li><li>核心是非阻塞的IO多路复用</li><li>单线程反而不用考虑多线程的上下文切换问题</li></ul><h2 id="redis的过期策略">redis的过期策略</h2><p>定期删除和惰性删除</p><h1 id="redis的高并发和高可用">redis的高并发和高可用</h1><p>高并发：主从架构，一主多从，主负责写入，单机几万的QPS， 从负责查询，多个从可以提10万的QPS</p><p>高可用：哨兵，任何一个实例宕机，自动进行主备切换</p><p>单机读写分离 + 主从架构 = 支撑10万+qps读的操作</p><h2 id="redis主从架构">redis主从架构</h2><ul><li>redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量</li><li>一个master node是可以配置多个slave node的</li><li>slave node也可以连接其他的slave node</li><li>slave node做复制的时候，是不会block master node的正常工作的</li><li>slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</li><li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</li><li>写操作存放在master node，同时在异步把master上的信息，同步到每个slave node上。</li></ul><h3 id="master持久化对于主从架构的安全保障的意义">Master持久化对于主从架构的安全保障的意义</h3><p>maste必须开启持久化，不能只靠salve node作为master node的数据热备份， 因为这样的话，master如果宕机了，也没有持久化，master就会认为数据是空的，从而去同步所有的salve node，把slave node数据也给丢掉了</p><p>第二个，master的各种备份方案，要不要做？<mark> 要做!</mark>万一说本地的所有文件丢失了; 从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的</p><p>即便用了 后续的高可用机制， slave node可以自动接管master node，但是可能sential还未检测到master 宕机，master就自动重启了，还是导致素有的slave node数据被清空</p><h3 id="主从复制原理">主从复制原理</h3><p>当启动一个slave node的时候，它会发送一个PSYNC命令给 master node，</p><ul><li>如果是salve node 重新连接master node，那么master node只会复制给slave部分缺少的数据(<font color='blue'>如何判断缺少与否？？</font>)</li><li>第一次连接到 master node ，full resynchronization</li></ul><p>full resynchronization，master会启动一个后台线程，开始生产一份RDB快照，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p><p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p><h3 id="主从复制的断点续传">主从复制的断点续传</h3><p>主从复制过程中，网络连接断掉了，可以接着上次复制的地方，继续复制下去，而不是从头复制一份，</p><p>slave保存一个replica offset 还有一个master id， offset保存在backlog中，如果复制过程中master和slave断开链接了，那么slave会从上次的replica开始继续复制，但是如果没有找到对应的offset，就会执行一次full resynchronization</p><h3 id="redis-主从复制的完整复制流程">Redis 主从复制的完整复制流程</h3><ol><li><p>salve node 启动，只有master node的信息，<font color='blue'> host + ip</font>,</p><blockquote><p>但是复制流程没开始hots ip哪里来的，redis.conf 中的slaveof 配置的</p></blockquote></li><li><p>slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket网络连接</p></li><li><p>slave node发送ping命令给master node</p></li><li><p>口令认证，如果master设置了requirepass，那么salve node必须发送masterauth的口令过去进行认证</p></li><li><p>master node第一次执行全量复制，将所有数据发给slave node</p></li><li><p>master node后续持续将写命令，异步复制给slave node</p></li></ol><h4 id="复制模式">复制模式</h4><h5 id="同步复制">同步复制</h5><p>在同步复制模式下，主节点在执行写操作之前会等待至少一个从节点确认接收到该命令后才继续执行。主节点会将写操作命令发送给从节点，并等待从节点的回复确认。</p><p>优点 数据一致性</p><p>缺点 影响性能，并且如果子节点因为故障无法回复，就会导致子节点阻塞住</p><h5 id="异步复制">异步复制</h5><p>在异步复制模式下，主节点将写操作命令发送给从节点，但不等待从节点的确认。主节点发送命令后即可继续处理其他命令，不会阻塞在复制过程上。</p><p>优点 响应快</p><p>缺点</p><ul><li>数据一致性无法保证</li><li>如果从节点发生故障或者延迟，写操作可能会在从节点上丢失</li></ul><h2 id="哨兵模式-sentinel">哨兵模式（sentinel）</h2><p>在sential 模式下， 有一下几个关键角色：</p><ul><li>master，</li><li>slave，</li><li>sentinel：负责监控主节点和从节点的健康状态，以及执行故障转移操作，哨兵有多个，形成一个哨兵集群 <font color='blue'> 哨兵节点最少3个，且集群数量为奇数，因要避免单点，且故障转移中涉及到选举，避免产生平局。</font></li></ul><h3 id="异常节点自动替换">异常节点自动替换</h3><h4 id="从节点异常">从节点异常</h4><p>sentinel定期给从节点发送<code>INFO</code> 命令，salve 回复自己的信息，包括复制偏移量、连接数等等，通过分析这些信息，sentinel可以判断slave的健康状态。</p><p>当slave被标记为下线（S_DOWN主观下线）时，检测到的哨兵会通知其他哨兵，共同确认节点的下线状态，多个哨兵确认从节点不健康时（客观下线），哨兵节点会将其从主节点的复制列表中移除，并将其从其他从节点的复制列表中移除。这样，异常从节点将不再接收主节点的复制数据，并且不再被其他从节点复制。当从节点状态恢复，哨兵节点会将其重新添加到主节点的复制列表中，并将其作为其他从节点的复制源。这样，从节点可以继续复制主节点的数据。</p><blockquote><p>主观下线：<font color='blue'>自己（sentinel）认为这个slave掉线了</font></p><p>客观下线：<font color='green'>多个哨兵都认为节点掉线了</font></p></blockquote><h4 id="主节点异常">主节点异常</h4><p>sentinel会定期给master 发送<code>PING</code>命令来检测心跳，如果心跳丢失，则哨兵会标记主节点为S_DOWN 主观下线</p><p>当主节点被标记为S_DOWN的时候，哨兵会通知其他哨兵，多个哨兵会共同确认master的下线状态，如果多数节点认为mater下线（客观下线），会进行一次选举，从slave中选出master，同时修改其余从节点的配置，将新的主节点作为数据同步的来源，然后重启服务，完成切换</p><h4 id="选举election">选举election</h4><p>根据所有slave的优先级 复制进度 运行ID来选出新的master</p><p>选举 先看优先级 再看复制进度 最后看运行ID</p><p>也就优先级一样，复制进度快的作为master</p><p>复制进度一样 ID小的作为master</p><blockquote><p>什么是复制进度？主从架构中，主节点会将写操作同步给从节点，在这个过程中，主节点会用 master_repl_offset(复制偏移量) 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从节点会用 slave_repl_offset 这个值记录当前的复制进度</p><p>如果某个从节点的 slave_repl_offset 最接近 master_repl_offset，说明它的复制进度是最靠前的，于是就可以将它选为新主节点。</p></blockquote><h4 id="主从切换过程">主从切换过程</h4><ol><li>选出新master之后，sentinel会向被选中的节点发送<code>SLAVEOF no one</code>命令，解除其从节点身份，变成新的主节点</li><li>发送命令之后，哨兵以每秒一次的频率发送<code>INFO</code>命令，并且观察其回复信息中的角色是否有由slave升级为master</li><li>是则哨兵向所有slave发送<code>SLAVEOF</code>,让他们成为新的master的slave</li><li>当旧的master重启时， 哨兵发送<code>SLAVEOF</code>，让其成为新的master的slave</li></ol><h4 id="哨兵集群组成">哨兵集群组成</h4><p>在配置哨兵集群的信息时，哨兵配置中，只需要填写主节点的相关信息，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br></pre></td></tr></table></figure><p>哨兵之间使用过 发布/订阅来实现的，master 有一个 <code>__sentinel__:helllo</code>的频道，所有哨兵都会订阅这个，有哨兵需要加入集群的时候，就会向这个频道发送 自己的IP + PORT， 这样就可以加入集群</p><p><mark>哨兵集群通过向主节点发送INFO命令，获取从节点信息。</mark> 然后根据获取的信息，可以和子节点slave建立连接，并监控子节点的健康状态</p><h4 id="什么是脑裂？？">什么是脑裂？？</h4><p>一主多从，当master从正常网络脱离开，但是master实际上还是在工作，于是他还在处理客户端的请求，但是哨兵检测不到他，然后哨兵选举出新的节点，有两个master（脑裂了），这时新的master无法接受到客户端的写请求，这个时候网络好了，新的master存在，旧的master被哨兵设置为slave，发生全量同步，这个时候客户端向这个旧masater写入的数据就全部丢掉了</p><p>解决方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>要求至少有一个slave，数据复制和同步的延迟不能超过10s。</p><p>如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了，上面两个配置可以减少异步复制和脑裂导致的数据丢失</p><h2 id="集群模式cluster-mode">集群模式cluster mode</h2><p><mark> 多主多从 </mark></p><p>Redis Cluster 是 Redis 的分布式解决方案，集群通过分片（sharding）模式来对数据进行管理，并具备分片间数据复制、故障转移和流量调度的能力</p><ul><li>分布式架构，数据分布在多个节点上，每个节点负责管理一部分数据槽位，集群中一共有16384个槽位，每个槽位对应一个数据片段，通过数据分布在多个节点，可以支撑数据的<font color='blue'>负载均衡和横向扩展</font></li><li>主从复制, 每个主节点可以有一个或者多个从节点，主节点负责处理客户端请求和写入，从节点复制主节点的数据，负责处理读取操作，主从复制提供了数据的<font color='blue'>冗余备份和故障恢复</font></li><li>故障转移 主节点故障的时候，会从从节点选举出新的主节点</li><li>握手 当客户端连接到cluster的时候， 会进行一次握手，通过集群的节点间通信，客户端会获取到集群的拓扑结构信息，包括节点的IP地址和端口号，以及槽位的分配情况。这样客户端就可以直接与正确的节点进行通信。</li><li>槽位迁移，在Redis Cluster中，槽位的分配是动态的。当节点加入或离开集群时，槽位会进行重新分配和迁移。槽位迁移是逐个槽位进行的，节点之间会进行数据传输和同步，以保证数据的一致性。</li><li>客户端路由，Redis Cluster提供了客户端路由功能，客户端可以根据数据的Key来计算槽位，并将请求发送到对应的节点。客户端路由可以实现请求的负载均衡，以及自动发现和适应集群拓扑变化。</li></ul><p><mark> 创建集群至少需要三个主节点</mark> 3 个从节点 ，所以最少是6个节点</p><h2 id="hash-slot">hash slot</h2><p>hash slot 是对数据进行分片的单元，redis cluster 将数据划分为16384个哈希槽（0～16383）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，每个槽位对应一个数据片段，槽位的数量是固定的</p><p>cluster通过对key应用hash函数 （CRC16）计算出一个哈希值，将hash值对16384取模得到槽位编号，槽位编号确定了数据属于哪个槽位。</p><p><strong>注：哈希槽必须全部被分配，若有一个槽位没有正常分配，则整个集群都不可用。</strong></p><p><strong>哈希槽的划分：</strong></p><p>在 Redis Cluster 中，每个键根据其键名进行哈希计算，并被映射到这些哈希槽中的一个。</p><ol><li>初始状态：当创建一个 Redis Cluster 时，所有的哈希槽都是未分配的状态，没有任何键被映射到特定的哈希槽上。</li><li>添加节点：当添加主节点到 Redis Cluster 时，每个<mark>主节点</mark>会负责处理一部分哈希槽。Redis Cluster 会根据主节点的数量平均分配哈希槽。例如，如果有 3 个主节点，每个主节点将负责处理大约 1/3 的哈希槽。<font color='blue'> 也就是每个主从对 负责维护一部分数据，这样多机器就可以实现横向扩容，分布式存储，从是主的备份，同时也对外提供读请求的处理功能</font></li><li>哈希槽迁移：当节点加入或离开集群时，集群会自动进行哈希槽的迁移。迁移的目的是将哈希槽从一个节点转移给另一个节点(从一个主 移动到 另外一个主），以实现数据的均衡分布。迁移过程中，集群会自动将相关的键从一个节点复制到另一个节点，并在迁移完成后更新映射关系。<ul><li>当添加新节点时：集群会将一部分哈希槽从现有节点迁移到新节点上。</li><li>当删除节点时：集群会将被删除节点上负责的哈希槽迁移到其他节点上，确保数据的可用性。</li></ul></li><li>客户端请求路由：一旦哈希槽分配完成，客户端的请求将根据键名的哈希值被路由到相应的节点。集群会根据请求中的键名计算哈希值，并将请求发送到负责该哈希槽的节点上进行处理。</li></ol><p>哈希槽的映射：</p><p>在 Redis Cluster 中，哈希槽（slots）与键的映射是通过对键名进行哈希计算来实现的。Redis 使用 CRC16 算法对键名进行哈希计算，并将计算结果对 16384（2^14）取模，得到对应的哈希槽。</p><ol><li>哈希计算：对于要存储到 Redis Cluster 的每个键，使用 CRC16 算法对键名进行哈希计算。这个哈希计算过程会生成一个 16 位的无符号整数。</li><li>取模运算：将哈希计算结果对 16384（2^14）取模，得到一个范围在 0 到 16383 的整数。这个结果就是键对应的哈希槽。如：哈希计算结果为 12345，那么对 16384 取模的结果为 12345 % 16384 = 12345，键就被映射到哈希槽 12345。</li><li>哈希槽分配：根据哈希槽的映射结果，将键存储在相应的哈希槽中。Redis Cluster 中的每个主节点都负责处理一部分哈希槽，主节点会根据哈希槽的分配情况进行数据存储和处理。</li></ol><blockquote><p>哈希槽的划分和映射是 Redis Cluster 在集群创建、主节点加入或离开时自动完成的，不需要手动操作。只有在特殊情况下，如手动划分哈希槽或进行特定的数据迁移时，才需要关注和操作哈希槽的映射关系</p><p><mark> 哈希槽只分布在主节点上，从节点没有哈希槽</mark></p></blockquote><h2 id="主从复制">主从复制</h2><p>原理一致</p><h2 id="集群间节点通信-心跳机制">集群间节点通信/心跳机制</h2><p>分布式存储集群需要提供维护节点元数据信息(节点信息，节点数据，节点状态等)的机制，常见的有集中式和P2P方式。</p><ol><li><p>集中式元数据维护方式：</p><p>在集中式方式中，有一个中心化的元数据管理节点（通常称为元数据服务器或元数据中心），负责管理和维护系统的元数据信息。其他节点通过与元数据服务器的交互来获取和更新元数据。</p><ul><li>优点：集中式元数据管理方便集中控制和维护，元数据的一致性和准确性相对容易保证。对于一些需要集中决策或控制的操作，集中式方式更为适用。</li><li>缺点：集中式元数据服务器可能成为系统的单点故障，一旦元数据服务器发生故障，整个系统的元数据访问和更新都会受到影响。此外，集中式方式的可扩展性和容错性可能较差。</li></ul></li><li><p>P2P元数据维护方式：</p><p>在P2P方式中，每个节点都具有一份或部分的元数据信息，并通过节点之间的相互通信来交换和同步元数据。所有节点都是对等的，没有中心化的元数据管理节点。</p><ul><li>优点：P2P方式避免了中心化的 <font color='red'>单点故障</font>，提高了系统的容错性和可用性。每个节点都具有元数据信息的副本，可以快速获取和更新元数据，减少了对中心节点的依赖。</li><li>缺点：P2P方式的元数据<mark>一致性</mark>较难保证，节点之间的同步和通信需要额外的开销。同时，P2P方式可能在某些操作上缺乏集中控制和决策的能力。</li></ul></li></ol><p><mark> cluster使用的P2P方式，采用的gossip协议实现，去中心化</mark></p><h3 id="gossip协议">gossip协议</h3><h4 id="1-节点选择">1.节点选择</h4><p>每个节点在固定的时间间隔内选择一些其他节点来通信，选择的节点可以是随机选择或者是基于某种算法进行选择</p><p>通过单独的TCP通道来进行通信</p><h4 id="2-信息交换">2.信息交换</h4><p>节点之间进行信息交换， 节点的IP地址 端口号，槽位分配信息，故障检测信息</p><h4 id="3-消息传播">3.消息传播</h4><p>接受到消息的节点会将消息传播给其他节点，从而实现信息在整个集群中的扩散（<mark>泛洪？</mark>)</p><p>每个节点会维护一份已知的节点列表，将收到的消息发给列表中的其他节点</p><h4 id="4-故障检查">4.故障检查</h4><p>节点通过Gossip协议实时地了解其他节点的状态，包括存活，故障或者重新上线</p><p>当节点检测到其他节点故障的时候，将故障消息广播给集群中的其他节点，以便进行故障转移和恢复操作。<mark>投票问题</mark></p><h4 id="5-节点状态更新">5.节点状态更新</h4><p>节点接受到了其他节点的消息之后，会更新自己维护的节点信息</p><p>节点可能会更新其他节点的状态，增加或者删除节点，以反映整个集群的最新状态</p><p><font color='blue'>Gossip协议的优点之一是它的去中心化性质，每个节点都可以主动地向其他节点传播信息，无需集中的协调者。这种去中心化的设计使得Gossip协议具有较好的可扩展性和容错性，能够适应大规模分布式系统中的节点动态变化和故障情况。</font></p><h4 id="消息类型">消息类型</h4><p>常用的Gossip消息可分为： <code>ping</code>消息、 <code>pong</code>消息、 <code>meet</code>消息、<code> fail</code>消息等。</p><ul><li><strong>ping</strong>：ping 消息是用于探测其他节点是否存活和可达的消息。当一个节点发送 Ping 消息给其他节点时，它期望收到 Pong 消息作为回复，以确认目标节点的存活状态。</li><li><strong>pong</strong>：pong 消息是对 Ping 消息的回复，用于确认节点的存活状态。当一个节点收到 Ping 消息时，会发送 Pong 消息给发送方，表明自己是存活的。</li><li><strong>meet</strong>：meet 消息是用于节点之间建立联系和发现新节点的消息。当一个节点想要加入到分布式系统中时，它可以发送 Meet 消息给一个已知的节点(可能是从默认的配置文件中找到节点的IP+Port)，请求与其建立联系。通过 Meet 消息的交换，新节点可以与现有节点建立连接并进一步扩展整个集群。</li><li><strong>fail</strong>：fail 消息是用于通知其他节点某个节点的故障或不可用状态的消息。当一个节点检测到另一个节点发生故障时，它可以发送 Fail 消息给其他节点，以便其他节点能够感知到该节点的状态，并采取相应的措施，如从集群中移除故障节点。</li></ul><h2 id="请求路由">请求路由</h2><p>类似于http协议的重定向，客户端直接链接的节点，可能并不负责这次请求的key，也就是这个key 的hash slot 不在当前这个节点上，需要重定向到新的节点</p><h2 id="故障转移">故障转移</h2><p>故障节点发现与自动替换：</p><ol><li>故障节点检测：每个节点通过 Gossip 协议与其他节点进行周期性的消息交换。当一个节点在一定时间内（ cluster-node-timeout ）没有收到来自主节点的消息时，它会将该主节点标记为疑似下线（pfail状态，即主观下线）。</li><li>疑似下线节点确认：节点向其他节点发送确认消息，询问它们是否也认为该主节点处于疑似下线状态。</li><li>多数派确认：如果大多数节点都确认了该主节点的疑似下线状态，那么该主节点会被标记为fail状态（客观下线）。</li><li>故障转移决策：客观下线的主节点会触发故障转移决策。集群中的其他节点会根据一定的算法和规则，从该主节点的从节点中选举出一个新的主节点。</li><li>新主节点选举：新的主节点会被选举并接管故障主节点的槽。选举过程中通常采用 Raft 算法或者其他一致性算法来保证选举的正确性和一致性。</li><li>数据重平衡：一旦新的主节点选举完成，集群会开始进行数据重平衡，将原先属于故障主节点的槽重新分配给新的主节点，并确保数据的一致性。</li></ol><h1 id="redis如何作为mysql的缓存？">redis如何作为mysql的缓存？</h1><p>mysql查询返回的是一个结果集合，</p><p>对查询语句计算MD5得到key， 然后保存结果，是否会导致缓存命中率不高？</p><p>string-map， 表名+ID 作为key 值作为val；</p><h1 id="缓存击穿和雪崩-穿透">缓存击穿和雪崩、穿透</h1><h3 id="击穿">击穿</h3><p>某个热点缓存失效，大量的请求直接打到数据库</p><p>解决：</p><ol><li><p><strong>缓存预热</strong>：在缓存失效前，提前重新加载数据，避免热点数据失效。</p></li><li><p><strong>互斥锁</strong>：使用分布式锁（例如 Redis 分布式锁）来控制只有一个请求可以去数据库加载数据并刷新缓存，其他请求等待锁释放后直接从缓存读取。</p></li><li><p><strong>永不过期策略</strong>：对热点数据设置成永不过期，并通过异步任务去定期更新缓存。</p></li></ol><h3 id="雪崩">雪崩</h3><p>大量缓存同时失效，或者redis数据库寄了，导致数据库也收到了大量的访问请求</p><p>解决方法：</p><ol><li><p><strong>缓存失效时间随机化</strong>：在设置缓存的过期时间时，加上一个随机值，避免大量缓存同时失效。</p></li><li><p><strong>逐渐失效策略</strong>：将缓存的失效时间分散在不同时段，避免集中失效。</p></li><li><p><strong>双层缓存</strong>：使用多级缓存，第一层缓存失效后请求从第二层缓存获取，给数据库更多的缓冲时间。</p></li></ol><h4 id="如果是redis数据库寄了-怎么办？">如果是redis数据库寄了，怎么办？</h4><ul><li>服务熔断机制，拒绝所有请求，或者只放一部分请求进mysql，等到redis服务重启之后，在重新开启服务</li><li>使用集群模式 主从</li></ul><h3 id="穿透">穿透</h3><p>用户要访问的数据既不在缓存中，又不在数据库中，<mark>那在哪里？？？</mark></p><p>说明数据丢失了，</p><ul><li>业务误操作，删除了</li><li>被黑客恶意攻击，故意访问大量不存在的数据</li></ul><p>解决方法</p><ul><li>非法请求的限制</li><li>缓存空值或者默认值，如果穿透了，就直接返回空/default，这样就不会再继续查询数据库了</li><li>使用布隆过滤器快速判断数据是否存在，从而避免查询数据库</li></ul><h1 id="什么是布隆过滤器？">什么是布隆过滤器？</h1><p>布隆过滤器（Bloom Filter）是一种空间效率极高的数据结构，用于测试一个元素是否在一个集合中。它的设计目标是用来处理可能性测试的问题，尤其是在需要处理大规模数据时。布隆过滤器能够提供快速的“可能存在”测试，<font color='blue'>但可能会有一些误报。</font></p><h3 id="基本概念">基本概念</h3><p>布隆过滤器有以下几个主要特性：</p><ol><li><strong>空间效率</strong>：布隆过滤器的主要优点是其空间效率。在存储大量数据时，它比其他数据结构（如哈希表、集合等）要节省空间。</li><li><strong>时间效率</strong>：对元素的查询操作非常快速。</li><li><strong>可能的误报</strong>：布隆过滤器可能会错误地报告某个元素存在，但绝不会错误地报告某个元素不存在。也就是说，它的假阳性率（false positive rate）是可控的，但假阴性率（false negative rate）为零。</li></ol><h3 id="工作原理">工作原理</h3><p>布隆过滤器使用了多个哈希函数和一个位数组来实现其功能。具体步骤如下：</p><ol><li><strong>初始化</strong>：<ul><li>创建一个位数组（bit array），所有位初始化为0。</li><li>选择多个哈希函数，每个哈希函数将元素映射到位数组中的一个位置。</li></ul></li><li><strong>添加元素</strong>：<ul><li>对每个要添加的元素，使用多个哈希函数计算出多个索引位置。</li><li>将这些索引位置对应的位在位数组中设置为1。</li></ul></li><li><strong>查询元素</strong>：<ul><li>对要查询的元素，使用相同的哈希函数计算出多个索引位置。</li><li>检查这些索引位置对应的位是否都是1。</li><li>如果所有位置的位都是1，布隆过滤器报告元素可能存在<mark>(因为可能存在哈希冲突，不同的key可能设置了同样的位置为1）</mark>；如果有任何一个位置的位为0，布隆过滤器报告元素一定不存在。</li></ul></li></ol><h3 id="误报率">误报率</h3><p>布隆过滤器的误报率与位数组的大小、哈希函数的数量以及元素的数量有关。误报率是可以通过调整这些参数来控制的：</p><ul><li><strong>位数组的大小</strong>：越大，误报率越低。</li><li><strong>哈希函数的数量</strong>：增加哈希函数的数量可以减少误报率，但会增加计算开销。</li></ul><h3 id="优缺点">优缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>节省空间</strong>：相比其他数据结构，布隆过滤器占用的空间更少。</li><li><strong>快速查询</strong>：查询操作时间复杂度为 O(k)，其中 k 是哈希函数的数量。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>可能的误报</strong>：布隆过滤器可能会误判元素存在。</li><li><strong>无法删除元素</strong>：标准的布隆过滤器无法删除已经添加的元素，因为删除操作可能会影响到其他元素的查询。</li></ul><h3 id="应用场景">应用场景</h3><p>布隆过滤器广泛应用于各种需要高效集合测试的场景，比如：</p><ul><li><strong>数据库系统</strong>：在进行磁盘或网络查找之前，用于减少不必要的查询。</li><li><strong>缓存系统</strong>：用来检查缓存中是否可能包含某个对象，以减少缓存失效的开销。</li><li><strong>网络爬虫</strong>：检测网页是否已被访问过，防止重复抓取。</li></ul><h3 id="例子">例子</h3><p>假设你有一个布隆过滤器，用来检查某个数字是否在一个大数据集中。你使用三个哈希函数，将每个数字映射到位数组的三个不同位置。例如，数字 42 经过三个哈希函数后可能会映射到位数组的索引 5、12 和 33。这些位置的位被设置为 1。当你查询数字 42 是否存在时，布隆过滤器会检查这些位置的位是否都是 1，如果是，它就报告数字 42 可能存在；如果其中任何一个位置的位是 0，它就报告数字 42 一定不存在。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os learning</title>
      <link href="/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="进程">进程</h1><h1 id="总线与外部设备">总线与外部设备</h1><h2 id="为什么要有总线？">为什么要有总线？</h2><p>各种设备 单独连线的复杂度 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">C_{n}^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>的，设备一多，复杂度起飞， 也不利于扩展 -&gt; 总线</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序方法 总结</title>
      <link href="/2024/04/12/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2024/04/12/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>总结一下各种排序方法 和模版<br>主要包括 快速排序，归并排序，冒泡排序，堆排序，希尔排序<br>以及sort函数的自定义比较函数的使用</p><h2 id="快速排序-升序排序">快速排序 升序排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l, j = r; <span class="comment">//这里选择哨兵是最左边的元素，</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--; <span class="comment">// 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 &lt; nums[l] 的元素</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++; <span class="comment">// 这样 循环外的 swap（nums[l], nums[j]) 才是对的；</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">quicksort</span>(nums, l, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(nums, j + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>降序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l, j = r; <span class="comment">//这里选择哨兵是最左边的元素，</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &lt;= nums[l]) j--; <span class="comment">// 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 &lt; nums[l] 的元素</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &gt;= nums[l]) i++; <span class="comment">// 这样 循环外的 swap（nums[l], nums[j]) 才是对的；</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">quicksort</span>(nums, l, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(nums, j + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure><p>快速排序的特殊用途<br>在o(n)的时间复杂度下得出第k小的数<br>方法 由于哨兵就是分界点，某次递归的时候发现哨兵的位置i就是k，那么说明当前位置的哨兵就是第k小的值</p><blockquote><p>空间复杂度 <mark style="background-color: yellow;">o(1)</mark><br>平均时间复杂度 <mark style="background-color: yellow;">o(nlogn)</mark><br>最坏情况复杂度 <mark style="background-color: yellow;">o(n2)</mark> 每次都选中了最小的 或者最大的</p></blockquote><h2 id="归并排序">归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merged_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merged_sort</span>(nums, temp, l, m);</span><br><span class="line">    <span class="built_in">merged_sort</span>(nums, temp, m+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并过程, 递归下去的时候两部分已经弄好了，所以需要使用temp 来保存</span></span><br><span class="line">    <span class="comment">// 有序的左右2part， nums用于返回排序好的部分</span></span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class="line">        temp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m+<span class="number">1</span>)&#123;</span><br><span class="line">            nums[k] = temp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r || temp[i] &lt;= temp[j])&#123;</span><br><span class="line">            nums[k] = temp[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums[k] = temp[j++]; <span class="comment">// ====求逆序数在这统计即可======</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的特殊用途：</p><ul><li>归并排序的特殊用途， 求逆序数 ，但是不能用于求每个位置的逆序数，只能求逆序数的总和</li><li>在注释的位置加上统计操作，返回统计结果就可以了</li><li>求每个位置的逆序数需要使用树状数组，树状数组也可以求逆序数的和</li></ul><blockquote><p>空间复杂度 o(N);<br>平均时间复杂度 o(nlogn)<br>最坏情况复杂度 o(nlogn)</p></blockquote><h2 id="冒泡排序">冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> swapped; <span class="comment">// 标记是否发生交换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果本轮没有发生交换，则数组已经有序，可以提前结束</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度 <mark style="background-color:yellow"> o(n2) </mark><br>空间复杂度 <mark style="background-color:yellow"> o(1) </mark></p></blockquote><h2 id="堆排序">堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i; <span class="comment">// 将当前节点标记为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点的索引</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出当前节点、左子节点和右子节点中的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是当前节点，则将最大值与当前节点交换，并递归调整</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums, i, largest);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆，从最后一个非叶子节点开始向上调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次将堆顶元素与末尾元素交换，并调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="number">0</span>, i); <span class="comment">// 将堆顶元素（最大值）与当前末尾元素交换</span></span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, <span class="number">0</span>); <span class="comment">// 调整堆，使剩余部分重新成为最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>空间复杂度 <mark style="background-color:yellow"> o(1) </mark><br>平均时间复杂度 <mark style="background-color:yellow"> o(nlogn) </mark><br>最坏时间复杂度 <mark style="background-color:yellow"> o(nlogn) </mark></p><p><em><strong>它的性能表现良好，在实践中通常比较高效，尤其适用于大型数据集。然而，堆排序的主要缺点是不稳定性，即相同值的元素在排序后可能会改变相对顺序。</strong></em></p></blockquote><h2 id="希尔排序">希尔排序</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组专题</title>
      <link href="/2024/04/09/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/"/>
      <url>/2024/04/09/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>树状数组 BIT 也叫fenwick tree</p><h2 id="用途">用途</h2><p>支持单点更新<br>前缀和查询</p><p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240815113727.png" alt=""></p><hr><p>对比前缀和数组</p><table><thead><tr><th>属性</th><th>前缀和数组</th><th>bit</th></tr></thead><tbody><tr><td>求区间和</td><td>O(1)</td><td>O(logn)</td></tr><tr><td>单点更新</td><td>O(n)</td><td>O(logn)</td></tr></tbody></table><h3 id="推导">推导</h3><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>13</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1101</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(13)_2=(1101)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">3</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>13</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1000</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>100</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><msub><mo stretchy="false">)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">(13)_2=(1000)_2 + (100)_2 + (1)_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">3</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>思想来源： 一个数字一定可以在<code>O(logn)</code>时间内拆分成<code>logn</code>个和</p><p>所以 树状数组就是 在设计一种组合方式 使得每个数组 都可以在 log2n的时间复杂度内 更新或者求和 ，也就是树的高度是 log2n</p><h2 id="使用场景">使用场景</h2><p>任何需要使用前缀和，或者操作存在逆元的 区间和 （加减 乘除 区间xor和， 模质数意义下的区间乘积）</p><p>树状数组的区间和其实是两次前缀和的查询，右端点的前缀和结果对做边的前缀结果取 逆元操作，</p><p>Eg：求区间逆序数</p><h2 id="模版">模版</h2><p>先构造中间数组 （离散化）</p><p>使用中间数组 构建bit</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">BIT</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; Bit;</span><br><span class="line">    <span class="built_in">BIT</span>(<span class="type">int</span> size)&#123;</span><br><span class="line">        m_size = size;</span><br><span class="line">        Bit = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (m_size+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> del)</span></span>&#123; <span class="comment">//delta 是变化的值</span></span><br><span class="line">        <span class="comment">//更新当前节点和 父节点，idx更新了，包含了idx 的父节点也需要更新</span></span><br><span class="line">        <span class="keyword">while</span>(idx &lt;= m_size)&#123;</span><br><span class="line">            bit[idx] += del;</span><br><span class="line">            idx += <span class="built_in">lowbit</span>(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum += bit[idx];</span><br><span class="line">            idx -= <span class="built_in">lowbit</span>(idx); <span class="comment">// 往下加上子节点的数值，直到到达叶子节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &amp; (-idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lowbit">lowbit</h3><p>x的lowbit = $$2^k$$ , 其中 <mark>k = 第一个1右边连续0 的个数</mark></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>=</mo><mi>x</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">lowbit = x \&amp; (-x);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></span></p><blockquote><p>如果x是0 0&amp;(-0) = 0;</p><p>如果x是奇数，则最后一位是1，其lowbit 为 1</p><p>-x = 取反 + 1；导致 -x 最后一位是1 且没有进位，从而导致除了最后一位全1 之外，其他的全部是犯的（取反），包括符号位， 所以lowbit = 1；</p><p>如果x是偶数，且 x = 2的m次方，则x的二进制只有一个1，全0</p><p>x 0 00100 -x 就是 1 11011 + 1 = 1 11100   0 00100 &amp; （1 11100） = 100 = 4 也是对的</p><p>如果x是偶数，却不是2的m次方，则可以写成 $$x=y*(2^m)$$,其中y的最低为是1，也就是y是一个奇数，也就是x是奇数左移m位得到的，</p><p>推导一下，结果也是$$2^k$$​</p></blockquote><p>奇怪的 位运算技巧</p><p><mark>判断是否是 2的幂次 x &gt; 0 ? ( x &amp; (x-1) == 0) : false;</mark></p><p><strong>example 逆序数 leetcode 315 计算右侧小于当前元素的个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;&#125;; <span class="comment">//特殊判断</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">  set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; rank_map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ele:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">count</span>(ele) == <span class="number">0</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(ele); <span class="comment">//vec存放nums出现过的元素，相当于集合，不过后面还要排序，所以用的vector</span></span><br><span class="line">        &#125;</span><br><span class="line">      st.<span class="built_in">insert</span>(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 升序排序, 小 到 大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;vec.<span class="built_in">begin</span>();i++)&#123;</span><br><span class="line">      rank_map[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> size = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">BIT <span class="title">bit</span><span class="params">(size)</span></span>; <span class="comment">// 存放排名，每个位置的前缀和是小于当前排名的元素个数</span></span><br><span class="line">                    <span class="comment">//然后从后往前遍历原来的数组，根据数组元素查询排名idx</span></span><br><span class="line">                    <span class="comment">//调用update(idx+1,1) 向上更新;表示 idx+1 往后的节点，小于其排名的元素个数 + 1， 因为出现了一个idx</span></span><br><span class="line">                    <span class="comment">//然后调用query(idx), 向下求和，表示求当前位置之后有多少个元素小于当前位置的元素； </span></span><br><span class="line">                    <span class="comment">// 倒序遍历 + 离散化排名 保证了逆序对的求值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//init bit</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> ele = nums[i]; <span class="comment">// 右往左遍历，出现了新元素，去查这个元素的排名</span></span><br><span class="line">      <span class="type">int</span> rank = rank_map[ele];</span><br><span class="line">      bit.<span class="built_in">update</span>(rank + <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">      result[i] = bit.<span class="built_in">query</span>(rank);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="与线段树的区别">与线段树的区别</h3><p>线段树只需要保证区间操作的可结合性质，可加性（也就是大区间的结果可以由小区间得到），而树状数组除了需要满足上面的条件之外，还要额外加一条可抵消性，也就是<font color='blue'>可以通过一个操作抵消掉不需要的区间的贡献</font></p><p><strong>线段树 TODO</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 区间和 </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯面试记录</title>
      <link href="/2024/04/09/tecent_interview/"/>
      <url>/2024/04/09/tecent_interview/</url>
      
        <content type="html"><![CDATA[<h2 id="date-4-1-19-00"><strong>date</strong> 4.1 19:00</h2><h2 id="面试部门-qq浏览器"><strong>面试部门</strong> QQ浏览器</h2><hr><h2 id="http-udp-区别">HTTP UDP 区别</h2><table><thead><tr><th>item</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td></td><td>面向连接的</td><td>无连接的</td></tr><tr><td>可靠性</td><td>提供可靠传输</td><td>尽最大努力交付，不保证可靠传输</td></tr><tr><td></td><td>有拥塞控制机制</td><td>无拥塞控制机制，不会降低源主机的发送速率，适合用于实时应用 语音 视频 直播</td></tr><tr><td>传输对象</td><td>字节流</td><td>报文段</td></tr><tr><td>传输效率</td><td>慢</td><td>快</td></tr><tr><td>首部开销</td><td>20-60</td><td>8 字节</td></tr><tr><td>场景</td><td>适用于要求传输可靠的场景，如文件邮件传输</td><td>适用于通信速率要求高 即时通讯场景，域名服务 语音视频</td></tr><tr><td></td><td>一对一</td><td>一对多 一对一 多对一 多对多</td></tr><tr><td>示例</td><td>使用TCP的应用层协议有 FTP Telnet SMTP POP3 HTTP</td><td>DNS SNMP TFTP</td></tr></tbody></table><hr><h2 id="http1-0-与-http1-1-http-2-0">HTTP1.0 与 HTTP1.1 HTTP 2.0</h2><table><thead><tr><th>特性</th><th>HTTP 1.0</th><th>HTTP 1.1</th><th>HTTP 2.0</th></tr></thead><tbody><tr><td>持久连接</td><td>不支持</td><td>允许在单个连接上发送多个请求和响应</td><td>允许在单个连接上多路复用多个请求和响应</td></tr><tr><td>头部压缩</td><td>不支持</td><td>引入了部分头部压缩机制</td><td>引入了头部压缩，减少了重复的头部信息传输</td></tr><tr><td>多路复用</td><td>不支持</td><td>不支持</td><td>支持多路复用，允许同时发送和接收多个请求和响应</td></tr><tr><td>二进制传输</td><td>不支持</td><td>不支持</td><td>使用二进制格式传输数据，提高传输效率</td></tr><tr><td>请求优先级</td><td>不支持</td><td>不支持</td><td>支持请求优先级，允许指定请求的优先级顺序</td></tr><tr><td>流控制</td><td>不支持</td><td>不支持</td><td>支持流控制，避免了发送者超负荷发送数据</td></tr></tbody></table><hr><h2 id="断点续传如何实现的">断点续传如何实现的</h2><p>断点续传（Resumable Download）是一种通过在下载过程中保存已下载数据的方式，使用户可以在下载中断后继续下载而不必重新开始的技术。它通常在网络下载和上传中使用，尤其是针对大型文件或不稳定网络环境下的文件传输。</p><p>实现断点续传通常包括以下步骤：</p><ol><li><p>服务器端支持： 服务器端需要支持断点续传功能。这通常涉及配置服务器以处理范围请求（Range Requests）。服务器接收到范围请求后，会返回请求的部分内容而不是整个文件。HTTP协议中使用的是Range头部来指示客户端需要的数据范围。</p></li><li><p>客户端实现： 客户端需要能够处理断点续传的逻辑。当下载中断后，客户端会向服务器发送一个包含已下载部分范围的范围请求。服务器会根据这个范围请求返回相应的数据。然后客户端会将这些数据与之前已下载的数据进行合并，从而实现断点续传。</p></li><li><p>断点记录： 客户端通常会记录已经下载的文件片段的信息，包括文件的大小、已下载的数据大小等。当下载中断时，客户端可以使用这些信息来向服务器发送范围请求。</p></li><li><p>续传标识： 服务器端通常会使用特定的HTTP头部（如Accept-Ranges和Content-Range）来指示客户端服务器是否支持范围请求以及返回的数据的范围。</p></li></ol><p>总的来说，断点续传是通过客户端和服务器之间的协作来实现的。客户端在下载中断时发送范围请求，服务器根据请求返回相应的数据片段，客户端将这些数据片段与已下载的部分合并，从而实现断点续传。</p><hr><h2 id="数据库技术">数据库技术</h2><p>没学，寄！</p><hr><h2 id="停止等待arq协议-连续arq协议">停止等待ARQ协议 连续ARQ协议</h2><p>TCP使用的是什么协议？</p><hr><h2 id="new-和-malloc-的区别">new 和 malloc 的区别</h2><hr><h2 id="hash如何实现">hash如何实现</h2><p>hash_table 开放寻址法 拉链法</p><hr><h2 id="如何实现tcp那样的可靠传输协议-有哪些难点">如何实现TCP那样的可靠传输协议 有哪些难点</h2><p>编号重排序， 校验和， 冗余丢弃，超时重传，拥塞控制， 流量控制</p><hr><h2 id="线程与进程">线程与进程</h2><table><thead><tr><th>特征</th><th>线程</th><th>进程</th></tr></thead><tbody><tr><td>定义</td><td>线程是进程的一部分，是程序执行的最小单元。</td><td>进程是操作系统分配资源的最小单位。</td></tr><tr><td>资源占用</td><td>线程共享进程的资源，如内存空间、文件句柄等。</td><td>进程有独立的资源空间，如内存、文件句柄等。</td></tr><tr><td>切换开销</td><td>线程切换开销小，因为共享相同的地址空间。</td><td>进程切换开销大，因为需要切换不同的地址空间。</td></tr><tr><td>通信方式</td><td>线程间通信相对容易，因为共享相同的地址空间。</td><td>进程间通信相对复杂，需要使用IPC机制。</td></tr><tr><td>并发性</td><td>线程并发性高，多个线程可同时执行不同的任务。</td><td>进程并发性低，多个进程之间执行互不干扰。</td></tr><tr><td>创建开销</td><td>创建线程的开销较小，通常只需要分配栈空间。</td><td>创建进程的开销较大，需要分配独立的地址空间、PCB等。</td></tr><tr><td>故障隔离</td><td>一个线程崩溃可能导致整个进程崩溃。</td><td>一个进程崩溃不会影响其他进程。</td></tr><tr><td>灵活性</td><td>线程间切换开销小，适合处理密集型任务。</td><td>进程间切换开销大，适合处理CPU密集型任务。</td></tr></tbody></table><hr><h2 id="死锁">死锁</h2><ol><li><p>互斥条件：至少有一个资源是非共享的，即一次只能被一个进程使用。如果一个进程在使用该资源时，其他进程不能使用，直到该进程释放该资源。</p></li><li><p>请求与保持条件：一个进程可以请求资源并保持对其他资源的占用。即当一个进程在请求资源时，它可以继续持有已分配的资源，不释放。</p></li><li><p>不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程抢占，只能由该进程自己释放。</p></li><li><p>循环等待条件：若干个进程之间形成一种循环等待资源的关系，即每个进程都在等待下一个进程所持有的资源。</p></li></ol><h1 id="构造一个死锁">构造一个死锁</h1><p>构造死锁的一个常见方式是通过多个进程之间的资源竞争，同时满足死锁的四个条件。例如，考虑两个进程A和B，它们都需要两个资源，但是资源的顺序分配不同，这可能导致死锁。具体来说：</p><ul><li>进程A获取资源1，进程B获取资源2。</li><li>进程A请求资源2，但由于资源2已被进程B持有，所以进程A等待。</li><li>同时，进程B请求资源1，但由于资源1已被进程A持有，所以进程B也等待。<br>这样，进程A等待进程B释放资源2，而进程B等待进程A释放资源1，导致了死锁的发生。</li></ul><h1 id="打破死锁">打破死锁</h1><p>要打破死锁或预防死锁，可以采取以下方法：</p><ul><li><p>避免死锁： 通过设计算法和协议来避免进程陷入死锁状态。例如，银行家算法可以在分配资源时避免死锁。</p></li><li><p>检测和恢复： 定期检测系统中是否存在死锁，一旦检测到死锁，采取恢复措施。常见的方法包括进程终止、资源抢占和回滚操作等。</p></li><li><p>避免资源竞争： 设计资源分配策略，尽量减少进程之间的资源竞争。例如，使用资源分配顺序来避免循环等待条件。</p></li><li><p>加锁顺序： 规定所有进程对资源的访问顺序，确保所有进程以相同的顺序请求资源，从而避免环路的形成。</p></li><li><p>超时机制： 对于等待资源的进程，设置超时机制，如果等待时间超过一定阈值，就放弃等待并释放已持有的资源，从而避免死锁。</p></li></ul><hr><h3 id="coding">coding</h3><pre><code>合并两个升序链表</code></pre><hr><h3 id="评价">评价</h3><h1 id="寄">寄！</h1>]]></content>
      
      
      <categories>
          
          <category> 面试笔试记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/09/hello-world/"/>
      <url>/2024/04/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
