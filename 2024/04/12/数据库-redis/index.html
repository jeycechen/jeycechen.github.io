<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库-redis | 冷静一下's bolg</title><meta name="author" content="冷静一下,cklnuaa@163.com"><meta name="copyright" content="冷静一下"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Why redis？ redis 是什么？ 是一种开源的、基于内存的数据结构存储系统，通常用作数据库缓存， Remote Dictionary Server 磁盘IO的时间在10ms左右， 而内存的读写时间是100us左右，所以如果能把经常访问的数据放在内存中， 能够极大提高服务器对客户端的响应速度 – 缓存 那么加了缓存有什么缺点？？  数据一致性问题 页面换入换处 - 也就是数据项的更新  M">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库-redis">
<meta property="og:url" content="http://example.com/2024/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93-redis/index.html">
<meta property="og:site_name" content="冷静一下&#39;s bolg">
<meta property="og:description" content="Why redis？ redis 是什么？ 是一种开源的、基于内存的数据结构存储系统，通常用作数据库缓存， Remote Dictionary Server 磁盘IO的时间在10ms左右， 而内存的读写时间是100us左右，所以如果能把经常访问的数据放在内存中， 能够极大提高服务器对客户端的响应速度 – 缓存 那么加了缓存有什么缺点？？  数据一致性问题 页面换入换处 - 也就是数据项的更新  M">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG">
<meta property="article:published_time" content="2024-04-12T12:47:18.163Z">
<meta property="article:modified_time" content="2024-09-11T08:26:35.710Z">
<meta property="article:author" content="冷静一下">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93-redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库-redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-11 16:26:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/collections.css"><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/staring_star_sky.JPG')"><nav id="nav"><span id="blog-info"><a href="/" title="冷静一下's bolg"><span class="site-name">冷静一下's bolg</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据库-redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-12T12:47:18.163Z" title="发表于 2024-04-12 20:47:18">2024-04-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-11T08:26:35.710Z" title="更新于 2024-09-11 16:26:35">2024-09-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据库-redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="why-redis？">Why redis？</h1>
<p>redis 是什么？ 是一种开源的、基于内存的数据结构存储系统，通常用作数据库缓存， <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver</p>
<p>磁盘IO的时间在10ms左右， 而内存的读写时间是100us左右，所以如果能把经常访问的数据放在内存中， 能够极大提高服务器对客户端的响应速度 – 缓存</p>
<p>那么加了缓存有什么缺点？？</p>
<ul>
<li>数据一致性问题</li>
<li>页面换入换处 - 也就是数据项的更新</li>
</ul>
<h2 id="memcache-vs-redis">Memcache vs redis</h2>
<ul>
<li>
<p>redis支持更多的数据结构</p>
</li>
<li>
<p>redis内存利用率高，对于简单的k-v 存储，memcache的利用率高</p>
</li>
<li>
<p>redis 是单核的 支持原生的集群模式</p>
</li>
</ul>
<h2 id="redis持久化">redis持久化</h2>
<h4 id="rdb-和aof-持久化">RDB 和AOF 持久化</h4>
<p>简单来说RDB：就是将Redis中的数据，每个一段时间，进行数据持久化</p>
<p>Redis将内存中的数据，存放到一个AOF文件中，但是因为Redis只会写一个AOF文件，因此这个AOF文件会越来越大。</p>
<p>AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在Redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集</p>
<p>AOF rewrite 压缩</p>
<p>RDB 实时性较差 AOF需要定时rewrite压缩，缺点就是恢复数据的时候比较慢，</p>
<p>一般是RDB + AOF混着用</p>
<h2 id="redis的线程模型">redis的线程模型</h2>
<p>类似一muduo库，一个主loop负责监听事件，然后分发给对应的事件处理器</p>
<h4 id="为什么单线程模型效率这么高？">为什么单线程模型效率这么高？</h4>
<ul>
<li>纯内存操作</li>
<li>核心是非阻塞的IO多路复用</li>
<li>单线程反而不用考虑多线程的上下文切换问题</li>
</ul>
<h2 id="redis的过期策略">redis的过期策略</h2>
<p>定期删除和惰性删除</p>
<h1 id="redis的高并发和高可用">redis的高并发和高可用</h1>
<p>高并发：主从架构，一主多从，主负责写入，单机几万的QPS， 从负责查询，多个从可以提10万的QPS</p>
<p>高可用：哨兵，任何一个实例宕机，自动进行主备切换</p>
<p>单机读写分离 + 主从架构 = 支撑10万+qps读的操作</p>
<h2 id="redis主从架构">redis主从架构</h2>
<ul>
<li>redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量</li>
<li>一个master node是可以配置多个slave node的</li>
<li>slave node也可以连接其他的slave node</li>
<li>slave node做复制的时候，是不会block master node的正常工作的</li>
<li>slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</li>
<li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</li>
<li>写操作存放在master node，同时在异步把master上的信息，同步到每个slave node上。</li>
</ul>
<h3 id="master持久化对于主从架构的安全保障的意义">Master持久化对于主从架构的安全保障的意义</h3>
<p>maste必须开启持久化，不能只靠salve node作为master node的数据热备份， 因为这样的话，master如果宕机了，也没有持久化，master就会认为数据是空的，从而去同步所有的salve node，把slave node数据也给丢掉了</p>
<p>第二个，master的各种备份方案，要不要做？<mark> 要做!</mark>万一说本地的所有文件丢失了; 从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的</p>
<p>即便用了 后续的高可用机制， slave node可以自动接管master node，但是可能sential还未检测到master 宕机，master就自动重启了，还是导致素有的slave node数据被清空</p>
<h3 id="主从复制原理">主从复制原理</h3>
<p>当启动一个slave node的时候，它会发送一个PSYNC命令给 master node，</p>
<ul>
<li>如果是salve node 重新连接master node，那么master node只会复制给slave部分缺少的数据(<font color='blue'>如何判断缺少与否？？</font>)</li>
<li>第一次连接到 master node ，full resynchronization</li>
</ul>
<p>full resynchronization，master会启动一个后台线程，开始生产一份RDB快照，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p>
<p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p>
<h3 id="主从复制的断点续传">主从复制的断点续传</h3>
<p>主从复制过程中，网络连接断掉了，可以接着上次复制的地方，继续复制下去，而不是从头复制一份，</p>
<p>slave保存一个replica offset 还有一个master id， offset保存在backlog中，如果复制过程中master和slave断开链接了，那么slave会从上次的replica开始继续复制，但是如果没有找到对应的offset，就会执行一次full resynchronization</p>
<h3 id="redis-主从复制的完整复制流程">Redis 主从复制的完整复制流程</h3>
<ol>
<li>
<p>salve node 启动，只有master node的信息，<font color='blue'> host + ip</font>,</p>
<blockquote>
<p>但是复制流程没开始hots ip哪里来的，redis.conf 中的slaveof 配置的</p>
</blockquote>
</li>
<li>
<p>slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket网络连接</p>
</li>
<li>
<p>slave node发送ping命令给master node</p>
</li>
<li>
<p>口令认证，如果master设置了requirepass，那么salve node必须发送masterauth的口令过去进行认证</p>
</li>
<li>
<p>master node第一次执行全量复制，将所有数据发给slave node</p>
</li>
<li>
<p>master node后续持续将写命令，异步复制给slave node</p>
</li>
</ol>
<h4 id="复制模式">复制模式</h4>
<h5 id="同步复制">同步复制</h5>
<p>在同步复制模式下，主节点在执行写操作之前会等待至少一个从节点确认接收到该命令后才继续执行。主节点会将写操作命令发送给从节点，并等待从节点的回复确认。</p>
<p>优点 数据一致性</p>
<p>缺点 影响性能，并且如果子节点因为故障无法回复，就会导致子节点阻塞住</p>
<h5 id="异步复制">异步复制</h5>
<p>在异步复制模式下，主节点将写操作命令发送给从节点，但不等待从节点的确认。主节点发送命令后即可继续处理其他命令，不会阻塞在复制过程上。</p>
<p>优点 响应快</p>
<p>缺点</p>
<ul>
<li>数据一致性无法保证</li>
<li>如果从节点发生故障或者延迟，写操作可能会在从节点上丢失</li>
</ul>
<h2 id="哨兵模式-sentinel">哨兵模式（sentinel）</h2>
<p>在sential 模式下， 有一下几个关键角色：</p>
<ul>
<li>master，</li>
<li>slave，</li>
<li>sentinel：负责监控主节点和从节点的健康状态，以及执行故障转移操作，哨兵有多个，形成一个哨兵集群 <font color='blue'> 哨兵节点最少3个，且集群数量为奇数，因要避免单点，且故障转移中涉及到选举，避免产生平局。</font></li>
</ul>
<h3 id="异常节点自动替换">异常节点自动替换</h3>
<h4 id="从节点异常">从节点异常</h4>
<p>sentinel定期给从节点发送<code>INFO</code> 命令，salve 回复自己的信息，包括复制偏移量、连接数等等，通过分析这些信息，sentinel可以判断slave的健康状态。</p>
<p>当slave被标记为下线（S_DOWN主观下线）时，检测到的哨兵会通知其他哨兵，共同确认节点的下线状态，多个哨兵确认从节点不健康时（客观下线），哨兵节点会将其从主节点的复制列表中移除，并将其从其他从节点的复制列表中移除。这样，异常从节点将不再接收主节点的复制数据，并且不再被其他从节点复制。当从节点状态恢复，哨兵节点会将其重新添加到主节点的复制列表中，并将其作为其他从节点的复制源。这样，从节点可以继续复制主节点的数据。</p>
<blockquote>
<p>主观下线：<font color='blue'>自己（sentinel）认为这个slave掉线了</font></p>
<p>客观下线：<font color='green'>多个哨兵都认为节点掉线了</font></p>
</blockquote>
<h4 id="主节点异常">主节点异常</h4>
<p>sentinel会定期给master 发送<code>PING</code>命令来检测心跳，如果心跳丢失，则哨兵会标记主节点为S_DOWN 主观下线</p>
<p>当主节点被标记为S_DOWN的时候，哨兵会通知其他哨兵，多个哨兵会共同确认master的下线状态，如果多数节点认为mater下线（客观下线），会进行一次选举，从slave中选出master，同时修改其余从节点的配置，将新的主节点作为数据同步的来源，然后重启服务，完成切换</p>
<h4 id="选举election">选举election</h4>
<p>根据所有slave的优先级 复制进度 运行ID来选出新的master</p>
<p>选举 先看优先级 再看复制进度 最后看运行ID</p>
<p>也就优先级一样，复制进度快的作为master</p>
<p>复制进度一样 ID小的作为master</p>
<blockquote>
<p>什么是复制进度？主从架构中，主节点会将写操作同步给从节点，在这个过程中，主节点会用 master_repl_offset(复制偏移量) 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从节点会用 slave_repl_offset 这个值记录当前的复制进度</p>
<p>如果某个从节点的 slave_repl_offset 最接近 master_repl_offset，说明它的复制进度是最靠前的，于是就可以将它选为新主节点。</p>
</blockquote>
<h4 id="主从切换过程">主从切换过程</h4>
<ol>
<li>选出新master之后，sentinel会向被选中的节点发送<code>SLAVEOF no one</code>命令，解除其从节点身份，变成新的主节点</li>
<li>发送命令之后，哨兵以每秒一次的频率发送<code>INFO</code>命令，并且观察其回复信息中的角色是否有由slave升级为master</li>
<li>是则哨兵向所有slave发送<code>SLAVEOF</code>,让他们成为新的master的slave</li>
<li>当旧的master重启时， 哨兵发送<code>SLAVEOF</code>，让其成为新的master的slave</li>
</ol>
<h4 id="哨兵集群组成">哨兵集群组成</h4>
<p>在配置哨兵集群的信息时，哨兵配置中，只需要填写主节点的相关信息，如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br></pre></td></tr></table></figure>
<p>哨兵之间使用过 发布/订阅来实现的，master 有一个 <code>__sentinel__:helllo</code>的频道，所有哨兵都会订阅这个，有哨兵需要加入集群的时候，就会向这个频道发送 自己的IP + PORT， 这样就可以加入集群</p>
<p><mark>哨兵集群通过向主节点发送INFO命令，获取从节点信息。</mark> 然后根据获取的信息，可以和子节点slave建立连接，并监控子节点的健康状态</p>
<h4 id="什么是脑裂？？">什么是脑裂？？</h4>
<p>一主多从，当master从正常网络脱离开，但是master实际上还是在工作，于是他还在处理客户端的请求，但是哨兵检测不到他，然后哨兵选举出新的节点，有两个master（脑裂了），这时新的master无法接受到客户端的写请求，这个时候网络好了，新的master存在，旧的master被哨兵设置为slave，发生全量同步，这个时候客户端向这个旧masater写入的数据就全部丢掉了</p>
<p>解决方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>
<p>要求至少有一个slave，数据复制和同步的延迟不能超过10s。</p>
<p>如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了，上面两个配置可以减少异步复制和脑裂导致的数据丢失</p>
<h2 id="集群模式cluster-mode">集群模式cluster mode</h2>
<p><mark> 多主多从 </mark></p>
<p>Redis Cluster 是 Redis 的分布式解决方案，集群通过分片（sharding）模式来对数据进行管理，并具备分片间数据复制、故障转移和流量调度的能力</p>
<ul>
<li>分布式架构，数据分布在多个节点上，每个节点负责管理一部分数据槽位，集群中一共有16384个槽位，每个槽位对应一个数据片段，通过数据分布在多个节点，可以支撑数据的<font color='blue'>负载均衡和横向扩展</font></li>
<li>主从复制, 每个主节点可以有一个或者多个从节点，主节点负责处理客户端请求和写入，从节点复制主节点的数据，负责处理读取操作，主从复制提供了数据的<font color='blue'>冗余备份和故障恢复</font></li>
<li>故障转移 主节点故障的时候，会从从节点选举出新的主节点</li>
<li>握手 当客户端连接到cluster的时候， 会进行一次握手，通过集群的节点间通信，客户端会获取到集群的拓扑结构信息，包括节点的IP地址和端口号，以及槽位的分配情况。这样客户端就可以直接与正确的节点进行通信。</li>
<li>槽位迁移，在Redis Cluster中，槽位的分配是动态的。当节点加入或离开集群时，槽位会进行重新分配和迁移。槽位迁移是逐个槽位进行的，节点之间会进行数据传输和同步，以保证数据的一致性。</li>
<li>客户端路由，Redis Cluster提供了客户端路由功能，客户端可以根据数据的Key来计算槽位，并将请求发送到对应的节点。客户端路由可以实现请求的负载均衡，以及自动发现和适应集群拓扑变化。</li>
</ul>
<p><mark> 创建集群至少需要三个主节点</mark> 3 个从节点 ，所以最少是6个节点</p>
<h2 id="hash-slot">hash slot</h2>
<p>hash slot 是对数据进行分片的单元，redis cluster 将数据划分为16384个哈希槽（0～16383）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，每个槽位对应一个数据片段，槽位的数量是固定的</p>
<p>cluster通过对key应用hash函数 （CRC16）计算出一个哈希值，将hash值对16384取模得到槽位编号，槽位编号确定了数据属于哪个槽位。</p>
<p><strong>注：哈希槽必须全部被分配，若有一个槽位没有正常分配，则整个集群都不可用。</strong></p>
<p><strong>哈希槽的划分：</strong></p>
<p>在 Redis Cluster 中，每个键根据其键名进行哈希计算，并被映射到这些哈希槽中的一个。</p>
<ol>
<li>初始状态：当创建一个 Redis Cluster 时，所有的哈希槽都是未分配的状态，没有任何键被映射到特定的哈希槽上。</li>
<li>添加节点：当添加主节点到 Redis Cluster 时，每个<mark>主节点</mark>会负责处理一部分哈希槽。Redis Cluster 会根据主节点的数量平均分配哈希槽。例如，如果有 3 个主节点，每个主节点将负责处理大约 1/3 的哈希槽。<font color='blue'> 也就是每个主从对 负责维护一部分数据，这样多机器就可以实现横向扩容，分布式存储，从是主的备份，同时也对外提供读请求的处理功能</font></li>
<li>哈希槽迁移：当节点加入或离开集群时，集群会自动进行哈希槽的迁移。迁移的目的是将哈希槽从一个节点转移给另一个节点(从一个主 移动到 另外一个主），以实现数据的均衡分布。迁移过程中，集群会自动将相关的键从一个节点复制到另一个节点，并在迁移完成后更新映射关系。
<ul>
<li>当添加新节点时：集群会将一部分哈希槽从现有节点迁移到新节点上。</li>
<li>当删除节点时：集群会将被删除节点上负责的哈希槽迁移到其他节点上，确保数据的可用性。</li>
</ul>
</li>
<li>客户端请求路由：一旦哈希槽分配完成，客户端的请求将根据键名的哈希值被路由到相应的节点。集群会根据请求中的键名计算哈希值，并将请求发送到负责该哈希槽的节点上进行处理。</li>
</ol>
<p>哈希槽的映射：</p>
<p>在 Redis Cluster 中，哈希槽（slots）与键的映射是通过对键名进行哈希计算来实现的。Redis 使用 CRC16 算法对键名进行哈希计算，并将计算结果对 16384（2^14）取模，得到对应的哈希槽。</p>
<ol>
<li>哈希计算：对于要存储到 Redis Cluster 的每个键，使用 CRC16 算法对键名进行哈希计算。这个哈希计算过程会生成一个 16 位的无符号整数。</li>
<li>取模运算：将哈希计算结果对 16384（2^14）取模，得到一个范围在 0 到 16383 的整数。这个结果就是键对应的哈希槽。如：哈希计算结果为 12345，那么对 16384 取模的结果为 12345 % 16384 = 12345，键就被映射到哈希槽 12345。</li>
<li>哈希槽分配：根据哈希槽的映射结果，将键存储在相应的哈希槽中。Redis Cluster 中的每个主节点都负责处理一部分哈希槽，主节点会根据哈希槽的分配情况进行数据存储和处理。</li>
</ol>
<blockquote>
<p>哈希槽的划分和映射是 Redis Cluster 在集群创建、主节点加入或离开时自动完成的，不需要手动操作。只有在特殊情况下，如手动划分哈希槽或进行特定的数据迁移时，才需要关注和操作哈希槽的映射关系</p>
<p><mark> 哈希槽只分布在主节点上，从节点没有哈希槽</mark></p>
</blockquote>
<h2 id="主从复制">主从复制</h2>
<p>原理一致</p>
<h2 id="集群间节点通信-心跳机制">集群间节点通信/心跳机制</h2>
<p>分布式存储集群需要提供维护节点元数据信息(节点信息，节点数据，节点状态等)的机制，常见的有集中式和P2P方式。</p>
<ol>
<li>
<p>集中式元数据维护方式：</p>
<p>在集中式方式中，有一个中心化的元数据管理节点（通常称为元数据服务器或元数据中心），负责管理和维护系统的元数据信息。其他节点通过与元数据服务器的交互来获取和更新元数据。</p>
<ul>
<li>优点：集中式元数据管理方便集中控制和维护，元数据的一致性和准确性相对容易保证。对于一些需要集中决策或控制的操作，集中式方式更为适用。</li>
<li>缺点：集中式元数据服务器可能成为系统的单点故障，一旦元数据服务器发生故障，整个系统的元数据访问和更新都会受到影响。此外，集中式方式的可扩展性和容错性可能较差。</li>
</ul>
</li>
<li>
<p>P2P元数据维护方式：</p>
<p>在P2P方式中，每个节点都具有一份或部分的元数据信息，并通过节点之间的相互通信来交换和同步元数据。所有节点都是对等的，没有中心化的元数据管理节点。</p>
<ul>
<li>优点：P2P方式避免了中心化的 <font color='red'>单点故障</font>，提高了系统的容错性和可用性。每个节点都具有元数据信息的副本，可以快速获取和更新元数据，减少了对中心节点的依赖。</li>
<li>缺点：P2P方式的元数据<mark>一致性</mark>较难保证，节点之间的同步和通信需要额外的开销。同时，P2P方式可能在某些操作上缺乏集中控制和决策的能力。</li>
</ul>
</li>
</ol>
<p><mark> cluster使用的P2P方式，采用的gossip协议实现，去中心化</mark></p>
<h3 id="gossip协议">gossip协议</h3>
<h4 id="1-节点选择">1.节点选择</h4>
<p>每个节点在固定的时间间隔内选择一些其他节点来通信，选择的节点可以是随机选择或者是基于某种算法进行选择</p>
<p>通过单独的TCP通道来进行通信</p>
<h4 id="2-信息交换">2.信息交换</h4>
<p>节点之间进行信息交换， 节点的IP地址 端口号，槽位分配信息，故障检测信息</p>
<h4 id="3-消息传播">3.消息传播</h4>
<p>接受到消息的节点会将消息传播给其他节点，从而实现信息在整个集群中的扩散（<mark>泛洪？</mark>)</p>
<p>每个节点会维护一份已知的节点列表，将收到的消息发给列表中的其他节点</p>
<h4 id="4-故障检查">4.故障检查</h4>
<p>节点通过Gossip协议实时地了解其他节点的状态，包括存活，故障或者重新上线</p>
<p>当节点检测到其他节点故障的时候，将故障消息广播给集群中的其他节点，以便进行故障转移和恢复操作。<mark>投票问题</mark></p>
<h4 id="5-节点状态更新">5.节点状态更新</h4>
<p>节点接受到了其他节点的消息之后，会更新自己维护的节点信息</p>
<p>节点可能会更新其他节点的状态，增加或者删除节点，以反映整个集群的最新状态</p>
<p><font color='blue'>Gossip协议的优点之一是它的去中心化性质，每个节点都可以主动地向其他节点传播信息，无需集中的协调者。这种去中心化的设计使得Gossip协议具有较好的可扩展性和容错性，能够适应大规模分布式系统中的节点动态变化和故障情况。</font></p>
<h4 id="消息类型">消息类型</h4>
<p>常用的Gossip消息可分为： <code>ping</code>消息、 <code>pong</code>消息、 <code>meet</code>消息、<code> fail</code>消息等。</p>
<ul>
<li><strong>ping</strong>：ping 消息是用于探测其他节点是否存活和可达的消息。当一个节点发送 Ping 消息给其他节点时，它期望收到 Pong 消息作为回复，以确认目标节点的存活状态。</li>
<li><strong>pong</strong>：pong 消息是对 Ping 消息的回复，用于确认节点的存活状态。当一个节点收到 Ping 消息时，会发送 Pong 消息给发送方，表明自己是存活的。</li>
<li><strong>meet</strong>：meet 消息是用于节点之间建立联系和发现新节点的消息。当一个节点想要加入到分布式系统中时，它可以发送 Meet 消息给一个已知的节点(可能是从默认的配置文件中找到节点的IP+Port)，请求与其建立联系。通过 Meet 消息的交换，新节点可以与现有节点建立连接并进一步扩展整个集群。</li>
<li><strong>fail</strong>：fail 消息是用于通知其他节点某个节点的故障或不可用状态的消息。当一个节点检测到另一个节点发生故障时，它可以发送 Fail 消息给其他节点，以便其他节点能够感知到该节点的状态，并采取相应的措施，如从集群中移除故障节点。</li>
</ul>
<h2 id="请求路由">请求路由</h2>
<p>类似于http协议的重定向，客户端直接链接的节点，可能并不负责这次请求的key，也就是这个key 的hash slot 不在当前这个节点上，需要重定向到新的节点</p>
<h2 id="故障转移">故障转移</h2>
<p>故障节点发现与自动替换：</p>
<ol>
<li>故障节点检测：每个节点通过 Gossip 协议与其他节点进行周期性的消息交换。当一个节点在一定时间内（ cluster-node-timeout ）没有收到来自主节点的消息时，它会将该主节点标记为疑似下线（pfail状态，即主观下线）。</li>
<li>疑似下线节点确认：节点向其他节点发送确认消息，询问它们是否也认为该主节点处于疑似下线状态。</li>
<li>多数派确认：如果大多数节点都确认了该主节点的疑似下线状态，那么该主节点会被标记为fail状态（客观下线）。</li>
<li>故障转移决策：客观下线的主节点会触发故障转移决策。集群中的其他节点会根据一定的算法和规则，从该主节点的从节点中选举出一个新的主节点。</li>
<li>新主节点选举：新的主节点会被选举并接管故障主节点的槽。选举过程中通常采用 Raft 算法或者其他一致性算法来保证选举的正确性和一致性。</li>
<li>数据重平衡：一旦新的主节点选举完成，集群会开始进行数据重平衡，将原先属于故障主节点的槽重新分配给新的主节点，并确保数据的一致性。</li>
</ol>
<h1 id="redis如何作为mysql的缓存？">redis如何作为mysql的缓存？</h1>
<p>mysql查询返回的是一个结果集合，</p>
<p>对查询语句计算MD5得到key， 然后保存结果，是否会导致缓存命中率不高？</p>
<p>string-map， 表名+ID 作为key 值作为val；</p>
<h1 id="缓存击穿和雪崩-穿透">缓存击穿和雪崩、穿透</h1>
<h3 id="击穿">击穿</h3>
<p>某个热点缓存失效，大量的请求直接打到数据库</p>
<p>解决：</p>
<ol>
<li>
<p><strong>缓存预热</strong>：在缓存失效前，提前重新加载数据，避免热点数据失效。</p>
</li>
<li>
<p><strong>互斥锁</strong>：使用分布式锁（例如 Redis 分布式锁）来控制只有一个请求可以去数据库加载数据并刷新缓存，其他请求等待锁释放后直接从缓存读取。</p>
</li>
<li>
<p><strong>永不过期策略</strong>：对热点数据设置成永不过期，并通过异步任务去定期更新缓存。</p>
</li>
</ol>
<h3 id="雪崩">雪崩</h3>
<p>大量缓存同时失效，或者redis数据库寄了，导致数据库也收到了大量的访问请求</p>
<p>解决方法：</p>
<ol>
<li>
<p><strong>缓存失效时间随机化</strong>：在设置缓存的过期时间时，加上一个随机值，避免大量缓存同时失效。</p>
</li>
<li>
<p><strong>逐渐失效策略</strong>：将缓存的失效时间分散在不同时段，避免集中失效。</p>
</li>
<li>
<p><strong>双层缓存</strong>：使用多级缓存，第一层缓存失效后请求从第二层缓存获取，给数据库更多的缓冲时间。</p>
</li>
</ol>
<h4 id="如果是redis数据库寄了-怎么办？">如果是redis数据库寄了，怎么办？</h4>
<ul>
<li>服务熔断机制，拒绝所有请求，或者只放一部分请求进mysql，等到redis服务重启之后，在重新开启服务</li>
<li>使用集群模式 主从</li>
</ul>
<h3 id="穿透">穿透</h3>
<p>用户要访问的数据既不在缓存中，又不在数据库中，<mark>那在哪里？？？</mark></p>
<p>说明数据丢失了，</p>
<ul>
<li>业务误操作，删除了</li>
<li>被黑客恶意攻击，故意访问大量不存在的数据</li>
</ul>
<p>解决方法</p>
<ul>
<li>非法请求的限制</li>
<li>缓存空值或者默认值，如果穿透了，就直接返回空/default，这样就不会再继续查询数据库了</li>
<li>使用布隆过滤器快速判断数据是否存在，从而避免查询数据库</li>
</ul>
<h1 id="什么是布隆过滤器？">什么是布隆过滤器？</h1>
<p>布隆过滤器（Bloom Filter）是一种空间效率极高的数据结构，用于测试一个元素是否在一个集合中。它的设计目标是用来处理可能性测试的问题，尤其是在需要处理大规模数据时。布隆过滤器能够提供快速的“可能存在”测试，<font color='blue'>但可能会有一些误报。</font></p>
<h3 id="基本概念">基本概念</h3>
<p>布隆过滤器有以下几个主要特性：</p>
<ol>
<li><strong>空间效率</strong>：布隆过滤器的主要优点是其空间效率。在存储大量数据时，它比其他数据结构（如哈希表、集合等）要节省空间。</li>
<li><strong>时间效率</strong>：对元素的查询操作非常快速。</li>
<li><strong>可能的误报</strong>：布隆过滤器可能会错误地报告某个元素存在，但绝不会错误地报告某个元素不存在。也就是说，它的假阳性率（false positive rate）是可控的，但假阴性率（false negative rate）为零。</li>
</ol>
<h3 id="工作原理">工作原理</h3>
<p>布隆过滤器使用了多个哈希函数和一个位数组来实现其功能。具体步骤如下：</p>
<ol>
<li><strong>初始化</strong>：
<ul>
<li>创建一个位数组（bit array），所有位初始化为0。</li>
<li>选择多个哈希函数，每个哈希函数将元素映射到位数组中的一个位置。</li>
</ul>
</li>
<li><strong>添加元素</strong>：
<ul>
<li>对每个要添加的元素，使用多个哈希函数计算出多个索引位置。</li>
<li>将这些索引位置对应的位在位数组中设置为1。</li>
</ul>
</li>
<li><strong>查询元素</strong>：
<ul>
<li>对要查询的元素，使用相同的哈希函数计算出多个索引位置。</li>
<li>检查这些索引位置对应的位是否都是1。</li>
<li>如果所有位置的位都是1，布隆过滤器报告元素可能存在<mark>(因为可能存在哈希冲突，不同的key可能设置了同样的位置为1）</mark>；如果有任何一个位置的位为0，布隆过滤器报告元素一定不存在。</li>
</ul>
</li>
</ol>
<h3 id="误报率">误报率</h3>
<p>布隆过滤器的误报率与位数组的大小、哈希函数的数量以及元素的数量有关。误报率是可以通过调整这些参数来控制的：</p>
<ul>
<li><strong>位数组的大小</strong>：越大，误报率越低。</li>
<li><strong>哈希函数的数量</strong>：增加哈希函数的数量可以减少误报率，但会增加计算开销。</li>
</ul>
<h3 id="优缺点">优缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>节省空间</strong>：相比其他数据结构，布隆过滤器占用的空间更少。</li>
<li><strong>快速查询</strong>：查询操作时间复杂度为 O(k)，其中 k 是哈希函数的数量。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>可能的误报</strong>：布隆过滤器可能会误判元素存在。</li>
<li><strong>无法删除元素</strong>：标准的布隆过滤器无法删除已经添加的元素，因为删除操作可能会影响到其他元素的查询。</li>
</ul>
<h3 id="应用场景">应用场景</h3>
<p>布隆过滤器广泛应用于各种需要高效集合测试的场景，比如：</p>
<ul>
<li><strong>数据库系统</strong>：在进行磁盘或网络查找之前，用于减少不必要的查询。</li>
<li><strong>缓存系统</strong>：用来检查缓存中是否可能包含某个对象，以减少缓存失效的开销。</li>
<li><strong>网络爬虫</strong>：检测网页是否已被访问过，防止重复抓取。</li>
</ul>
<h3 id="例子">例子</h3>
<p>假设你有一个布隆过滤器，用来检查某个数字是否在一个大数据集中。你使用三个哈希函数，将每个数字映射到位数组的三个不同位置。例如，数字 42 经过三个哈希函数后可能会映射到位数组的索引 5、12 和 33。这些位置的位被设置为 1。当你查询数字 42 是否存在时，布隆过滤器会检查这些位置的位是否都是 1，如果是，它就报告数字 42 可能存在；如果其中任何一个位置的位是 0，它就报告数字 42 一定不存在。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">冷静一下</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93-redis/">http://example.com/2024/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93-redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">冷静一下's bolg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.JPG" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.JPG" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/12/remain/" title="remain"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">remain</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="os learning"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">os learning</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冷静一下</div><div class="author-info__description">一个小菜鸟</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jeycechen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jeycechen" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/cklnuaa@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#why-redis%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Why redis？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#memcache-vs-redis"><span class="toc-number">1.1.</span> <span class="toc-text">Memcache vs redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rdb-%E5%92%8Caof-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">RDB 和AOF 持久化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">redis的线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%95%88%E7%8E%87%E8%BF%99%E4%B9%88%E9%AB%98%EF%BC%9F"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">为什么单线程模型效率这么高？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.</span> <span class="toc-text">redis的过期策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">redis的高并发和高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">redis主从架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#master%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E4%BA%8E%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">Master持久化对于主从架构的安全保障的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">2.1.3.</span> <span class="toc-text">主从复制的断点续传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">Redis 主从复制的完整复制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">复制模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.4.1.1.</span> <span class="toc-text">同步复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.4.1.2.</span> <span class="toc-text">异步复制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-sentinel"><span class="toc-number">2.2.</span> <span class="toc-text">哨兵模式（sentinel）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%8A%82%E7%82%B9%E8%87%AA%E5%8A%A8%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">异常节点自动替换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E8%8A%82%E7%82%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">从节点异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">主节点异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BEelection"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">选举election</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">主从切换过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%BB%84%E6%88%90"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">哨兵集群组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%91%E8%A3%82%EF%BC%9F%EF%BC%9F"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">什么是脑裂？？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8Fcluster-mode"><span class="toc-number">2.3.</span> <span class="toc-text">集群模式cluster mode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash-slot"><span class="toc-number">2.4.</span> <span class="toc-text">hash slot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%97%B4%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">集群间节点通信&#x2F;心跳机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gossip%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.6.1.</span> <span class="toc-text">gossip协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">1.节点选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">2.信息交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E4%BC%A0%E6%92%AD"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">3.消息传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%85%E9%9A%9C%E6%A3%80%E6%9F%A5"><span class="toc-number">2.6.1.4.</span> <span class="toc-text">4.故障检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0"><span class="toc-number">2.6.1.5.</span> <span class="toc-text">5.节点状态更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.1.6.</span> <span class="toc-text">消息类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="toc-number">2.7.</span> <span class="toc-text">请求路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.8.</span> <span class="toc-text">故障转移</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E5%A6%82%E4%BD%95%E4%BD%9C%E4%B8%BAmysql%E7%9A%84%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">redis如何作为mysql的缓存？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9-%E7%A9%BF%E9%80%8F"><span class="toc-number">4.</span> <span class="toc-text">缓存击穿和雪崩、穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BB%E7%A9%BF"><span class="toc-number">4.0.1.</span> <span class="toc-text">击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%AA%E5%B4%A9"><span class="toc-number">4.0.2.</span> <span class="toc-text">雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AFredis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%84%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">如果是redis数据库寄了，怎么办？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BF%E9%80%8F"><span class="toc-number">4.0.3.</span> <span class="toc-text">穿透</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">什么是布隆过滤器？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.0.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AF%E6%8A%A5%E7%8E%87"><span class="toc-number">5.0.3.</span> <span class="toc-text">误报率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.0.4.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.0.5.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">5.0.6.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/task-struct%E8%AF%A6%E8%A7%A3/" title="task_struct详解">task_struct详解</a><time datetime="2024-09-11T16:14:29.000Z" title="发表于 2024-09-12 00:14:29">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/ac-tricks/" title="ac_tricks">ac_tricks</a><time datetime="2024-09-09T13:15:03.000Z" title="发表于 2024-09-09 21:15:03">2024-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/cookie-session/" title="cookie &amp;&amp; session">cookie &amp;&amp; session</a><time datetime="2024-09-09T08:14:13.000Z" title="发表于 2024-09-09 16:14:13">2024-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/05/c++%E9%9D%A2%E7%BB%8F/" title="c++面经">c++面经</a><time datetime="2024-09-05T15:19:47.000Z" title="发表于 2024-09-05 23:19:47">2024-09-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/05/%E6%95%B0%E8%AE%BA/" title="数论">数论</a><time datetime="2024-09-05T15:19:08.000Z" title="发表于 2024-09-05 23:19:08">2024-09-05</time></div></div></div></div><div class="card-widget"><div class="item-headline"><i class="fas fa-cubes"></i><span>系列合集</span></div><div class="collections-item-content"><a href="文章1url">面试合集</a></div><div class="collections-item-content"><a href="文章2url">名称2</a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冷静一下</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liKf4gi0DpLa4i2u',
      clientSecret: '80d1c4128ced9c69f894028dd98211b70e94d2ca',
      repo: 'jeycechen.github.io',
      owner: 'jeycechen',
      admin: ['jeycechen'],
      id: '536a507047f65f3f78bb9f5a2ff8c501',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>