<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>jos_lab1 | 冷静一下's bolg</title><meta name="author" content="冷静一下,cklnuaa@163.com"><meta name="copyright" content="冷静一下"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JOS mit 6.828 lab1 环境配置和使用 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;oasisyang&#x2F;p&#x2F;15355667.html make qemu-gdb make gdb 在内存地址 0x7c00 b *0x7c00 打印寄存器的值 p $esi 打印寄存器所指向内存地址的值 p *$esi 打印要执行的下一条指令x&#x2F;i $eip PC Bootstrap PC的物理地">
<meta property="og:type" content="article">
<meta property="og:title" content="jos_lab1">
<meta property="og:url" content="http://jeycechen.github.com/2024/10/04/6-828-lab1/index.html">
<meta property="og:site_name" content="冷静一下&#39;s bolg">
<meta property="og:description" content="JOS mit 6.828 lab1 环境配置和使用 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;oasisyang&#x2F;p&#x2F;15355667.html make qemu-gdb make gdb 在内存地址 0x7c00 b *0x7c00 打印寄存器的值 p $esi 打印寄存器所指向内存地址的值 p *$esi 打印要执行的下一条指令x&#x2F;i $eip PC Bootstrap PC的物理地">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG">
<meta property="article:published_time" content="2024-10-04T03:21:03.000Z">
<meta property="article:modified_time" content="2024-10-07T15:51:01.455Z">
<meta property="article:author" content="冷静一下">
<meta property="article:tag" content="boot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jeycechen.github.com/2024/10/04/6-828-lab1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jos_lab1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-07 23:51:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/collections.css"><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/staring_star_sky.JPG')"><nav id="nav"><span id="blog-info"><a href="/" title="冷静一下's bolg"><span class="site-name">冷静一下's bolg</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">jos_lab1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-04T03:21:03.000Z" title="发表于 2024-10-04 11:21:03">2024-10-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-07T15:51:01.455Z" title="更新于 2024-10-07 23:51:01">2024-10-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="jos_lab1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>JOS mit 6.828</p>
<h1 id="lab1">lab1</h1>
<h2 id="环境配置和使用">环境配置和使用</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/oasisyang/p/15355667.html">https://www.cnblogs.com/oasisyang/p/15355667.html</a></p>
<p>make qemu-gdb</p>
<p>make gdb</p>
<p>在内存地址 0x7c00 <code>b *0x7c00</code></p>
<p>打印寄存器的值 <code>p $esi</code></p>
<p>打印寄存器所指向内存地址的值 <code>p *$esi</code><br>
打印要执行的下一条指令<code>x/i $eip</code></p>
<h2 id="pc-bootstrap">PC Bootstrap</h2>
<h3 id="pc的物理地址空间">PC的物理地址空间</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>384KB area from 0x000A0000 through 0x000FFFFF 是供给硬件使用的 尤其是video disdplay buffers 以及 firmware held in non-volatile memory，最重要的BIOS也保存在这个地方 占据着 64KB region from 0x000F0000 through 0x000FFFFF.</p>
<blockquote>
<p>该保留区域中最重要的部分是基本输入/输出系统 (BIOS)，它占据了从 0x000F0000 到 0x000FFFFF 的 64KB 区域。在早期的 PC 中，BIOS 保存在真正的只读存储器 (ROM) 中，但当前的 PC 将 BIOS 存储在可更新的闪存中。BIOS 负责执行基本的系统初始化，例如激活视频卡和检查已安装的内存量。执行此初始化后，BIOS 会从某个适当的位置（例如软盘、硬盘、CD-ROM 或网络）加载操作系统，并将机器的控制权交给操作系统。</p>
<p>When Intel finally “broke the one megabyte barrier” with the 80286 and 80386 processors, which supported 16MB and 4GB physical address spaces respectively, the PC architects nevertheless preserved the original layout for the low 1MB of physical address space in order to ensure backward compatibility with existing software. <font color='blue'>Modern PCs therefore have a “hole” in physical memory from 0x000A0000 to 0x00100000,</font> dividing RAM into “low” or “conventional memory” (the first 640KB) and “extended memory” (everything else). <font color='red'><strong>In addition, some space at the very top of the PC’s 32-bit physical address space, above all physical RAM, is now commonly reserved by the BIOS for use by 32-bit PCI devices</strong>.</font></p>
<p>也就是现代计算机仍然存在hole 在0x000A0000到 0x00100000的位置，bios和硬件所保留，这个hole把物理内存划分为两部分 low/conventional memory 和 extended memory</p>
</blockquote>
<h3 id="the-rom-bios">The ROM BIOS</h3>
<p>启动qemu</p>
<p><img src="/Users/casey/blog_md/JOS/lab1/first_code.png" alt="第一个执行的代码"></p>
<p>可以看到第一句执行的指令是 位于0xffff0的 一条jump指令</p>
<p>注意到以下三点：</p>
<ul>
<li>
<p>The IBM PC starts executing at physical address 0x000ffff0, which is at the very top of the 64KB area reserved for the ROM BIOS</p>
</li>
<li>
<p>The PC starts executing with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code>.</p>
<blockquote>
<p>CS IP是什么？</p>
<p>CS 代码段寄存器 内存单元的段地址</p>
<p>IP 指令指针寄存器 内存单元的偏移地址</p>
<p>如何通过CS IP 得到 实际的物理地址</p>
<p>physical address = CS * 16 + IP;</p>
<p>也就是CS左移4位 加上 IP 就是实际的物理内存地址</p>
<p>通过CS：IP的方式，8088的16位地址线可以管理访问到1M的物理内存</p>
</blockquote>
</li>
<li>
<p>The first instruction to be executed is a <code>jmp</code> instruction, which jumps to the segmented address <code>CS = 0xf000</code> and <code>IP = 0xe05b</code></p>
</li>
</ul>
<p>为何QEMU这样启动？intel就是这样设计的 PC中的BIOS is “hard-wired” to the physical address range 0x000f0000-0x000fffff， 这种设计确保了 BIOS在开机或者重启的时候 始终能够取得机器的控制权，在开机之后，处理器enters real mode and sets CS to 0xf000 and the IP to 0xfff0，以便从CS:IP这个地址开始执行</p>
<p>1、0xffff0到 BIOS的末尾0x00100000 也就  <code>16Bytes</code> 能做的事情非常有限，所以这一条指令是一条 <font color='blue'>jump</font>指令.</p>
<p>2、当BIOS继续运行， 它会设置 interrupt descriptor table and initializes various devices such as the VGA display. 设置中断向量表<font color='blue'>IDT</font>和全局描述符表<font color='blue'>GDT</font></p>
<p>3、PCI总线和所有的重要设备初始化完成之后，BIOS就会搜索所有的可启动的设备 ，如 floppy, hard drive, or CD-ROM. ，找到可启动磁盘后，BIOS会从磁盘读取 <font color='blue'>引导加载程序<code>Boot Loader</code> 并且将控制权转交给它</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1 0xffff0: ljmp $0xf000, $0xe05b    #跳转到0xfe05b</span><br><span class="line">2 0xfe05b: cmpl $0x0, $cs:0x6ac8    #根据cs:0x6ac8是否为0，进行跳转</span><br><span class="line">3 0xfe062: jne 0xfd2e1                #无跳转</span><br><span class="line">4 0xfe066: xor %dx, %dx                #%dx清零</span><br><span class="line">5 0xfe068: mov %dx, %ss                #%ss置零</span><br><span class="line">6 0xfe06a: mov $0x7000, %esp</span><br><span class="line">7 0xfe070: mov $0xf34d2,%edx</span><br><span class="line">8 0xfe076: jmp 0xfd15c</span><br><span class="line">9 0xfd15c: mov %eax, %ecx</span><br><span class="line">10 0xfd15f: cli                        #BIOS的启动不允许中断，关闭中断</span><br><span class="line">11 0xfd160: cld                        #设置指令增长的方向</span><br><span class="line">12 0xfd161: mov $0x8f, %eax</span><br><span class="line">13 0xfd167: out %al, $0x70            #0x70和0x71是用于操作CMOS 的端口</span><br><span class="line">14 0xfd169: in $0x71, %al            #12-14三条指令是用于关闭不可屏蔽中断</span><br><span class="line">15 0xfd16b: in $0x92, %al</span><br><span class="line">16 0xfd16d: or $0x2, %al</span><br><span class="line">17 0xfd16f: out %al, $0x92</span><br><span class="line">18 0xfd171: lidtw %cs:0x6ab8        #将0xf6ab8处的数据读入到中断向量表寄存(IDTR)</span><br><span class="line">19 0xfd177: lgdtw %cs:0x6a74   #并将0xf6a74的数据读入到全局描述符表格寄存器(GDTR)中</span><br><span class="line">20 0xfd17d: mov %cr0, %eax</span><br><span class="line">21 0xfd180: or $0x1, %eax</span><br><span class="line">22 0xfd184: mov %eax, %cr0  #CR0末位置1，进入保护模式</span><br><span class="line">23 0xfd187: ljmpl $0x8, $0xfd18f</span><br><span class="line">24 0xfd18f: mov $0x10, %eax</span><br><span class="line">25 0xfd194: mov %eax, %ds</span><br><span class="line">26 0xfd196: mov %eax, %es</span><br><span class="line">27 0xfd198: mov %eax, %ss</span><br><span class="line">28 0xfd19a: mov %eax, %fs</span><br><span class="line">29 0xfd19c: mov %eax, %gs</span><br><span class="line">30 0xfd19e: mov %ecx, %eax #第23~29 步用于重新加载段寄存器，在加载完GDTR 寄存器后需要刷新所有的段寄存器的值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>what is GDTR?</p>
</blockquote>
<p>Global Descriptor Table</p>
<p>包含一组描述符，用于定义内存段的起始地址、大小、权限等信息。每个描述可以代表一个段。</p>
<ul>
<li><strong>内存分段</strong> 通过定义不同的段来划分内存地址空间<font color='blue'> 虚拟地址空间</font></li>
<li><strong>权限控制</strong> 可以设置不同的权限级别，内核模式和用户模式</li>
<li><strong>段选择</strong> 通过段选择子来访问GDT中的描述符，从而决定代码和数据的访问范围和权限</li>
</ul>
<h2 id="the-boot-loader">The Boot Loader</h2>
<p>PC的Floopy 和 hard disks 被划分成512bytes 的扇区， 扇区是磁盘的最小传输单位，每个读取或者写入的操作必须是一个或者多个扇区大小，并且要与扇区的边界对齐</p>
<p>如果磁盘是可以引导的，那个第一个扇区被称为引导扇区，（因其包含boot loader代码）当BIOS找到了一个可引导设备，它就会加载这个设备的第一个扇区512字节到内存地址 <code>0x7c00-0x7dff</code>， 并且使用jmp指令设置CS：IP 为<code>0000:7c00</code>， 就像BIOS的入口地址一样 7c00这个地址<font color='green'>是随意的，但是是约定好的标准，是惯例</font></p>
<blockquote>
<p>从CD-ROM Boot有一些不一样 比如 CD-ROOM的扇区大小是2048</p>
<p>The ability to boot from a CD-ROM came much later during the evolution of the PC, and as a result the PC architects took the opportunity to rethink the boot process slightly. As a result, the way a modern BIOS boots from a CD-ROM is a bit more complicated (and more powerful). CD-ROMs use a sector size of 2048 bytes instead of 512, and the BIOS can load a much larger boot image from the disk into memory (not just one sector) before transferring control to it. For more information, see the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El Torito” Bootable CD-ROM Format Specification</a>.</p>
</blockquote>
<p>6.828中 使用传统的hard drive boot mechanism，这意味着引导程序必须在512字节完成，代码在<code>boot/boot.S</code>, <code>boot/main.c</code>, 由assembly  language + c一起完成 ，这两部分代码必须完成两个主要的功能</p>
<ol>
<li>首先，boot loader 需要完成processor <font color='blue'>从 16-bit real mode 到32-bit protected mode 的转变</font>，因为只有在protected mode 才能访问在1MB之上的所有内存地址空间</li>
</ol>
<blockquote>
<p>Protected mode is described briefly in sections 1.2.7 and 1.2.8 of <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language</a>, and in great detail in the Intel architecture manuals. <strong>At this point you only have to understand that translation of segmented addresses (segment:offset pairs) into physical addresses happens differently in protected mode, and that after the transition offsets are 32 bits instead of 16.</strong></p>
</blockquote>
<ol start="2">
<li>其次，boot loader  会通过x86的特殊IO指令直接访问IDE磁盘设备寄存器，从硬盘读取内核</li>
</ol>
<blockquote>
<p>b 打断点  <strong>b *0x7c00</strong></p>
<p>c</p>
<p>si 单步</p>
<p>si N N个单步</p>
<p>x/i  查看下一条指令</p>
<p>x/Ni ADDR 查看从ADDR开始的 N条指令</p>
</blockquote>
<h3 id="answer-questions">Answer Questions</h3>
<ul>
<li>
<p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"># ljmp $0x8, $0x7c32 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、在完成启用A20地址线之后，以及bootstrap GDT</p>
<p>and segment translation 加载好GDT表之后，开始转型执行32位的代码，为什么要这样做？（为了向早期的机器兼容）开机的时候1MB以上的地址空间是默认不可用的，需要解锁，<strong><font color='red'>GDT表是什么？</font></strong></p>
<p>2、因为实模式到保护模式的转变，需要使用更多的地址，就需要16 -&gt; 32位</p>
</blockquote>
</li>
<li>
<p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw	$0x1234,0x472			# warm boot</span><br></pre></td></tr></table></figure>
<p>在不中断电源的情况下启动 热启动，将0x1234 写入到地址0x472，系统可以识别并且执行预定的重启程序，比如不进行完全的硬件复位</p>
</li>
</ul>
<p>​	再来回顾整个boot 流程</p>
<p>​	1、0xffff0 是 开机的第一条指令 ，跳转到bios，jump到0xfe50b，执行bios的代码</p>
<p>​	2、bios完成必要的一些初始化操作后， 会去扫描磁盘引导扇区，找bootloader，加载bootloader到0x7c00处，然后 bootloader 接管控制权（jump to 0x7c00）</p>
<p>​	3、boot.s 负责启动A20地址线，load <strong><font color='red'>GDT表？</font></strong>，完成实模式到保护模式的转变，然后设置栈指针(为c语言函数作准备) call bootmain(main.c)设置栈指针0x7c00，因为stack是向下增长的 所以不会覆盖bootloader</p>
<blockquote>
<p>向下增长的堆栈有助于利用线性地址空间和简化内存管理。例如，当调用函数时，新分配的局部变量和返回地址都放置在较低的地址空间，这样可以有效利用内存并保持堆栈的连续性。</p>
</blockquote>
<p>​	4、main.c 从 磁盘中读取 内核ELF文件 ，然后进Kernel的入口函数e_entry，启动内核</p>
<ul>
<li>
<p><em>Where</em> is the first instruction of the kernel?</p>
<p>same as the last question!</p>
</li>
<li>
<p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p>
</li>
</ul>
<p>Elf 文件格式</p>
<blockquote>
<p>Excercise5 Then change the link address in <code>boot/Makefrag</code> to something wrong, run make clean,</p>
<p>会发生什么？ 无限重启，为什么？因为默认是在0x7c00这个地找bootloader，电脑开机的时候，会先执行bios，bios完成必要的初始化之后，会去搜索所有的磁盘，然后从磁盘的第一个分区尝试找到一个引导程序，如果是合法的引导程序，就会按照引导程序的elf设置将这个程序加载到LMA所指定的地址，bios加载完之后，会默认跳转到0x7c00这个地址执行引导程序，那么如果引导程序没有被加载到这个地址，而是被加载到了0x7100，相当于跳转的地方没有合法的引导程序，SeaBios的实现可能就是无限重启</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241002111624.png" alt=""></p>
<p>修改之后-Ttext 0x7c00-&gt;0x8c00，<code>ljmp $0xb886, $0x87c23 -&gt; ljmp $0xb886, $0x88c32</code>;</p>
<p>这里明明加载到的是8c00，为什么gdb调试的时候，在7c00还是能看到执行的是8c00 的代码？</p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241002114002.png" alt=""></p>
<p>ljmp跳转 88c32  这个位置之后，实际上执行的是最开始的代码 ，</p>
<p>猜测过程应该是这样的，bios会把bootloader<strong>固定</strong>加载到 0x7c00这个地方，所以无论-Ttext 写的是多少，实际上0x7c00执行的第一句都是boot 的第一行，但是一旦涉及到符号跳转的地方就会出现问题，因为符号跳转使用的是绝对地址，而绝对地址（编译时使用的虚拟地址）的开始值是被设置成0x8c00，也就是ljmp跳转 88c32  ，这个时候就会出现错误，<font color='blue'>然后重新从0xfe05b开始执行，这里应该是bios接管了重新执行</font></p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241002114547.png" alt=""></p>
<h3 id="loading-the-kernel">Loading the Kernel</h3>
<p>ELF 文件格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">i386-elf-objdump -h obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000173b  f0100000  00100000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       00000714  f0101740  00101740  00002740  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         00000001  f0101e54  00101e54  00002e54  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .stabstr      00000001  f0101e55  00101e55  00002e55  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  4 .data         0000a300  f0102000  00102000  00003000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .bss          00000660  f010c300  0010c300  0000d300  2**5</span><br><span class="line">                  ALLOC</span><br><span class="line">  6 .comment      00000012  00000000  00000000  0000d300  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  7 .debug_info   0000067f  00000000  00000000  0000d312  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line">  8 .debug_abbrev 000002d0  00000000  00000000  0000d991  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line">  9 .debug_loclists 00000a11  00000000  00000000  0000dc61  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 10 .debug_aranges 00000040  00000000  00000000  0000e672  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 11 .debug_rnglists 00000051  00000000  00000000  0000e6b2  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 12 .debug_line   0000042e  00000000  00000000  0000e703  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br><span class="line"> 13 .debug_str    00000290  00000000  00000000  0000eb31  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING, OCTETS</span><br></pre></td></tr></table></figure>
<p>注释 ：</p>
<ul>
<li>
<p>VMA(link address)  LMA（load address）</p>
<blockquote>
<p>The load address of a section is the memory address at which that section should be loaded into memory.</p>
<p>就是实际load物理地址</p>
<p>The VMA of a section is the memory address from which the section expects to execute.</p>
<p>就是虚拟地址</p>
<p>The linker encodes the link address in the binary in various ways, such as when the code needs the address of a global variable, with the result that a binary usually won’t work if it is executing from an address that it is not linked for.</p>
</blockquote>
<p>通常 ，这俩应该是相等的</p>
</li>
<li>
<p>boot loader 使用ELF program headers来决定如何加载secctions，ELF program headers 指定了ELF的那部分需要加载到内存的哪个目标地址</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">                 CONTENTS, READONLY</span><br><span class="line">(base) casey@192 lab % objdump -x obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:        file format elf32-i386</span><br><span class="line">architecture: i386</span><br><span class="line">start address: 0x0010000c</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x0000c300 memsz 0x0000c960 flags rwx</span><br><span class="line"></span><br><span class="line">Dynamic Section:</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name            Size     VMA      LMA      Type</span><br><span class="line">  0                 00000000 00000000 00000000 </span><br><span class="line">  1 .text           0000173b f0100000 00100000 TEXT</span><br><span class="line">  2 .rodata         00000714 f0101740 00101740 DATA</span><br><span class="line">  3 .stab           00000001 f0101e54 00101e54 DATA</span><br><span class="line">  4 .stabstr        00000001 f0101e55 00101e55 </span><br><span class="line">  5 .data           0000a300 f0102000 00102000 DATA</span><br><span class="line">  6 .bss            00000660 f010c300 0010c300 BSS</span><br></pre></td></tr></table></figure>
<p>需要加载到内存的对象区域是标记为“LOAD”的区域，</p>
<ul>
<li>
<p>可以看到 内核的 加载地址 和 链接地址不是一样的， 内核告诉loader 将其加载到内存的低地址 00100000，但是他希望从高地址 f0100000开始执行，下一节介绍如何实现这一点</p>
</li>
<li>
<p>除了节信息之外，ELF 头中还有一个很重要的字段，名为 e_entry。此字段保存程序中入口点的链接地址：程序文本节中程序应开始执行的内存地址。可以看到入口点：<code>objdump -f obj/kern/kernel</code></p>
</li>
</ul>
<h2 id="the-kernel">The Kernel</h2>
<blockquote>
<p>Like the boot loader, the kernel begins with some assembly language code that sets things up so that C language code can execute properly.</p>
</blockquote>
<h3 id="using-virtual-memory-to-work-around-position-dependence">Using virtual memory to work around position dependence</h3>
<p>上一张说到boot loader的VMA LMA 一样的</p>
<p>但是 kernel的 VMA LMA不一致，这是因为：</p>
<p>操作系统内核通常喜欢链接并运行在非常高的<em>虚拟地址</em>上，例如 0xf0100000，以便将处理器虚拟地址空间的较低部分留给用户程序使用。</p>
<p>许多机器在地址 0xf0100000 处没有任何物理内存，因此不能指望能够将内核存储在那里。相反，我们将使用处理器的内存管理硬件将虚拟地址 0xf0100000（内核代码预期运行的链接地址*）*映射到物理地址 0x00100000（引导加载程序将内核加载到物理内存中的位置）。这样，尽管内核的虚拟地址足够高，可以为用户进程留出足够的虚拟地址空间，但它将加载到 PC RAM 中 1MB 位置的物理内存中，就在 BIOS ROM 上方。这种方法要求 PC 至少有几兆字节的物理内存（以便物理地址 0x00100000 可以工作），但对于 1990 年以后制造的任何 PC 来说，这很可能都是正确的。</p>
<p>在0x1000c处break 可以看到 在此处完成了虚拟地址的映射</p>
<p>也就是高地址 0xf0100000可以被访问了</p>
<p><mark style="background-color:red">怎么做到的？？</mark></p>
<h3 id="formatted-printing-to-the-console">Formatted Printing to the Console</h3>
<ol>
<li>Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</li>
</ol>
<p>printf负责提供打印的函数 putch ，cprintf ，vcprintf，</p>
<p><code>int cprintf(const char *fmt, ...)</code>  负责接收变参数列表变成va_list，然后调用<code>int vcprintf(const char *fmt, va_list ap)</code>，这里再调用vprintfmt函数格式化处理输出<code>vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)</code>，将变参数列表嵌入到format中，保存到<code>putdat</code>中，调用<code>putch</code>回调函数输出到console中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">putch</span><span class="params">(<span class="type">int</span> ch, <span class="type">int</span> *cnt)</span></span><br><span class="line">&#123;</span><br><span class="line">	cputchar(ch);</span><br><span class="line">	*cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cputchar就是consoles中的函数，负责将ch通过<mark style='background:yello'>与硬件交互真正地输出到终端上</mark></p>
<ol start="2">
<li>Explain the following from console.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>)); <span class="comment">//移动 腾出最后一行</span></span><br><span class="line">		<span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">			crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>; <span class="comment">//最后一行置为空格 也就是全部删除掉</span></span><br><span class="line">		crt_pos -= CRT_COLS;<span class="comment">//回到最后一行开始的位置以便继续向缓冲区输出数据</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>crt_buf 满了 清一下？</p>
<p>正确解释：用于<code>控制文本显示</code>的，具体来说，这段代码处理当字符缓冲区（crt_buf）满时需要<code>滚动屏幕</code>的情况，<code>CRT_SIZE</code>被设置为<code>25*80</code>， 也就是窗口支持显示25行，80列个字符串，现在显示满了，需要将缓冲区向上腾一行，也就是第二行往下的所有内容整体往上移动一行，腾出新的一行的空间，实现滚动的效果</p>
<ol start="3">
<li>Run the following code.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br></pre></td></tr></table></figure>
<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<blockquote>
<p>%s 需要的是一个 char * 的指针 ，所以传入的是一个指针</p>
</blockquote>
<p>如果是小端字节序，<code>unsigned int i</code> 在内存中的布局是</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>值</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;i</code></td>
<td><code>0x72</code></td>
<td><code>r</code></td>
</tr>
<tr>
<td><code>&amp;i+1</code></td>
<td><code>0x6c</code></td>
<td><code>l</code></td>
</tr>
<tr>
<td><code>&amp;i+2</code></td>
<td><code>0x64</code></td>
<td><code>d</code></td>
</tr>
<tr>
<td><code>&amp;i+3</code></td>
<td><code>0x00</code></td>
<td>null</td>
</tr>
</tbody>
</table>
<p>为了保持一样的结果 大端字节序的i 的值应该被设置成<code>0x726c6400</code>, 这样在内存的地址才和上面是保持一致的</p>
<p>但是 57616 不需要修改, 因为%x输出的就是十六进制，<mark style='background-color yello'>无论是小端还是大端系统，整数 <code>57616</code>（十进制）在以十六进制格式输出时都将表现为 <code>e110</code>。这是因为整数在内存中的存储顺序对其整体数值没有影响，只影响内存中字节的排列顺序，而 <code>%x</code> 只关心数值本身。</mark></p>
<ol start="4">
<li>In the following code, what is going to be printed after<code>'y='</code>? (note: the answer is not a specific value.) Why does this happen?</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure>
<p>输出将会是不确定的，因为，fmt需要两个参数 而va_list只有一个，在取第二个参数的时候，会取到不属于 cprintf 函数栈帧的数据 所以这其实是<font color='blue'>未定义的行为， 输出什么值都有可能</font></p>
<blockquote>
<p>补充</p>
<p>x86进栈顺序，按照函数参数声明的顺序，最后声明的参数将被第一个入栈</p>
<p>cprintf(“H%x Wo%s”, 57616, &amp;i);， 先入栈的是i的地址 然后是整数57616，最后是fmt字符串</p>
</blockquote>
<h4 id="exercise8">Exercise8</h4>
<p>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">			num = getuint(&amp;ap, lflag);</span><br><span class="line">			base = <span class="number">8</span>;</span><br><span class="line">			<span class="keyword">goto</span> number;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>在i386 init这个地方 <code>cprintf(&quot;\n6828 decimal is %o octal!\n&quot;, 6828);</code>,需要在格式串6828前面添加\n,否则过不了make grade</p>
<h3 id="the-stack">the Stack</h3>
<p>在x86架构的函数调用中，ebp（基址指针）是用来帮助管理栈帧的。假设函数A调用了函数B，函数B将当前的esp值复制到ebp中，这个操作实际上是函数B在为自己设置一个新的栈帧。在这种情况下，B并不是不能使用ebp，而是B使用ebp来指向自己的栈帧的起始位置。</p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003150047.png" alt=""></p>
<p>下面是一个具体的步骤说明：</p>
<ol>
<li>
<p><strong>函数A调用函数B</strong>：</p>
<ul>
<li>
<p>先把函数需要使用到的参数压入栈中</p>
</li>
<li>
<p>函数A执行<code>call B</code>指令，这会将返回地址压入栈中，然后跳转到函数B。</p>
</li>
</ul>
</li>
<li>
<p><strong>函数B的栈帧初始化</strong>：</p>
<ul>
<li>函数B开始执行时，通常会首先保存A的ebp值。这是通过<code>push ebp</code>实现的，将A的ebp值压入栈中。</li>
<li>然后，B将当前esp（A的栈顶）的值复制到ebp（B的栈底）中：<code>mov ebp, esp</code>。这一步创建了B自己的栈帧，ebp现在指向B的栈帧的起始位置。 <font color='blue'> 也就是设置B的栈底为A的栈顶 然后开始保护寄存器…</font></li>
</ul>
</li>
<li>
<p><strong>函数B的栈帧使用</strong>：</p>
<ul>
<li>在B的执行过程中，esp会随着局部变量和其他栈操作而改变，而ebp则保持不变，用于访问B的参数和局部变量。</li>
<li>由于ebp指向B的栈帧起始位置，B可以通过ebp+offset的方式访问自己的局部变量和参数。</li>
</ul>
</li>
<li>
<p><strong>函数B结束并返回到A</strong>：</p>
<ul>
<li>
<p>在函数B即将返回时，通常会恢复A的ebp值。这是通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<p>实现的：</p>
<ul>
<li><code>mov esp, ebp</code>：将esp恢复到B的栈帧起始位置，这样可以正确弹出返回地址。</li>
<li><code>pop ebp</code>：将A的ebp值弹出栈，并恢复到ebp寄存器。</li>
<li><font color='blue'>这两条在实际实现中 使用<code>leave</code> 来实现</font></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave // 清除当前函数的栈帧</span><br><span class="line">ret // 这一步 对应一开始的call ，弹出地址，设置eip</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003113003.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003104512.png" alt=""></p>
</li>
<li>
<p><strong>函数A继续执行</strong>：</p>
<ul>
<li>函数B返回后，esp指向A的栈帧的原位置，并且ebp也恢复为A的值。</li>
</ul>
</li>
</ol>
<p>通过这种机制，每个函数在调用过程中都可以使用ebp来管理自己的栈帧，而不会干扰其他函数的栈帧。因为ebp在发生函数调用的时候，会被push保护起来，因此，ebp是可以被每个函数独立使用的。</p>
<h3 id="问题">问题</h3>
<p>1、为什么是mov %esp， %ebp</p>
<p>mov dest, source 那么这里就是把ebp 复制到esp，是不是写反了？？？</p>
<p>往上查到的 是mov dest，source</p>
<p>但是这个jos实验所用的架构好像是先source 再dest</p>
<p>如<code>f010011d movl $0x5, (%esp)</code>;</p>
<p>2、为什么第一个参数是以<code>movl $0x5, (%esp)</code> 的形式入栈，而其他是以push入栈？</p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003150251.png" alt=""></p>
<p>因为esp这个时候是上一个函数的参数，5，这里参数不太清楚，把stack_test(1,2,3,4,6)最后一参数换成6，gdb调试一下;</p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003151940.png" alt=""></p>
<p><font color='blue'>也就是这里的栈顶放的是上一个函数的入参，但是已经不需要用了，所以就直接movl 覆盖掉就好了</font></p>
<h3 id="思考">思考</h3>
<p>为什么在函数开始的地方需要保存ebx？</p>
<p>参见<font color='blue'>csapp 173</font> 寄存器分为被调用者保存寄存器和调用者保存寄存器</p>
<p><strong>被调用者保存寄存器</strong> rbx rbq r12-r15</p>
<p>P调用Q的时候，Q必须保存这些寄存器， <font color='red'>保护这些寄存器是被调用者的责任，如果需要使用这些寄存器的话，就必须push（保护 和pop（恢复</font></p>
<p><strong>调用者保存寄存器</strong> 处理上面这些寄存器和rsp， 都是调用者保存寄存器</p>
<p><font color='blue'> 调用者保存，因为任何函数都可以使用这类寄存器，如果过程P在这类寄存器有局部数据，就必须自己保存，因为其他过程可以随便修改这类寄存器</font></p>
<p>为什么这么设置，这是x86-64的惯例！</p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241003123418.png" alt=""></p>
<h1 id="运行结果">运行结果</h1>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241001163923.png" alt=""></p>
<h4 id="exercise-10-12">exercise 10 - 12</h4>
<p>实现内核调用栈回溯</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">	<span class="type">uint32_t</span> ebp, eip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="comment">//指针学习</span></span><br><span class="line">    <span class="comment">//+1实际上偏移的是4bytes</span></span><br><span class="line">    <span class="keyword">for</span>(ebp=read_ebp(); ebp!=<span class="number">0</span>; ebp=*((<span class="type">uint32_t</span> *)ebp))&#123;</span><br><span class="line">        eip = *((<span class="type">uint32_t</span> *)ebp+<span class="number">1</span>);</span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,</span><br><span class="line">                    ebp, eip, *((<span class="type">uint32_t</span> *)ebp+<span class="number">2</span>), *((<span class="type">uint32_t</span> *)ebp+<span class="number">3</span>), </span><br><span class="line">                    *((<span class="type">uint32_t</span> *)ebp+<span class="number">4</span>), *((<span class="type">uint32_t</span> *)ebp+<span class="number">5</span>), *((<span class="type">uint32_t</span> *)ebp+<span class="number">5</span>), </span><br><span class="line">                    *((<span class="type">uint32_t</span> *)ebp+<span class="number">6</span>));</span><br><span class="line">                    <span class="comment">//.有截断的能力，*能够让eip_fn_namelen阶段字符串</span></span><br><span class="line">        cprintf(<span class="string">&quot;         %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, </span><br><span class="line">                            info.eip_fn_namelen, info.eip_fn_name, eip-info.eip_fn_addr);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在debuginfo_eip中需要补充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">info-&gt;eip_line = lline &gt; rline ? <span class="number">-1</span> : stabs[lline].n_desc;</span><br></pre></td></tr></table></figure>
<h1 id="挑战">挑战</h1>
<p><em>Challenge</em> Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret <a target="_blank" rel="noopener" href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/">ANSI escape sequences</a> embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/reference.html">the 6.828 reference page</a> and elsewhere on the web on programming the VGA display hardware. If you’re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</p>
<p>我们知道参数是按照声明顺序从右到左入栈的，也就是最后所有的参数入栈之后，最下面的那个（栈顶）应该是第一个参数。思考如下问题</p>
<p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	cnt = vcprintf(fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回答">回答</h3>
<p>int cprintf(const char *fmt, …) 这里应该被改成int cprintf(…, const char *fmt)</p>
<p>同时va_xxx对format的遍历应该从末尾开始，因为从左到右压入栈之后，栈顶第一个元素是最末尾的参数，为了匹配参数大小，应该从format的末尾开始</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://jeycechen.github.com">冷静一下</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://jeycechen.github.com/2024/10/04/6-828-lab1/">http://jeycechen.github.com/2024/10/04/6-828-lab1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jeycechen.github.com" target="_blank">冷静一下's bolg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/boot/">boot</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/07/jos-lab2/" title="jos_lab2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jos_lab2</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/18/epoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="epoll实现原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">epoll实现原理</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冷静一下</div><div class="author-info__description">一个小菜鸟</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jeycechen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jeycechen" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/cklnuaa@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab1"><span class="toc-number">1.</span> <span class="toc-text">lab1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">环境配置和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pc-bootstrap"><span class="toc-number">1.2.</span> <span class="toc-text">PC Bootstrap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pc%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.1.</span> <span class="toc-text">PC的物理地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-rom-bios"><span class="toc-number">1.2.2.</span> <span class="toc-text">The ROM BIOS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-boot-loader"><span class="toc-number">1.3.</span> <span class="toc-text">The Boot Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#answer-questions"><span class="toc-number">1.3.1.</span> <span class="toc-text">Answer Questions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loading-the-kernel"><span class="toc-number">1.3.2.</span> <span class="toc-text">Loading the Kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-kernel"><span class="toc-number">1.4.</span> <span class="toc-text">The Kernel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using-virtual-memory-to-work-around-position-dependence"><span class="toc-number">1.4.1.</span> <span class="toc-text">Using virtual memory to work around position dependence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#formatted-printing-to-the-console"><span class="toc-number">1.4.2.</span> <span class="toc-text">Formatted Printing to the Console</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise8"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Exercise8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-stack"><span class="toc-number">1.4.3.</span> <span class="toc-text">the Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">1.4.5.</span> <span class="toc-text">思考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">2.</span> <span class="toc-text">运行结果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-10-12"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">exercise 10 - 12</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%91%E6%88%98"><span class="toc-number">3.</span> <span class="toc-text">挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94"><span class="toc-number">3.0.1.</span> <span class="toc-text">回答</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/07/jos-lab2/" title="jos_lab2">jos_lab2</a><time datetime="2024-10-07T15:50:46.000Z" title="发表于 2024-10-07 23:50:46">2024-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/04/6-828-lab1/" title="jos_lab1">jos_lab1</a><time datetime="2024-10-04T03:21:03.000Z" title="发表于 2024-10-04 11:21:03">2024-10-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/18/epoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="epoll实现原理">epoll实现原理</a><time datetime="2024-09-18T13:11:54.000Z" title="发表于 2024-09-18 21:11:54">2024-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/task-struct%E8%AF%A6%E8%A7%A3/" title="task_struct详解">task_struct详解</a><time datetime="2024-09-11T16:14:29.000Z" title="发表于 2024-09-12 00:14:29">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/ac-tricks/" title="ac_tricks">ac_tricks</a><time datetime="2024-09-09T13:15:03.000Z" title="发表于 2024-09-09 21:15:03">2024-09-09</time></div></div></div></div><div class="card-widget"><div class="item-headline"><i class="fas fa-cubes"></i><span>系列合集</span></div><div class="collections-item-content"><a href="文章1url">面试合集</a></div><div class="collections-item-content"><a href="文章2url">名称2</a></div></div></div></div></main><footer id="footer" style="background-image: url('/img/staring_star_sky.JPG')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冷静一下</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liKf4gi0DpLa4i2u',
      clientSecret: '80d1c4128ced9c69f894028dd98211b70e94d2ca',
      repo: 'jeycechen.github.io',
      owner: 'jeycechen',
      admin: ['jeycechen'],
      id: '9180eebf4ef2f2d66841bc6c3f0c5821',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>