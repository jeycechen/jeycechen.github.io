<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>jos_lab2 | 冷静一下's bolg</title><meta name="author" content="冷静一下,cklnuaa@163.com"><meta name="copyright" content="冷静一下"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="introduction 本lab要实现一个内存管理的代码，Memory management has two components：  Physical memoru allocator 以4096 bytes（pages）作为最小操作单元，需要维护一个数据结构，记录哪些页面是已经分配的，哪些是空闲的 virtual memory：将程序和内核使用的虚拟地址映射为真实的物理地址，MMU使用页表在">
<meta property="og:type" content="article">
<meta property="og:title" content="jos_lab2">
<meta property="og:url" content="http://jeycechen.github.com/2024/10/07/jos-lab2/index.html">
<meta property="og:site_name" content="冷静一下&#39;s bolg">
<meta property="og:description" content="introduction 本lab要实现一个内存管理的代码，Memory management has two components：  Physical memoru allocator 以4096 bytes（pages）作为最小操作单元，需要维护一个数据结构，记录哪些页面是已经分配的，哪些是空闲的 virtual memory：将程序和内核使用的虚拟地址映射为真实的物理地址，MMU使用页表在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG">
<meta property="article:published_time" content="2024-10-07T15:50:46.000Z">
<meta property="article:modified_time" content="2024-10-07T15:51:24.332Z">
<meta property="article:author" content="冷静一下">
<meta property="article:tag" content="jos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jeycechen.github.com/2024/10/07/jos-lab2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'jos_lab2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-07 23:51:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/collections.css"><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/staring_star_sky.JPG')"><nav id="nav"><span id="blog-info"><a href="/" title="冷静一下's bolg"><span class="site-name">冷静一下's bolg</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">jos_lab2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-07T15:50:46.000Z" title="发表于 2024-10-07 23:50:46">2024-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-07T15:51:24.332Z" title="更新于 2024-10-07 23:51:24">2024-10-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="jos_lab2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="introduction">introduction</h1>
<p>本lab要实现一个内存管理的代码，Memory management has two components：</p>
<ul>
<li>Physical memoru allocator 以4096 bytes（pages）作为最小操作单元，需要维护一个数据结构，记录哪些页面是已经分配的，哪些是空闲的</li>
<li>virtual memory：将程序和内核使用的虚拟地址映射为真实的物理地址，MMU使用页表在使用虚拟地址的时候进行映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                Permissions</span></span><br><span class="line"><span class="comment"> *                                                    kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4 Gig --------&gt;  +------------------------------+</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     |   Remapped Physical Memory   | RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span></span><br><span class="line"><span class="comment"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span></span><br><span class="line"><span class="comment"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span></span><br><span class="line"><span class="comment"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span></span><br><span class="line"><span class="comment"> *                     |          RO PAGES            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span></span><br><span class="line"><span class="comment"> *                     |           RO ENVS            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span></span><br><span class="line"><span class="comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebff000</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span></span><br><span class="line"><span class="comment"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span></span><br><span class="line"><span class="comment"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebfd000</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span></span><br><span class="line"><span class="comment"> *                     |     Program Data &amp; Heap      |</span></span><br><span class="line"><span class="comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |  User STAB Data (optional)   |                 PTSIZE</span></span><br><span class="line"><span class="comment"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *    0 ------------&gt;  +------------------------------+                 --+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="getting-started">Getting Started</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m message</span><br><span class="line">git checkout -b lab2 origin/lab2</span><br><span class="line">git merge lab1</span><br></pre></td></tr></table></figure>
<p>新的文件</p>
<ul>
<li>
<p><code>inc/memlayout.h</code> 描述了虚拟地址空间的布局</p>
</li>
<li>
<p><code>kern/pmap.c</code>  用来实现 memlayout 的布局</p>
</li>
<li>
<p><code>kern/pmap.h</code></p>
</li>
<li>
<p><code>kern/kclock.h</code>  操作PC的电池供电时钟和CMOS RAM 硬件（BIOS在其中记录了PC的物理内存量）</p>
<p>The code in <code>pmap.c</code> needs to read this device hardware in order to figure out how much physical memory there is, but that part of the code is done for you: you do not need to know the details of how the CMOS hardware works.</p>
</li>
<li>
<p><code>kern/kclock.c</code></p>
</li>
</ul>
<h1 id="part1-physical-page-management">Part1 Physical Page Management</h1>
<p>编写一个物理页面分配器，使用struct PageInfo的链表来跟踪哪些页面是空闲的，在实现虚拟内存之前必须先实现一个物理内存分配器</p>
<h3 id="exercise1">Exercise1</h3>
<blockquote>
<p>In the file <code>kern/pmap.c</code>, you must implement code for the following functions (probably in the order given).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init() (only up to the call to `check_page_free_list(<span class="number">1</span>)`)</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>
<p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004105710.png" alt=""></p>
<h4 id="boot-alloc">boot_alloc</h4>
<p>为什么需要boot_alloc， 管理页表需要一个page directory，创建一个page director就是创建一个page，就陷入了死锁，所以boot_alloc就是打破僵局的第一次分配的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">	<span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line">	<span class="comment">// which points to the end of the kernel&#x27;s bss segment: end 是链接器产生的， 指向了bss段的末尾 也就是从kernel的末尾开始</span></span><br><span class="line">	<span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">	<span class="comment">// to any kernel code or global variables. 这里应该说的是nextfree 应该是linker没有分配给任何内核代码和全局变量的第一个虚拟地址</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span></span><br><span class="line">	<span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">	<span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 2: Your code here.</span></span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP(nextfree + n, PGSIZE); <span class="comment">//分配 n bytes字节的内存，根据PGSIZE向上取整</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uint32_t</span>) nextfree - KERNBASE &gt; (npages * PGSIZE))&#123; <span class="comment">// 如果超出最大内存 OOM！</span></span><br><span class="line">		panic(<span class="string">&quot;Out of Memory!&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="page-init">page_init</h4>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004163627.png" alt=""></p>
<p>IDT 0-4k 设置为使用</p>
<p>base_mem 4k_640k 设置为未使用</p>
<p>io hole 640 - 1024k 设置为使用</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>1024</mn><mo>−</mo><mn>640</mn></mrow><mn>4</mn></mfrac><mo>=</mo><mn>96</mn></mrow><annotation encoding="application/x-tex">\frac{1024-640}{4} = 96
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">6</span></span></span></span></span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">	<span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">	<span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">	<span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">	<span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line">	<span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">	<span class="comment">//     is free.</span></span><br><span class="line">	<span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">	<span class="comment">//     never be allocated.</span></span><br><span class="line">	<span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">	<span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">	<span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">	<span class="comment">//     page tables and other data structures?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Change the code to reflect this.</span></span><br><span class="line">	<span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">	<span class="comment">// free pages!</span></span><br><span class="line">	<span class="comment">// size_t i;</span></span><br><span class="line">	<span class="comment">// for (i = 0; i &lt; npages; i++) &#123;</span></span><br><span class="line">	<span class="comment">// 	pages[i].pp_ref = 0;</span></span><br><span class="line">	<span class="comment">// 	pages[i].pp_link = page_free_list;</span></span><br><span class="line">	<span class="comment">// 	page_free_list = &amp;pages[i];</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">    <span class="comment">//boot_alloc(0)获取之前分配到的空闲页的首地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> pages_in_use_end =</span><br><span class="line">        npages_basemem + <span class="number">96</span> + ((<span class="type">uint32_t</span>)boot_alloc(<span class="number">0</span>) - KERNBASE) / PGSIZE;</span><br><span class="line">    <span class="comment">// pages_in_use_end = 600;</span></span><br><span class="line">    cprintf(<span class="string">&quot;now in use: %d\n&quot;</span>, pages_in_use_end);</span><br><span class="line">    <span class="comment">//设置让第0页为使用</span></span><br><span class="line">    cprintf(<span class="string">&quot;%08x %08x\n&quot;</span>, pages, (<span class="type">uint32_t</span>)boot_alloc(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//第0页用于存放real-mode IDT (interrupt descriptor table)and BIOS structures</span></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list; </span><br><span class="line">        page_free_list = &amp;pages[i]; <span class="comment">// 形成一个链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// I/O</span></span><br><span class="line">    <span class="keyword">for</span> (i = npages_basemem; i &lt; pages_in_use_end; ++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = pages_in_use_end; i &lt; npages; ++i) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="page-alloc">page_alloc</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">if</span>(!page_free_list) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//没有可用的空页面， return NULL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">ret</span> =</span> page_free_list;</span><br><span class="line">	page_free_list = page_free_list-&gt;pp_link; <span class="comment">// 让page_free_list 指向下一个空页面</span></span><br><span class="line">	ret-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(ret), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="page-free">page_free</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">	<span class="keyword">if</span>(pp-&gt;ref || pp-&gt;pp_link)&#123; <span class="comment">// 引用计数不为0 或者 pp-&gt;link不为0 panic</span></span><br><span class="line">		panic(<span class="string">&quot;free page error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="part-2-virtual-memory">Part 2: virtual memory</h1>
<h3 id="exercise2">Exercise2</h3>
<blockquote>
<p>Look at chapters 5 and 6 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm">Intel 80386 Reference Manual</a>, if you haven’t done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004185220.png" alt=""></p>
<p>80386 分为两个步骤将逻辑地址转换成为物理地址</p>
<ul>
<li>段转换，逻辑地址（段选择子 + 段偏移量）转化成线性地址</li>
<li>页面转换，将线性地址转换为物理地址</li>
</ul>
<h4 id="segement-translation">segement translation</h4>
<h5 id="descriptors">Descriptors</h5>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004185327.png" alt=""></p>
<p>BASE：定义了4GB的线性地址空间的 段的位置，处理器将base 的三个片段结合起来，形成一个32位的值</p>
<p>LIMIT：定义了段的大小，processor拼接起来20bit，limit的单位取决于 granularity bit 位，</p>
<ul>
<li>一种单位是1 byte，那么一个段的大小是就是1M</li>
<li>一种单位是4KB，那么一个段的大小就是4GB，</li>
</ul>
<p>Grandularity:指定limit的单位，0表示1Byte，1 表示4KB</p>
<p>Type：区分不同的descriptors</p>
<p>DPL（Descriptor Privilege Level）：在伯虎模式下使用</p>
<p>Segment-Present：0 表示不可用，处理器抛出异常。</p>
<blockquote>
<p>在什么情况下会清除此bit？</p>
</blockquote>
<ul>
<li>内存中不存在这个段的时候</li>
<li>当这个段跨越的线性地址还没有被分页机制映射的时候</li>
</ul>
<p>Accessed bit:  处理器在访问段的时候设置此位，</p>
<h5 id="描述符表">描述符表</h5>
<p>段描述符存储在以下两种描述符表中</p>
<ul>
<li>GDT 全局描述符表</li>
<li>LDT 本地描述符表</li>
</ul>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004213502.png" alt=""></p>
<p>描述符表是 A descriptor table is simply a memory array of 8-byte entries that contain descriptors，描述符表的长度最多可以包含8192个描述符，GDT的第一个不被使用</p>
<p>GDTR 和 LDTR寄存器在内存中定位GDT和当前LDT，</p>
<p>指令LGDT 和SGDT ----  访问GDTR</p>
<p>指令LLDT 和SLDT — 访问LDTR</p>
<h5 id="selectors">Selectors</h5>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004214624.png" alt=""></p>
<p>逻辑地址的selector部分</p>
<p>index 13bit， 作用是选择8192中的一个</p>
<p>Table Indicator 0表示使用GDT 1 表示使用LDT</p>
<p>Requestor’s Privilege Level: used by protection mechanism</p>
<blockquote>
<p>Because the first entry of the GDT is not used by the processor, a selector that has an index of zero and a table indicator of zero (i.e., a selector that points to the first entry of the GDT), can be used as a null selector. The processor does not cause an exception when a segment register (other than CS or SS) is loaded with a null selector. It will, however, cause an exception when the segment register is used to access memory. This feature is useful for initializing unused segment registers so as to trap accidental references</p>
</blockquote>
<h5 id="段寄存器">段寄存器</h5>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004215418.png" alt=""></p>
<p>80386将描述符的信息存储在段寄存器中，从而无需在每次访问内存的时候查描述符表</p>
<p>段寄存器的可见部分由程序操作，hidden part 由处理器操作，就像这只是一个普通的16bit寄存器</p>
<p>加载寄存器操作是普通的程序指令，这些指令分为两类</p>
<ul>
<li>直接加载，MOV POP LDS LSS LGS LFS</li>
<li>隐式加载，如far call 和 JMP</li>
</ul>
<p>使用这些指令，程序使用16bit 的selector加载值到可见部分，处理器会根据selector去找到描述符表的base limit … 信息填到hidden part里面</p>
<blockquote>
<p>Because most instructions refer to data in segments whose selectors have already been loaded into segment registers, the processor can add the segment-relative offset supplied by the instruction to the segment base address with no additional overhead.</p>
<p>局部性原理</p>
</blockquote>
<h4 id="page-translation">page translation</h4>
<p>可选的步骤，在CR0 的PG位被设置的时候，page translation是可用的</p>
<p>page frame 是物理内存中连续地址的4k字节单元，从字节边界开始</p>
<h5 id="linear-address">linear address</h5>
<p>段翻译出来的地址就是linear地址 开启page translation之后</p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004222418.png" alt=""></p>
<p>当前页目录的物理地址存放在CPU寄存器CR3中，也被称为页目录基址寄存器page directory base register (PDBR), PAGE directory中的32位都用来保存page table 的开始地址</p>
<p>一个PTE的格式</p>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241004222946.png" alt=""></p>
<h5 id="page-translation-cache-tlb">page translation cache TLB</h5>
<p>这个缓冲对应用程序是不可见的，但是对于系统程序员，需要在切换页表的时候flush cache，可以通过两种方式flush</p>
<ul>
<li>reload CR3 with MOV eg, <code>MOV CR3, EAX;</code></li>
<li>执行任务切换到具有与当前TSS不同的CR3映像的TSS（task state segment）</li>
</ul>
<h4 id="分段-分页">分段 &amp;&amp; 分页</h4>
<p>可以通过设置的方式屏蔽分段</p>
<p>… 还有一堆没看懂</p>
<h4 id="保护机制">保护机制</h4>
<h5 id="segment-level-protection">segment-level protection</h5>
<p>… to be continue</p>
<h2 id="virtual-linear-and-physical-address">Virtual , linear, and physical Address</h2>
<p>x86中，虚拟地址由段选择器和段内偏移（逻辑地址）组成，为什么这么麻烦？</p>
<p>因为，8086处理器有20位地址线，但是只有16位的寻址寄存器，为了访问20的空间，只能采用<code>CS:IP</code> 的方式，也就是通过CS*16 + IP 的方式来访问，后继的产品为了兼容，也保留了这个设计</p>
<p>虚拟地址 = 逻辑地址 ----&gt; 线性地址 ----&gt;物理地址</p>
<p>JOS</p>
<h3 id="引用计数">引用计数</h3>
<p>可能会有多个虚拟地址被映射到了同一个物理页面，为了防止释放的时候发生问题，需要使用引用计数来跟踪每个物理页的引用次数，计数变为0的时候，就可以被回收，</p>
<p>Page_alloc 返回的页面他的引用计数必须是0，如果对返回的页面进行了操作，比如插入页表，就应该增加ref</p>
<h3 id="页表管理">页表管理</h3>
<h4 id="exercise4">exercise4</h4>
<blockquote>
<p>In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()</span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()</span><br><span class="line">page_insert()</span><br></pre></td></tr></table></figure>
<p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p>
</blockquote>
<h5 id="pgdir-walk">pgdir_walk()</h5>
<p>从pgdir 中依据虚拟地址va找到对应的pte_t 返回,  create == 1 表示不存在的时候创建page table</p>
<p>hint: <font color='blue'>判断不存在 不能使用pgdir_entry == NULL 来判断 要使用 !(*pgdir_entry &amp; PTE_P) 这个来判断</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> * </span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// 返回的是一个虚拟地址</span></span><br><span class="line">	assert(pgdir);</span><br><span class="line">	<span class="type">pde_t</span> *pgdir_entry = &amp;pgdir[PDX(va)]; <span class="comment">// 获取二级页表page table pages的地址</span></span><br><span class="line">	<span class="comment">// 可能不存在</span></span><br><span class="line">	<span class="keyword">if</span>(!(*pgdir_entry &amp; PTE_P))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!create) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">// 否则就是需要create</span></span><br><span class="line">			<span class="keyword">struct</span> PageInfo * new_page = page_alloc(ALLOC_ZERO);	 <span class="comment">// 这里是虚拟地址</span></span><br><span class="line">			<span class="keyword">if</span>(new_page == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 分配新页面失败</span></span><br><span class="line">			*pgdir_entry = (page2pa(new_page) | PTE_P | PTE_W | PTE_U); </span><br><span class="line">			++(new_page-&gt;pp_ref); <span class="comment">// 需要加锁吗？目前应该是单核</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		PTE_ADDR(pte)	((physaddr_t) (pte) &amp; ~0xFFF)  就是low 12bit 置0， 12bit代表4KB，物理页面对齐，所以这里就是page table的起始地址</span></span><br><span class="line"><span class="comment">		再加上PTX(va) 获取真正的 pte的物理地址</span></span><br><span class="line"><span class="comment">		因为返回的是一个虚拟地址，所以需要使用KADDR() 对 pte的物理地址做转换，转化成其对应的虚拟地址</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">pte_t</span> *) (KADDR(PTE_ADDR(*pgdir_entry))) + PTX(va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="boot-map-region">boot_map_region()</h5>
<p>把[va, va + size) 映射到 [pa, pa + size) 也就是设置va的页面地址为pa ，类推</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// 怎么映射？？ 就是把页表中对应的虚拟地址设置为对应的物理地址！！</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">pte_t</span> *new_pte;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; size;i += PGSIZE, va += PGSIZE, pa += PGSIZE)&#123;</span><br><span class="line">		new_pte = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>); <span class="comment">// 获得了[va + i * PGSIZE, va + (i + 1) * PGSIZE) 所分配的PTE</span></span><br><span class="line">		<span class="comment">// 现在需要将这个new_pte 指向 pa + i * PGSIZE 这个物理页面；</span></span><br><span class="line">		*new_pte = pa | perm | PTE_P; <span class="comment">// 设置页面，+ 权限</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-lookup">page_lookup()</h5>
<p>找到va这个物理页是由哪个 PageInfo结构体管理的，</p>
<blockquote>
<p>pte_store的作用是什么？</p>
</blockquote>
<p>把这个页面的虚拟地址通过 pte_store 传递出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// cprintf(&quot;%p\n&quot;, va);</span></span><br><span class="line">	<span class="type">pte_t</span> *pgtable_entry = pgdir_walk(pgdir, va, <span class="number">0</span>); <span class="comment">// 这里返回的是一个虚拟地址</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pgtable_entry || !(*pgtable_entry &amp; PTE_P)) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//pgtable_entry为空 或者 不为空但是 present-bit无效</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != pte_store) &#123;</span><br><span class="line">		*pte_store = pgtable_entry; <span class="comment">// 这里是让 pte_store 放这个 虚拟地址吗？？？ 因为需要返回 pte* 只能通过参数传递返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*pte 就是这个pte所指向的物理页的地址</span></span><br><span class="line"><span class="comment">		PTE_ADDR 就是这个pte在其pagetable的地址 其实真的有必要用PTE_ADDR吗？？，*pte一定是指向一个物理页的起始，物理页一定是低12bit 为0 的， </span></span><br><span class="line"><span class="comment">		但是*pte 还包含了权限位这些信息，所以 必须使用PTE_ADDR 来去掉权限位</span></span><br><span class="line"><span class="comment">		最后 使用pa2page() 获取其页面信息</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	<span class="keyword">return</span> pa2page(PTE_ADDR(*pgtable_entry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-remove">page_remove()</h5>
<p>va 映射到了一个page，现在就需要uninstall 这种映射</p>
<blockquote>
<p>如何uninstall？</p>
</blockquote>
<p>需要做三件事情：</p>
<ul>
<li>
<p>找到这个va所对应的pte*，设置为NULL</p>
</li>
<li>
<p>取消这个va在TLB的缓存，invalidate</p>
</li>
<li>
<p>对应物理页面的PageInfo 引用计数-1，如果是0了，就设置为free 页面，然后串联到page_free_list 中</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span> *pgtable_entry;</span><br><span class="line">	<span class="comment">// how to remove ???</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> =</span> page_lookup(pgdir, va, &amp;pgtable_entry);</span><br><span class="line">	<span class="keyword">if</span>(pp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	page_decref(pp); <span class="comment">// 这个函数里面实现了回收</span></span><br><span class="line">	tlb_invalidate(pgdir, va); <span class="comment">// invalidate the tlb of pte</span></span><br><span class="line">	*pgtable_entry = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-insert">page_insert()</h5>
<p>将pp这个页面插入到va这个虚拟地址的映射中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>); <span class="comment">// </span></span><br><span class="line">	<span class="keyword">if</span>(pte == <span class="literal">NULL</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	++pp-&gt;pp_ref;</span><br><span class="line">	<span class="keyword">if</span>((*pte) &amp; PTE_P)&#123;</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	&#125;</span><br><span class="line">	*pte = page2pa(pp) | perm | PTE_P;</span><br><span class="line">	*(pgdir + PDX(va)) |= perm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="part-3-kernel-address-space">Part 3: Kernel Address Space</h1>
<p>jos 将处理器的32位线性地址空间划分为2部分</p>
<p>下半部分 User environments，在lab3会管理这部分，</p>
<p>上半部分将由内核完全控制，ulim设置为内核保留了256M的虚拟地址空间，</p>
<blockquote>
<p>This explains why we needed to give the kernel such a high link address in lab 1: otherwise there would not be enough room in the kernel’s virtual address space to map in a user environment below it at the same time.</p>
<p>也就是内核还需要留出虚拟的地址空间来映射下方的user虚拟地址空间</p>
</blockquote>
<h2 id="permissions-and-fault-isolation">Permissions and Fault Isolation</h2>
<p>[ULIM, ) 只有内核能够访问</p>
<p>[UTOP, ULIM)  都能够读，但是不能够访问，实际上 这部分是内核向用户态暴露的一些系统的信息，方便用户进行读取和调用</p>
<p>[0, UTOP) 用户态可以自由的进行权限的控制</p>
<blockquote>
<p>Since kernel and user memory are both present in each environment’s address space, we will have to use permission bits in our x86 page tables to allow user code access only to the user part of the address space. Otherwise bugs in user code might overwrite kernel data, causing a crash or more subtle malfunction; user code might also be able to steal other environments’ private data. Note that the writable permission bit (<code>PTE_W</code>) affects both user and kernel code!</p>
</blockquote>
<h2 id="initializing-the-kernel-address-space">Initializing the Kernel Address Space</h2>
<p>设置UTOP之上的地址空间</p>
<h3 id="exercise5">Exercise5</h3>
<blockquote>
<p>Fill in the missing code in <code>mem_init()</code> after the call to <code>check_page()</code>.</p>
<p>Your code should now pass the <code>check_kern_pgdir()</code> and <code>check_page_installed_pgdir()</code> checks.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, (<span class="number">0xffffffff</span>-KERNBASE), <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个把pages的物理地址用了？pages[0] 在page_init这个函数不是用来放0-4k 这个页面的pageinfo了吗？？？</p>
</blockquote>
<p><font color='blue'>这里要区分PADDR和page2pa的区别，PADDR是这个page结构体的物理地址，page2pa得到的是这个PageInfo所关联的物理页的起始地址, 这里做的事情，就是按照memorylayout的布局把虚拟地址和物理地址做一个关联，这里的关联包括更新页表</font></p>
<h3 id="questions">Questions</h3>
<ol start="2">
<li>
<p>填充下列表格</p>
<table>
<thead>
<tr>
<th>Entry</th>
<th>Base Virtual Address</th>
<th>Points to (logically):</th>
</tr>
</thead>
<tbody>
<tr>
<td>1023</td>
<td>0xFFF00000</td>
<td>Page table for top 4MB of phys memory</td>
</tr>
<tr>
<td>1022</td>
<td>0xFFB00000</td>
<td>?</td>
</tr>
<tr>
<td>960</td>
<td>0xf000000</td>
<td>KERNBASE</td>
</tr>
<tr>
<td>959</td>
<td>0xefff8000</td>
<td>Kernel Stack</td>
</tr>
<tr>
<td>957</td>
<td>0xef40000</td>
<td>Page directory(UVPT)</td>
</tr>
<tr>
<td>956</td>
<td>0xef000000</td>
<td>PageInfo array(RO PAGES)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p>
<p>分段机制 + 用户态的程序不能访问 不带有PTE_U标志的页面， 这些权限访问的标志位在page table中</p>
</li>
<li>
<p>What is the maximum amount of physical memory that this operating system can support? Why?</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mi>K</mi><mi>E</mi><mi>R</mi><mi>N</mi><mi>B</mi><mi>A</mi><mi>S</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">2^{32} - KERNBASE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></p>
</li>
<li>
<p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p>
<p>管理的开销 1 page directory + 1024 page table + 0xF00000 pageinfo = 12MB</p>
<p><font color='blue'>为什么page table 下面的内容不用计算，因为page table 更下一层次就是page frame 用来存放实际的内容而不是存管理相关的信息</font></p>
</li>
<li>
<p>Revisit the page table setup in <code>kern/entry.S</code> and <code>kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p>
</li>
</ol>
<h2 id="address-space-layout-alternatives">Address Space Layout Alternatives</h2>
<p>JOS中使用的地址空间布局方案并不是唯一可行的，甚至可以把整个地址空间给用户空间</p>
<blockquote>
<p>Hint: the technique is sometimes known as “<em>follow the bouncing kernel</em>.”</p>
</blockquote>
<p>challenge 略</p>
<h1 id="pass">PASS</h1>
<p><img src="https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20241007233711.png" alt=""></p>
<p>ld 有个warning 可以注意下</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://jeycechen.github.com">冷静一下</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://jeycechen.github.com/2024/10/07/jos-lab2/">http://jeycechen.github.com/2024/10/07/jos-lab2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jeycechen.github.com" target="_blank">冷静一下's bolg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/jos/">jos</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/10/04/6-828-lab1/" title="jos_lab1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">jos_lab1</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/jeycechen/pics_bed/main/IMG_321_new.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冷静一下</div><div class="author-info__description">一个小菜鸟</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jeycechen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jeycechen" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/cklnuaa@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#introduction"><span class="toc-number">1.</span> <span class="toc-text">introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#getting-started"><span class="toc-number">1.1.</span> <span class="toc-text">Getting Started</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#part1-physical-page-management"><span class="toc-number">2.</span> <span class="toc-text">Part1 Physical Page Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise1"><span class="toc-number">2.0.1.</span> <span class="toc-text">Exercise1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#boot-alloc"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">boot_alloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#page-init"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">page_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#page-alloc"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">page_alloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#page-free"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">page_free</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#part-2-virtual-memory"><span class="toc-number">3.</span> <span class="toc-text">Part 2: virtual memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise2"><span class="toc-number">3.0.1.</span> <span class="toc-text">Exercise2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#segement-translation"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">segement translation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#descriptors"><span class="toc-number">3.0.1.1.1.</span> <span class="toc-text">Descriptors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">3.0.1.1.2.</span> <span class="toc-text">描述符表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#selectors"><span class="toc-number">3.0.1.1.3.</span> <span class="toc-text">Selectors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.0.1.1.4.</span> <span class="toc-text">段寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#page-translation"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">page translation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#linear-address"><span class="toc-number">3.0.1.2.1.</span> <span class="toc-text">linear address</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#page-translation-cache-tlb"><span class="toc-number">3.0.1.2.2.</span> <span class="toc-text">page translation cache TLB</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5-%E5%88%86%E9%A1%B5"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">分段 &amp;&amp; 分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">3.0.1.4.</span> <span class="toc-text">保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#segment-level-protection"><span class="toc-number">3.0.1.4.1.</span> <span class="toc-text">segment-level protection</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual-linear-and-physical-address"><span class="toc-number">3.1.</span> <span class="toc-text">Virtual , linear, and physical Address</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">页表管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise4"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">exercise4</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pgdir-walk"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">pgdir_walk()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#boot-map-region"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">boot_map_region()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#page-lookup"><span class="toc-number">3.1.2.1.3.</span> <span class="toc-text">page_lookup()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#page-remove"><span class="toc-number">3.1.2.1.4.</span> <span class="toc-text">page_remove()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#page-insert"><span class="toc-number">3.1.2.1.5.</span> <span class="toc-text">page_insert()</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#part-3-kernel-address-space"><span class="toc-number">4.</span> <span class="toc-text">Part 3: Kernel Address Space</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#permissions-and-fault-isolation"><span class="toc-number">4.1.</span> <span class="toc-text">Permissions and Fault Isolation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initializing-the-kernel-address-space"><span class="toc-number">4.2.</span> <span class="toc-text">Initializing the Kernel Address Space</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exercise5"><span class="toc-number">4.2.1.</span> <span class="toc-text">Exercise5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#questions"><span class="toc-number">4.2.2.</span> <span class="toc-text">Questions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#address-space-layout-alternatives"><span class="toc-number">4.3.</span> <span class="toc-text">Address Space Layout Alternatives</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pass"><span class="toc-number">5.</span> <span class="toc-text">PASS</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/07/jos-lab2/" title="jos_lab2">jos_lab2</a><time datetime="2024-10-07T15:50:46.000Z" title="发表于 2024-10-07 23:50:46">2024-10-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/04/6-828-lab1/" title="jos_lab1">jos_lab1</a><time datetime="2024-10-04T03:21:03.000Z" title="发表于 2024-10-04 11:21:03">2024-10-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/18/epoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="epoll实现原理">epoll实现原理</a><time datetime="2024-09-18T13:11:54.000Z" title="发表于 2024-09-18 21:11:54">2024-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/task-struct%E8%AF%A6%E8%A7%A3/" title="task_struct详解">task_struct详解</a><time datetime="2024-09-11T16:14:29.000Z" title="发表于 2024-09-12 00:14:29">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/ac-tricks/" title="ac_tricks">ac_tricks</a><time datetime="2024-09-09T13:15:03.000Z" title="发表于 2024-09-09 21:15:03">2024-09-09</time></div></div></div></div><div class="card-widget"><div class="item-headline"><i class="fas fa-cubes"></i><span>系列合集</span></div><div class="collections-item-content"><a href="文章1url">面试合集</a></div><div class="collections-item-content"><a href="文章2url">名称2</a></div></div></div></div></main><footer id="footer" style="background-image: url('/img/staring_star_sky.JPG')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 冷静一下</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liKf4gi0DpLa4i2u',
      clientSecret: '80d1c4128ced9c69f894028dd98211b70e94d2ca',
      repo: 'jeycechen.github.io',
      owner: 'jeycechen',
      admin: ['jeycechen'],
      id: 'e8b0d471fe46145b902d21f074e60568',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>