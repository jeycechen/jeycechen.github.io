{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/IMG_321_new.JPG","path":"img/IMG_321_new.JPG","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/imgs/muduo.png","path":"imgs/muduo.png","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/collections.css","path":"css/collections.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1712639858076},{"_id":"source/_posts/new_test.md","hash":"1fd2220ffa7ed700be8ccfc5de9fb9ecc751d835","modified":1712639858076},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1712639858076},{"_id":"themes/butterfly/README.md","hash":"4e01b47448d9f3a02afc04eef644e2321253f6f4","modified":1712639858076},{"_id":"themes/butterfly/README_CN.md","hash":"148da187d16033624ceccce8b8561835296f5a5a","modified":1712639858076},{"_id":"themes/butterfly/_config.yml","hash":"2dc58817dcb7f549204e0c0bb56af86f177ec8f8","modified":1722699255508},{"_id":"themes/butterfly/package.json","hash":"314b0271ba3f668d0d6081b499b2d24e90dab25e","modified":1712639858082},{"_id":"themes/butterfly/plugins.yml","hash":"d807fbb62163bb6fc5a83a24ebd69ac14cf45f67","modified":1712639858082},{"_id":"themes/butterfly/languages/default.yml","hash":"90a6dc361de67532437d819a55ec64945ca5404b","modified":1712639858076},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"5004faee365139521f161babd66649a8107e4008","modified":1712639858076},{"_id":"themes/butterfly/languages/en.yml","hash":"af5603b1a888f167dc80be6d53a19437b5cf6bef","modified":1712639858076},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"03629d1d13a7be09d4933aa5dc0dcbe45e79140c","modified":1712639858076},{"_id":"themes/butterfly/layout/archive.pug","hash":"bb32c9c476372de747dfa563b83f77d7a917a77d","modified":1712639858076},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1712639858076},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1712639858082},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1712639858082},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1712639858082},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1712639858076},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1712639858076},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"ecec62305aaa596bb1dfbb46c13d06fb5a9628cf","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1712639858076},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"db275f7fbe4438b54cd813b695f4834e10aa234f","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1712639858078},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1712639858082},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1712639858082},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1712639858082},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1712639858083},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"2ac43fd4103ba3c6897da7c13015cb05f39fd695","modified":1712639858083},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"e196a99733d7f90899bceed5d12488e8234817d5","modified":1712639858083},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1712639858083},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"860f967ecf3c6a6ea785b560a7aae4d0757cd18a","modified":1712639858083},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a8eef3f37428436554f58a2b6bac7c255fbdf38d","modified":1712639858083},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1712639858083},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"96f861151e3b889ef0ffe78821d489ad2625ee43","modified":1712639858083},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"7caf549810f971c34196fb9deac2d992545bdff9","modified":1712639858083},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"d5c7e61257b08a9648404f6f48ce4d471cd5fa55","modified":1712639858083},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"e2a8a09bfe47da26eab242a36f516e6c452c799a","modified":1712639858083},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1712639858083},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"93229d44b35b9da92e647b89d6d3087085974a29","modified":1712639858083},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"821e973d41f7b3b64cde91e0e836ea49c43e3c06","modified":1712639858083},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1712639858083},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"418684993a3a3a2ac534257a2d9ecbcead6808c1","modified":1712639858083},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"365db87ddfc582bf8c15cb440c48bed95106e4b1","modified":1712639858083},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"512c68a22ae4a58d6a6b24b368a0c00c2ccb4fcb","modified":1712639858084},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"5c2a07df5874b5377540884e4da14dd21489378f","modified":1712639858084},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"19773218877281ccffed921431e87148413a7c20","modified":1712639858084},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"1acefc59ead75ebd8cafee36efc7da4fa426d088","modified":1712639858084},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"5cb273e95846874e3a58074074c501df23c5e912","modified":1712639858084},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"ffc62222f8d7b4d44c1c0726c8a08824a2201039","modified":1712639858084},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"830b1d592278b9f676df0cf9a91b1eeda2456aec","modified":1712639858084},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4526c75e5bf84609d67e92b6af3524bcb278e852","modified":1712639858084},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1712639858087},{"_id":"themes/butterfly/source/css/var.styl","hash":"152b6bd4b6285165541a71f5a1c913f8ee6a602b","modified":1712639858087},{"_id":"themes/butterfly/source/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1712639858094},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1712639858094},{"_id":"themes/butterfly/source/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1712639858094},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1712042593200},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1712042593201},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1712042593202},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"63fed4548367a3663cdbaffa1df48167b0a2397b","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"5208fe1e75d97a05fd9bdd6cc53c59d8b741b94b","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"f50e6a17073677933c5bc78481bf587a4a9e6da0","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1712639858077},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"6f310ca7b392021632b987557607d5b6d18052bb","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1712042593090},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"5574804fdea5edf7fd52aad2caf030614d5e7f2f","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"a096ff8eb6b2a22395be881f827ff2a686ba5596","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"1d39670ee6225f85f5c53bf5c84f3fd6e19290e8","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"12e57491e94fa00d953bbda9db0b6d6169e2358c","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"bd5ad01277f8c6ddf8a3a29af1518e5fe6eed23f","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"a658a274c5f7896ee5122725bee45548693bdd66","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1712639858082},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"e5cc47a6791d08bf13349feb5bf5ab2aa275c990","modified":1722697246292},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"c8ff6ddd5bfe1190b7b8056b68ce41114fd79dcb","modified":1712639858084},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f19694a42dbe28eda4b39a1696e8fbcd277bc76c","modified":1712639858084},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"4dcd468e4d11a0ac75406162678feffcd89fee00","modified":1712639858084},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"fad650f88778b33a6358e38cf50dfafc0974d28f","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"134811b2d696f9ed2c0cd578f3886f1c60770c0a","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"18d08be0cd9b1f8c049d4b922e80f8163a55c947","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"a2eb44fa5eaea1325319a2064439cf36d0f35a2f","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6cf26ffb8a0343eda1cde65b6b73b0ddbe8fcfc","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"f845b9b4efdee750f70c023aab27432611f83059","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"b7a6a585dbc38d177c9aba75df3a467415d0488a","modified":1712639858085},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1712639858085},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"0db591a1f4ed5adcb8668a549bbee5c9d62682cf","modified":1712639858085},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"e549d24ad81a7d93326a509ff8dcfcc58c80729e","modified":1712639858085},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1712639858085},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1712639858086},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1712639858086},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1712639858086},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1712639858086},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1712639858086},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"d4ebc41b5c855dd75f47de7345d62f85ce7cf073","modified":1712639858086},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1712639858086},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1712639858086},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"961589da3c0a532c4709a4a4ea96bd579257f766","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"5cddbb5f4eae695a26685e415d821b523e0f17bf","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"909bb5079b26b6ee68177919f522566503654058","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"2d02e52b360f6e6cae47c293ae57ed78e2554663","modified":1712639858086},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1712639858086},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1712639858087},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1712639858094},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1712639858094},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"f7299f9fef5bf94bb58c8cd3be8ee660ad2f9cd4","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"71af0b679e00290b0854384368b3c7e9b3e5f26a","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"c5f7081ca29db8cc80f808dfc29e36d5fa22fd7e","modified":1712639858078},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"3a5ccfc69bd8ccb4b8f3ce3502023f7914f2a022","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"f77f0fdeac2bc8a72f71a58f9b75aa39f0a108c8","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"62f16a602e57e5f7f7c5249dd37b42d436dc032a","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"3bc4c1b91568561f0491bdac65b75aa0bfd01f27","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"46aec6466959baec1c3d71a5dbc510fbeb00c91d","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"2d7b0b09678adba09481e3152e0b32962677f650","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0d378ee8a671982a46213a4bfb223b4f3409aea9","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"a9709905593d960954e2dd572f09f48a6c2b1ef7","modified":1712639858079},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"63cea2b5c8f7b59f5919379d61a2bb2ce8ed7623","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f15699abb8c7a255aabad0222ae53eee387c66a3","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"5c29b5887e2e6cd81e1f13b32da53d9c139b788b","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1995a654ba7ad62775a0a6e2922209cd1a85f2e3","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"46865e3f52096acb07d0212174b4e8751b123aea","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"7aa443b4881448979b810864e206e58c9ed787e3","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"6b67982bb7a3713b5bffd6a23ba2810425c504d0","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"17080aba1754478197ab089f7948ed900f116d2b","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"2609bc2656aaaa9b59e8d575e711776512a62192","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0f0b46d637a9a1b6ae35148923abecc80b866276","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"4104f96faa6040f111ebfb9a90eeb470857c3b86","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"1f9f51023e9e33081c2add2ca73643c0edc5e9d5","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"de2c4d02b520dd49a0a59fc0f33295e5bbb2c624","modified":1712639858080},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"24804ab6da9727ed793655c1262fa3f1a9746f70","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"b928be14d1b47a9fadb1bcc5f5072a7328752d4b","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"3335024ba91f55ccf3858571b7898f46881c455c","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"3ba49cfe186e9ca05faf9f0d0113611ec47e9b38","modified":1712639858081},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1712639858081},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1712639858084},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1712639858084},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1712639858084},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1712639858084},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"25914321762e30aacc610bc4dfb9de3e1cb556a3","modified":1712639858084},{"_id":"themes/butterfly/source/img/IMG_321_new.JPG","hash":"b01cc8c690ed0822226fd877b8d91863532e3777","modified":1712047099058},{"_id":"public/2024/04/02/new_test/index.html","hash":"b2d706a0bb1eaa92135d8a4ef0758a16c0f6de27","modified":1712111266415},{"_id":"public/2024/04/02/hello-world/index.html","hash":"5425abe51838ec05425c8df8a46a1ad095dd1f3d","modified":1712111266415},{"_id":"public/archives/index.html","hash":"1be0da3027288ddd66ea5650d54e767758bf1edf","modified":1722706581805},{"_id":"public/archives/2024/04/index.html","hash":"a8b310afec9e4723d3ba06dc7c76391f6149a4fb","modified":1722706581805},{"_id":"public/archives/2024/index.html","hash":"9190893f732f872d44ed8512e1e2a9704171851c","modified":1722706581805},{"_id":"public/index.html","hash":"cf1dc1e51ee14c7ff6528d502a7f90f826a495f7","modified":1722706581805},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1712111266415},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1712111266415},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1712111266415},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1712111266415},{"_id":"public/css/index.css","hash":"77a9c1a97dcf39bbf194c4563e29bd7f1bfae509","modified":1712111266415},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1712111266415},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1712111266415},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1712111266415},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1712111266415},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1712111266415},{"_id":"public/img/IMG_321_new.JPG","hash":"b01cc8c690ed0822226fd877b8d91863532e3777","modified":1712111266415},{"_id":"public/2024/04/09/hello-world/index.html","hash":"a105b12115908a6d2f97bfdb3a6138d31dce349b","modified":1722706291495},{"_id":"public/2024/04/09/new_test/index.html","hash":"18d4382ff89965f94ed38e7f6978b1b0a15819ea","modified":1712677215157},{"_id":"source/_posts/排序方法.md","hash":"72e63f0752183a0b34da7be29b2b43b907ca2fe8","modified":1714309754800},{"_id":"source/_posts/树状数组专题.md","hash":"156ea175a74074bcdc2de6c31d44ce1974b06ede","modified":1712906584932},{"_id":"public/2024/04/09/排序方法/index.html","hash":"741cdc1367db5b5d33106086b241814b3d62827e","modified":1712677215157},{"_id":"public/2024/04/09/树状数组专题/index.html","hash":"8fce1bfad70fb093eaab26a57a5d05bb2632344a","modified":1722706291495},{"_id":"source/_posts/tecent_interview.md","hash":"98e1511c101c8f27c33e700d6ee9031acd379475","modified":1722701165662},{"_id":"public/2024/04/12/排序方法/index.html","hash":"21368a7a8bc881c63864d3518410b604843c17de","modified":1722706291495},{"_id":"public/2024/04/09/tecent_interview/index.html","hash":"f7d469a3c36a45bd9c6e14905eae726c014f7adb","modified":1722706291495},{"_id":"source/_posts/cpp.md","hash":"4a1891593db6b8f2aa5604c367dffe57a7f7b4c2","modified":1712929738418},{"_id":"source/_posts/Docker.md","hash":"63b06ea4eff580247865f1c083b40fdd7ec7050b","modified":1712926928339},{"_id":"source/_posts/remian.md","hash":"dae77624731c85c30a5735fb025f2787840d14d2","modified":1712926576609},{"_id":"source/_posts/操作系统.md","hash":"360470cec4286083df37977066885b257374bac6","modified":1712925929858},{"_id":"source/_posts/数据库-redis.md","hash":"334e889260b5bb45dcd610c4afa9fdc1bf0fd4a0","modified":1712930705409},{"_id":"source/_posts/计算机网络.md","hash":"faea6a863242f52890fd0cee836e3ce8a2725852","modified":1716279825665},{"_id":"source/_posts/数据库-mysql.md","hash":"809eb0c4a86ec8ae6288d42399481df206a632c5","modified":1712926123038},{"_id":"source/_posts/设计模式.md","hash":"f7528a2a311903b1e61f0d70b10d51b8afc63279","modified":1715526891825},{"_id":"public/2024/04/12/Docker/index.html","hash":"2d704e0553173f53fb4cb6fa51c1fdd26c67d725","modified":1722706291495},{"_id":"public/2024/04/12/设计模式/index.html","hash":"46373d29e11914a34d7151f6cdc5261620fe3814","modified":1722706291495},{"_id":"public/2024/04/12/cpp/index.html","hash":"d0637834df7e2443445714f8181483bcc2d98929","modified":1722706291495},{"_id":"public/2024/04/12/remian/index.html","hash":"eb2a7eddeaf400451b5c1314cc7abe0e59a31da1","modified":1717945679132},{"_id":"public/2024/04/12/数据库-redis/index.html","hash":"0b390a642c727a8a6091ee31b686039e3ee5274d","modified":1722706291495},{"_id":"public/2024/04/12/数据库-mysql/index.html","hash":"eae44e331e21247bec15ac704182c4408851d700","modified":1722706291495},{"_id":"public/2024/04/12/操作系统/index.html","hash":"b223d4a193247364f175017347c2fded387300d4","modified":1722706291495},{"_id":"public/2024/04/12/计算机网络/index.html","hash":"ac555aa1703d833a32188f5c5d3e8901d13e247f","modified":1722706291495},{"_id":"public/archives/page/2/index.html","hash":"3d118488c274a4b895a8c426972c36324477ae9e","modified":1722706581805},{"_id":"public/archives/2024/page/2/index.html","hash":"f9003e6307f881c1c9727b5a81e48501cdfbe11e","modified":1722706581805},{"_id":"public/archives/2024/04/page/2/index.html","hash":"847a53b1af04ea55f3c2464aaa2b5ad41d265424","modified":1722706581805},{"_id":"public/page/2/index.html","hash":"98a06655ca18a6ab4b0f8da81fcbbea63a848a56","modified":1722706581805},{"_id":"source/_posts/CAS算法.md","hash":"ab9fa96e1ee94642a92061bea2422ae9467a2728","modified":1716454945902},{"_id":"public/2024/05/23/CAS算法/index.html","hash":"cd4037d5abbda04be6ad69490d001edafabc150f","modified":1722706291495},{"_id":"public/archives/2024/05/index.html","hash":"fb31879167c5105e08ebd54e039bcd1765093004","modified":1722706581805},{"_id":"source/_posts/muduo.md","hash":"52cf02c8f097751aca737f842f807e6075cd1dc0","modified":1717946127590},{"_id":"public/2024/06/09/muduo/index.html","hash":"13a401839808c8e13d8bc5c36ebff8daa4581510","modified":1722706291495},{"_id":"public/archives/2024/06/index.html","hash":"9a55826639bbe71c39ae4911cdc3b68e931f9058","modified":1722706581805},{"_id":"source/.DS_Store","hash":"842c912fce4d9d20073332a882be6ce7e2a76de9","modified":1717945898402},{"_id":"source/imgs/.DS_Store","hash":"63c84f22cd15d2bb9d4f0aa974b8d1c086091900","modified":1717945945874},{"_id":"source/imgs/muduo.png","hash":"41d708731835aa6c6f286c8841e018e36f241609","modified":1717945194138},{"_id":"public/imgs/muduo.png","hash":"41d708731835aa6c6f286c8841e018e36f241609","modified":1717945956228},{"_id":"source/_posts/remain.md","hash":"dae77624731c85c30a5735fb025f2787840d14d2","modified":1717946100377},{"_id":"public/2024/04/12/remain/index.html","hash":"8f6641942013b262215033f7557b3d731e4bba43","modified":1722706291495},{"_id":"source/_posts/智能指针.md","hash":"fd1d28923ec6a2402685aa006c1e8e386ec15aeb","modified":1719304286287},{"_id":"public/2024/06/25/智能指针/index.html","hash":"f9799f7d87d80525ddb0319e68981789797a2f8a","modified":1722706291495},{"_id":"source/_posts/KMP.md","hash":"e007ca6e87458442aa2f34bdc190bfed77654f56","modified":1719997322262},{"_id":"public/2024/07/03/KMP/index.html","hash":"b763f5064bac797adad73d49703a55cc949363a9","modified":1722706291495},{"_id":"public/archives/2024/07/index.html","hash":"da5adc82c730df857f0b7bf4807a8d835313e385","modified":1722706581805},{"_id":"source/_posts/dp.md","hash":"cf627e785109db353a8877880395138fd41ecebc","modified":1722254079863},{"_id":"public/2024/07/29/dp/index.html","hash":"c48cbd90fdac9a7518f462f14e347c36349c1b8b","modified":1722706291495},{"_id":"source/_data/collections.yml","hash":"74a91f9a37702d04c6d87c368b1f77cc880959e4","modified":1722698973335},{"_id":"themes/butterfly/source/css/collections.css","hash":"089b20ebeabc6a17845d1ba01d8f90af26eb3672","modified":1722697472851},{"_id":"themes/butterfly/layout/includes/widget/card_collection.pug","hash":"d14062bb5d981bf420e1fd246fb4d86a2e15356a","modified":1722697216277},{"_id":"public/css/collections.css","hash":"089b20ebeabc6a17845d1ba01d8f90af26eb3672","modified":1722697481799},{"_id":"themes/butterfly/layout/includes/widget/card_collections.pug","hash":"d14062bb5d981bf420e1fd246fb4d86a2e15356a","modified":1722697216277},{"_id":"source/_posts/mhy_笔试.md","hash":"2cad0fa5eb081ab97a1ea4c38fc994f88cbf9c60","modified":1722706044202},{"_id":"public/2024/08/03/mhy_笔试/index.html","hash":"da65cd9bc8672aeaf28b2ad2bed2e1c419505721","modified":1722706291495},{"_id":"public/archives/2024/08/index.html","hash":"f2013ea886b0f1f8ac9154bd12f5f8159c3b96c2","modified":1722706581805},{"_id":"source/categories/index.md","hash":"df5ab62bfbbdccb76935e7f466f731b196cdf37b","modified":1722700864528},{"_id":"public/categories/index.html","hash":"4384b3bce2ee209a4b61cb708b6c3d081c379120","modified":1722706581805},{"_id":"public/categories/面试笔试记录/index.html","hash":"13f47c6ed7fb68df164c4a6d64f277bb3c3e5f17","modified":1722706581805},{"_id":"source/_posts/静态和动态链接.md","hash":"d01e59b0dade0de108e6e29e79c21fe32d5de0a5","modified":1722706217503},{"_id":"source/tags/index.md","hash":"0ab079a97a2451f0f790c8a6ac6128c189b2939d","modified":1722706230697},{"_id":"public/tags/流水线/index.html","hash":"c5a5b07d8052955535c25d78f87133c4f5850731","modified":1722706581805},{"_id":"public/tags/异常处理/index.html","hash":"ad64312fa5605953c20f1c5810c12f06d5d8f83b","modified":1722706581805},{"_id":"public/tags/排序/index.html","hash":"6ebf5d22113f420139402fd384beb460b56a012b","modified":1722706581805},{"_id":"public/tags/TCP-UDP/index.html","hash":"1082f94297feb68fd5360438205b9b33cf04a68e","modified":1722706581805},{"_id":"public/tags/面试-笔试/index.html","hash":"b3bb58481c1725c97c96ad10afce6f7c8196c0fd","modified":1722706581805},{"_id":"public/tags/index.html","hash":"6bda91c9c49f1bd37296b4d38162fdfc1aae5585","modified":1722706581805},{"_id":"public/2024/08/04/静态和动态链接/index.html","hash":"3ede7627e0be069931eaaed42346c7507b7c75ef","modified":1722706291495},{"_id":"public/tags/静态链接/index.html","hash":"9041ee1629519fc395d3ee241439a3b7f8d1f4f5","modified":1722706581805},{"_id":"public/tags/动态链接/index.html","hash":"5d2ea00e672f472777685cb9f9eadd7f4eb35ddc","modified":1722706581805},{"_id":"public/tags/GOT和PLT/index.html","hash":"b5974038659132fdee6264770af5399ed9332e50","modified":1722706581805},{"_id":"public/tags/程序加载/index.html","hash":"e4c127bc71ceb50fb487ca9ad549680405a43e33","modified":1722706581805}],"Category":[{"name":"面试笔试记录","_id":"clzebsudg00014mjk36173jd6"}],"Data":[{"_id":"collections","data":{"collections":[{"name":"面试合集","url":"文章1url"},{"name":"名称2","url":"文章2url"}]}}],"Page":[{"title":"categories","date":"2024-08-03T16:01:04.000Z","keywords":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-08-04 00:01:04\nkeywords:\n---\n","updated":"2024-08-03T16:01:04.528Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clzebsudc00004mjkdlr30z81","content":"","cover":false,"excerpt":"","more":""},{"title":"tags","date":"2024-08-03T16:09:09.000Z","keywords":null,"type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2024-08-04 00:09:09\nkeywords:\ntype: \"tags\"\n---\n","updated":"2024-08-03T17:30:30.697Z","path":"tags/index.html","_id":"clzeet71f0009hsjk8uda9r0p","comments":1,"layout":"page","content":"","cover":false,"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-04-09T05:17:38.075Z","updated":"2024-04-09T05:17:38.076Z","_id":"cluj6ucqq0000t4uae3hng9u9","comments":1,"layout":"post","photos":[],"content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","cover":false,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"树状数组专题","_content":"\n树状数组 BIT\n***用途***\n支持单点更新 \n前缀和查询\n\n![树状数组示意](./public/img/bit.png)\n\n----\n对比前缀和数组  \n\n| 属性        | 前缀和数组 | bit     |\n|------------|------------|---------|\n| 求区间和   | O(1)       | O(logn) |\n| 单点更新   | O(n)       | O(logn) |\n\n\n***使用场景***\n求区间[l,r] 内的最大值\n求区间[l,r] 内的出现频次最高的数字\n求逆序数\n\n\n***模版***\n\n```c++\nclass BIT(){\npublic:\n    int m_size;\n    vector<int> Bit;\n    BIT(int size){\n        m_size = size;\n        Bit = vector<int> (m_size+1, 0);\n    }\n\n    void update(int idx, int del){ //delta 是变化的值\n        //更新当前节点和 父节点，\n        while(idx <= m_size){\n            bit[idx] += del;\n            idx += lowbit(idx);\n        }\n    }\n\n    int query(int idx){\n        int sum = 0;\n        while(idx>0){\n            sum += bit[idx];\n            idx -= lowbit(idx); // 往下加上子节点的数值，直到到达叶子节点。\n        }\n    }\n\n    int lowbit(int idx) {\n        return idx & (-idx);\n    }\n}\n```  \n\n\n---\n##example## 逆序数\n```c++\n    vector<int> reverse(vector<int> nums){\n        int len = nums.size();\n        if(len < 2) return vector<int> {}; //特殊判断\n        set<int> st;\n        vector<int> vec;\n        unordered_map<int, int> map;\n        for(auto ele:nums){\n            map[ele]++;\n            if(st.count(ele) == 0) {\n                vec.push_back(ele);\n            }\n        }\n        sort(vec.begin(), vec.end()); // 升序排序\n        \n        \n        int size = vec.size();\n        BIT bit(size); // 存放排名，每个位置的前缀和是小于当前排名的元素个数\n                        //然后从后往前遍历原来的数组，根据数组元素查询排名idx\n                        //调用update(idx+1,1) 向上更新;表示 idx+1 往后的节点，小于其排名的元素个数 + 1， 因为出现了一个idx\n                        //然后调用query(idx), 向下求和，表示求当前位置之后有多少个元素小于当前位置的元素； \n                        // 倒序遍历 + 离散化排名 保证了逆序对的求值\n\n        //init bit\n        vector<int> result;\n        for(int i = nums.size() - 1;i >= 0;i--){\n            int \n        }\n\n    }\n    \n```\n\n","source":"_posts/树状数组专题.md","raw":"---\ntitle: 树状数组专题\n---\n\n树状数组 BIT\n***用途***\n支持单点更新 \n前缀和查询\n\n![树状数组示意](./public/img/bit.png)\n\n----\n对比前缀和数组  \n\n| 属性        | 前缀和数组 | bit     |\n|------------|------------|---------|\n| 求区间和   | O(1)       | O(logn) |\n| 单点更新   | O(n)       | O(logn) |\n\n\n***使用场景***\n求区间[l,r] 内的最大值\n求区间[l,r] 内的出现频次最高的数字\n求逆序数\n\n\n***模版***\n\n```c++\nclass BIT(){\npublic:\n    int m_size;\n    vector<int> Bit;\n    BIT(int size){\n        m_size = size;\n        Bit = vector<int> (m_size+1, 0);\n    }\n\n    void update(int idx, int del){ //delta 是变化的值\n        //更新当前节点和 父节点，\n        while(idx <= m_size){\n            bit[idx] += del;\n            idx += lowbit(idx);\n        }\n    }\n\n    int query(int idx){\n        int sum = 0;\n        while(idx>0){\n            sum += bit[idx];\n            idx -= lowbit(idx); // 往下加上子节点的数值，直到到达叶子节点。\n        }\n    }\n\n    int lowbit(int idx) {\n        return idx & (-idx);\n    }\n}\n```  \n\n\n---\n##example## 逆序数\n```c++\n    vector<int> reverse(vector<int> nums){\n        int len = nums.size();\n        if(len < 2) return vector<int> {}; //特殊判断\n        set<int> st;\n        vector<int> vec;\n        unordered_map<int, int> map;\n        for(auto ele:nums){\n            map[ele]++;\n            if(st.count(ele) == 0) {\n                vec.push_back(ele);\n            }\n        }\n        sort(vec.begin(), vec.end()); // 升序排序\n        \n        \n        int size = vec.size();\n        BIT bit(size); // 存放排名，每个位置的前缀和是小于当前排名的元素个数\n                        //然后从后往前遍历原来的数组，根据数组元素查询排名idx\n                        //调用update(idx+1,1) 向上更新;表示 idx+1 往后的节点，小于其排名的元素个数 + 1， 因为出现了一个idx\n                        //然后调用query(idx), 向下求和，表示求当前位置之后有多少个元素小于当前位置的元素； \n                        // 倒序遍历 + 离散化排名 保证了逆序对的求值\n\n        //init bit\n        vector<int> result;\n        for(int i = nums.size() - 1;i >= 0;i--){\n            int \n        }\n\n    }\n    \n```\n\n","slug":"树状数组专题","published":1,"date":"2024-04-09T05:52:06.121Z","updated":"2024-04-12T07:23:04.932Z","_id":"clurystfm0000tzvkeie9emj9","comments":1,"layout":"post","photos":[],"content":"<p>树状数组 BIT<br><em><strong>用途</strong></em><br>支持单点更新<br>前缀和查询</p>\n<p><img src=\"/./public/img/bit.png\" alt=\"树状数组示意\"></p>\n<hr>\n<p>对比前缀和数组  </p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>前缀和数组</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>求区间和</td>\n<td>O(1)</td>\n<td>O(logn)</td>\n</tr>\n<tr>\n<td>单点更新</td>\n<td>O(n)</td>\n<td>O(logn)</td>\n</tr>\n</tbody></table>\n<p><em><strong>使用场景</strong></em><br>求区间[l,r] 内的最大值<br>求区间[l,r] 内的出现频次最高的数字<br>求逆序数</p>\n<p><em><strong>模版</strong></em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">BIT</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> m_size;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; Bit;</span><br><span class=\"line\">    <span class=\"built_in\">BIT</span>(<span class=\"type\">int</span> size)&#123;</span><br><span class=\"line\">        m_size = size;</span><br><span class=\"line\">        Bit = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (m_size+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> idx, <span class=\"type\">int</span> del)</span></span>&#123; <span class=\"comment\">//delta 是变化的值</span></span><br><span class=\"line\">        <span class=\"comment\">//更新当前节点和 父节点，</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(idx &lt;= m_size)&#123;</span><br><span class=\"line\">            bit[idx] += del;</span><br><span class=\"line\">            idx += <span class=\"built_in\">lowbit</span>(idx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(idx&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum += bit[idx];</span><br><span class=\"line\">            idx -= <span class=\"built_in\">lowbit</span>(idx); <span class=\"comment\">// 往下加上子节点的数值，直到到达叶子节点。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> idx &amp; (-idx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">#<span class=\"meta\">#example## 逆序数</span></span><br><span class=\"line\">```c++</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">reverse</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> vector&lt;<span class=\"type\">int</span>&gt; &#123;&#125;; <span class=\"comment\">//特殊判断</span></span><br><span class=\"line\">        set&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; vec;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; map;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ele:nums)&#123;</span><br><span class=\"line\">            map[ele]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(st.<span class=\"built_in\">count</span>(ele) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                vec.<span class=\"built_in\">push_back</span>(ele);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 升序排序</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> size = vec.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">BIT <span class=\"title\">bit</span><span class=\"params\">(size)</span></span>; <span class=\"comment\">// 存放排名，每个位置的前缀和是小于当前排名的元素个数</span></span><br><span class=\"line\">                        <span class=\"comment\">//然后从后往前遍历原来的数组，根据数组元素查询排名idx</span></span><br><span class=\"line\">                        <span class=\"comment\">//调用update(idx+1,1) 向上更新;表示 idx+1 往后的节点，小于其排名的元素个数 + 1， 因为出现了一个idx</span></span><br><span class=\"line\">                        <span class=\"comment\">//然后调用query(idx), 向下求和，表示求当前位置之后有多少个元素小于当前位置的元素； </span></span><br><span class=\"line\">                        <span class=\"comment\">// 倒序遍历 + 离散化排名 保证了逆序对的求值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//init bit</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n","cover":false,"excerpt":"","more":"<p>树状数组 BIT<br><em><strong>用途</strong></em><br>支持单点更新<br>前缀和查询</p>\n<p><img src=\"/./public/img/bit.png\" alt=\"树状数组示意\"></p>\n<hr>\n<p>对比前缀和数组  </p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>前缀和数组</th>\n<th>bit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>求区间和</td>\n<td>O(1)</td>\n<td>O(logn)</td>\n</tr>\n<tr>\n<td>单点更新</td>\n<td>O(n)</td>\n<td>O(logn)</td>\n</tr>\n</tbody></table>\n<p><em><strong>使用场景</strong></em><br>求区间[l,r] 内的最大值<br>求区间[l,r] 内的出现频次最高的数字<br>求逆序数</p>\n<p><em><strong>模版</strong></em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">BIT</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> m_size;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; Bit;</span><br><span class=\"line\">    <span class=\"built_in\">BIT</span>(<span class=\"type\">int</span> size)&#123;</span><br><span class=\"line\">        m_size = size;</span><br><span class=\"line\">        Bit = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (m_size+<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> idx, <span class=\"type\">int</span> del)</span></span>&#123; <span class=\"comment\">//delta 是变化的值</span></span><br><span class=\"line\">        <span class=\"comment\">//更新当前节点和 父节点，</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(idx &lt;= m_size)&#123;</span><br><span class=\"line\">            bit[idx] += del;</span><br><span class=\"line\">            idx += <span class=\"built_in\">lowbit</span>(idx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(idx&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum += bit[idx];</span><br><span class=\"line\">            idx -= <span class=\"built_in\">lowbit</span>(idx); <span class=\"comment\">// 往下加上子节点的数值，直到到达叶子节点。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> idx)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> idx &amp; (-idx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">#<span class=\"meta\">#example## 逆序数</span></span><br><span class=\"line\">```c++</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">reverse</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> len = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> vector&lt;<span class=\"type\">int</span>&gt; &#123;&#125;; <span class=\"comment\">//特殊判断</span></span><br><span class=\"line\">        set&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; vec;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; map;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> ele:nums)&#123;</span><br><span class=\"line\">            map[ele]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(st.<span class=\"built_in\">count</span>(ele) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                vec.<span class=\"built_in\">push_back</span>(ele);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 升序排序</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> size = vec.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">BIT <span class=\"title\">bit</span><span class=\"params\">(size)</span></span>; <span class=\"comment\">// 存放排名，每个位置的前缀和是小于当前排名的元素个数</span></span><br><span class=\"line\">                        <span class=\"comment\">//然后从后往前遍历原来的数组，根据数组元素查询排名idx</span></span><br><span class=\"line\">                        <span class=\"comment\">//调用update(idx+1,1) 向上更新;表示 idx+1 往后的节点，小于其排名的元素个数 + 1， 因为出现了一个idx</span></span><br><span class=\"line\">                        <span class=\"comment\">//然后调用query(idx), 向下求和，表示求当前位置之后有多少个元素小于当前位置的元素； </span></span><br><span class=\"line\">                        <span class=\"comment\">// 倒序遍历 + 离散化排名 保证了逆序对的求值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//init bit</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n"},{"title":"腾讯面试记录","_content":"\n\n## **date** 4.1 19:00  \n\n\n## **面试部门** QQ浏览器\n\n\n---\n## HTTP UDP 区别  \n\n| item | TCP | UDP |\n| ---- | ---- | ---- |\n| | 面向连接的 | 无连接的 |  \n|可靠性|提供可靠传输|尽最大努力交付，不保证可靠传输|  \n||有拥塞控制机制|无拥塞控制机制，不会降低源主机的发送速率，适合用于实时应用 语音 视频 直播|  \n|传输对象| 字节流| 报文段|\n| 传输效率 | 慢 | 快|\n| 首部开销 | 20-60 | 8 字节|\n| 场景 |适用于要求传输可靠的场景，如文件邮件传输 | 适用于通信速率要求高 即时通讯场景，域名服务 语音视频|\n| |一对一| 一对多 一对一 多对一 多对多|\n|示例|使用TCP的应用层协议有 FTP Telnet SMTP POP3 HTTP | DNS SNMP TFTP|\n\n\n---\n## HTTP1.0 与 HTTP1.1 HTTP 2.0\n| 特性 | HTTP 1.0 | HTTP 1.1 | HTTP 2.0 |\n| ---- | ---- | ---- | ---- |\n| 持久连接 | 不支持 | 允许在单个连接上发送多个请求和响应 | 允许在单个连接上多路复用多个请求和响应 |\n| 头部压缩 | 不支持 | 引入了部分头部压缩机制 | 引入了头部压缩，减少了重复的头部信息传输 |\n| 多路复用 | 不支持 | 不支持 | 支持多路复用，允许同时发送和接收多个请求和响应 |\n| 二进制传输 | 不支持 | 不支持 | 使用二进制格式传输数据，提高传输效率 |\n| 请求优先级 | 不支持 | 不支持 | 支持请求优先级，允许指定请求的优先级顺序 |\n| 流控制 | 不支持 | 不支持 | 支持流控制，避免了发送者超负荷发送数据 |\n\n---\n## 断点续传如何实现的\n断点续传（Resumable Download）是一种通过在下载过程中保存已下载数据的方式，使用户可以在下载中断后继续下载而不必重新开始的技术。它通常在网络下载和上传中使用，尤其是针对大型文件或不稳定网络环境下的文件传输。\n\n实现断点续传通常包括以下步骤：\n\n1. 服务器端支持： 服务器端需要支持断点续传功能。这通常涉及配置服务器以处理范围请求（Range Requests）。服务器接收到范围请求后，会返回请求的部分内容而不是整个文件。HTTP协议中使用的是Range头部来指示客户端需要的数据范围。\n\n2. 客户端实现： 客户端需要能够处理断点续传的逻辑。当下载中断后，客户端会向服务器发送一个包含已下载部分范围的范围请求。服务器会根据这个范围请求返回相应的数据。然后客户端会将这些数据与之前已下载的数据进行合并，从而实现断点续传。\n\n3. 断点记录： 客户端通常会记录已经下载的文件片段的信息，包括文件的大小、已下载的数据大小等。当下载中断时，客户端可以使用这些信息来向服务器发送范围请求。\n\n4. 续传标识： 服务器端通常会使用特定的HTTP头部（如Accept-Ranges和Content-Range）来指示客户端服务器是否支持范围请求以及返回的数据的范围。\n\n总的来说，断点续传是通过客户端和服务器之间的协作来实现的。客户端在下载中断时发送范围请求，服务器根据请求返回相应的数据片段，客户端将这些数据片段与已下载的部分合并，从而实现断点续传。 \n\n---  \n\n## 数据库技术\n没学，寄！ \n\n---  \n\n## 停止等待ARQ协议 连续ARQ协议\nTCP使用的是什么协议？ \n\n---\n\n## new 和 malloc 的区别\n\n---\n## hash如何实现\nhash_table 开放寻址法 拉链法\n\n---\n\n## 如何实现TCP那样的可靠传输协议 有哪些难点\n 编号重排序， 校验和， 冗余丢弃，超时重传，拥塞控制， 流量控制\n\n---\n\n## 线程与进程\n| 特征       | 线程                                        | 进程                                      |\n| ---------- | ------------------------------------------- | ----------------------------------------- |\n| 定义       | 线程是进程的一部分，是程序执行的最小单元。 | 进程是操作系统分配资源的最小单位。       |\n| 资源占用   | 线程共享进程的资源，如内存空间、文件句柄等。| 进程有独立的资源空间，如内存、文件句柄等。 |\n| 切换开销   | 线程切换开销小，因为共享相同的地址空间。   | 进程切换开销大，因为需要切换不同的地址空间。|\n| 通信方式   | 线程间通信相对容易，因为共享相同的地址空间。| 进程间通信相对复杂，需要使用IPC机制。     |\n| 并发性     | 线程并发性高，多个线程可同时执行不同的任务。 | 进程并发性低，多个进程之间执行互不干扰。   |\n| 创建开销   | 创建线程的开销较小，通常只需要分配栈空间。  | 创建进程的开销较大，需要分配独立的地址空间、PCB等。 |\n| 故障隔离   | 一个线程崩溃可能导致整个进程崩溃。          | 一个进程崩溃不会影响其他进程。           |\n| 灵活性     | 线程间切换开销小，适合处理密集型任务。      | 进程间切换开销大，适合处理CPU密集型任务。 |\n\n---\n\n## 死锁\n1. 互斥条件：至少有一个资源是非共享的，即一次只能被一个进程使用。如果一个进程在使用该资源时，其他进程不能使用，直到该进程释放该资源。\n\n2. 请求与保持条件：一个进程可以请求资源并保持对其他资源的占用。即当一个进程在请求资源时，它可以继续持有已分配的资源，不释放。\n\n3. 不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程抢占，只能由该进程自己释放。\n\n4. 循环等待条件：若干个进程之间形成一种循环等待资源的关系，即每个进程都在等待下一个进程所持有的资源。\n\n# 构造一个死锁\n构造死锁的一个常见方式是通过多个进程之间的资源竞争，同时满足死锁的四个条件。例如，考虑两个进程A和B，它们都需要两个资源，但是资源的顺序分配不同，这可能导致死锁。具体来说：\n\n- 进程A获取资源1，进程B获取资源2。\n- 进程A请求资源2，但由于资源2已被进程B持有，所以进程A等待。\n- 同时，进程B请求资源1，但由于资源1已被进程A持有，所以进程B也等待。\n这样，进程A等待进程B释放资源2，而进程B等待进程A释放资源1，导致了死锁的发生。\n\n# 打破死锁\n要打破死锁或预防死锁，可以采取以下方法：\n\n- 避免死锁： 通过设计算法和协议来避免进程陷入死锁状态。例如，银行家算法可以在分配资源时避免死锁。\n\n- 检测和恢复： 定期检测系统中是否存在死锁，一旦检测到死锁，采取恢复措施。常见的方法包括进程终止、资源抢占和回滚操作等。\n\n- 避免资源竞争： 设计资源分配策略，尽量减少进程之间的资源竞争。例如，使用资源分配顺序来避免循环等待条件。\n\n- 加锁顺序： 规定所有进程对资源的访问顺序，确保所有进程以相同的顺序请求资源，从而避免环路的形成。\n\n- 超时机制： 对于等待资源的进程，设置超时机制，如果等待时间超过一定阈值，就放弃等待并释放已持有的资源，从而避免死锁。\n\n---\n\n### coding\n    合并两个升序链表\n\n---\n\n### 评价   \n# 寄！","source":"_posts/tecent_interview.md","raw":"---\ntitle: 腾讯面试记录\ncategories:\n- 面试笔试记录\n---\n\n\n## **date** 4.1 19:00  \n\n\n## **面试部门** QQ浏览器\n\n\n---\n## HTTP UDP 区别  \n\n| item | TCP | UDP |\n| ---- | ---- | ---- |\n| | 面向连接的 | 无连接的 |  \n|可靠性|提供可靠传输|尽最大努力交付，不保证可靠传输|  \n||有拥塞控制机制|无拥塞控制机制，不会降低源主机的发送速率，适合用于实时应用 语音 视频 直播|  \n|传输对象| 字节流| 报文段|\n| 传输效率 | 慢 | 快|\n| 首部开销 | 20-60 | 8 字节|\n| 场景 |适用于要求传输可靠的场景，如文件邮件传输 | 适用于通信速率要求高 即时通讯场景，域名服务 语音视频|\n| |一对一| 一对多 一对一 多对一 多对多|\n|示例|使用TCP的应用层协议有 FTP Telnet SMTP POP3 HTTP | DNS SNMP TFTP|\n\n\n---\n## HTTP1.0 与 HTTP1.1 HTTP 2.0\n| 特性 | HTTP 1.0 | HTTP 1.1 | HTTP 2.0 |\n| ---- | ---- | ---- | ---- |\n| 持久连接 | 不支持 | 允许在单个连接上发送多个请求和响应 | 允许在单个连接上多路复用多个请求和响应 |\n| 头部压缩 | 不支持 | 引入了部分头部压缩机制 | 引入了头部压缩，减少了重复的头部信息传输 |\n| 多路复用 | 不支持 | 不支持 | 支持多路复用，允许同时发送和接收多个请求和响应 |\n| 二进制传输 | 不支持 | 不支持 | 使用二进制格式传输数据，提高传输效率 |\n| 请求优先级 | 不支持 | 不支持 | 支持请求优先级，允许指定请求的优先级顺序 |\n| 流控制 | 不支持 | 不支持 | 支持流控制，避免了发送者超负荷发送数据 |\n\n---\n## 断点续传如何实现的\n断点续传（Resumable Download）是一种通过在下载过程中保存已下载数据的方式，使用户可以在下载中断后继续下载而不必重新开始的技术。它通常在网络下载和上传中使用，尤其是针对大型文件或不稳定网络环境下的文件传输。\n\n实现断点续传通常包括以下步骤：\n\n1. 服务器端支持： 服务器端需要支持断点续传功能。这通常涉及配置服务器以处理范围请求（Range Requests）。服务器接收到范围请求后，会返回请求的部分内容而不是整个文件。HTTP协议中使用的是Range头部来指示客户端需要的数据范围。\n\n2. 客户端实现： 客户端需要能够处理断点续传的逻辑。当下载中断后，客户端会向服务器发送一个包含已下载部分范围的范围请求。服务器会根据这个范围请求返回相应的数据。然后客户端会将这些数据与之前已下载的数据进行合并，从而实现断点续传。\n\n3. 断点记录： 客户端通常会记录已经下载的文件片段的信息，包括文件的大小、已下载的数据大小等。当下载中断时，客户端可以使用这些信息来向服务器发送范围请求。\n\n4. 续传标识： 服务器端通常会使用特定的HTTP头部（如Accept-Ranges和Content-Range）来指示客户端服务器是否支持范围请求以及返回的数据的范围。\n\n总的来说，断点续传是通过客户端和服务器之间的协作来实现的。客户端在下载中断时发送范围请求，服务器根据请求返回相应的数据片段，客户端将这些数据片段与已下载的部分合并，从而实现断点续传。 \n\n---  \n\n## 数据库技术\n没学，寄！ \n\n---  \n\n## 停止等待ARQ协议 连续ARQ协议\nTCP使用的是什么协议？ \n\n---\n\n## new 和 malloc 的区别\n\n---\n## hash如何实现\nhash_table 开放寻址法 拉链法\n\n---\n\n## 如何实现TCP那样的可靠传输协议 有哪些难点\n 编号重排序， 校验和， 冗余丢弃，超时重传，拥塞控制， 流量控制\n\n---\n\n## 线程与进程\n| 特征       | 线程                                        | 进程                                      |\n| ---------- | ------------------------------------------- | ----------------------------------------- |\n| 定义       | 线程是进程的一部分，是程序执行的最小单元。 | 进程是操作系统分配资源的最小单位。       |\n| 资源占用   | 线程共享进程的资源，如内存空间、文件句柄等。| 进程有独立的资源空间，如内存、文件句柄等。 |\n| 切换开销   | 线程切换开销小，因为共享相同的地址空间。   | 进程切换开销大，因为需要切换不同的地址空间。|\n| 通信方式   | 线程间通信相对容易，因为共享相同的地址空间。| 进程间通信相对复杂，需要使用IPC机制。     |\n| 并发性     | 线程并发性高，多个线程可同时执行不同的任务。 | 进程并发性低，多个进程之间执行互不干扰。   |\n| 创建开销   | 创建线程的开销较小，通常只需要分配栈空间。  | 创建进程的开销较大，需要分配独立的地址空间、PCB等。 |\n| 故障隔离   | 一个线程崩溃可能导致整个进程崩溃。          | 一个进程崩溃不会影响其他进程。           |\n| 灵活性     | 线程间切换开销小，适合处理密集型任务。      | 进程间切换开销大，适合处理CPU密集型任务。 |\n\n---\n\n## 死锁\n1. 互斥条件：至少有一个资源是非共享的，即一次只能被一个进程使用。如果一个进程在使用该资源时，其他进程不能使用，直到该进程释放该资源。\n\n2. 请求与保持条件：一个进程可以请求资源并保持对其他资源的占用。即当一个进程在请求资源时，它可以继续持有已分配的资源，不释放。\n\n3. 不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程抢占，只能由该进程自己释放。\n\n4. 循环等待条件：若干个进程之间形成一种循环等待资源的关系，即每个进程都在等待下一个进程所持有的资源。\n\n# 构造一个死锁\n构造死锁的一个常见方式是通过多个进程之间的资源竞争，同时满足死锁的四个条件。例如，考虑两个进程A和B，它们都需要两个资源，但是资源的顺序分配不同，这可能导致死锁。具体来说：\n\n- 进程A获取资源1，进程B获取资源2。\n- 进程A请求资源2，但由于资源2已被进程B持有，所以进程A等待。\n- 同时，进程B请求资源1，但由于资源1已被进程A持有，所以进程B也等待。\n这样，进程A等待进程B释放资源2，而进程B等待进程A释放资源1，导致了死锁的发生。\n\n# 打破死锁\n要打破死锁或预防死锁，可以采取以下方法：\n\n- 避免死锁： 通过设计算法和协议来避免进程陷入死锁状态。例如，银行家算法可以在分配资源时避免死锁。\n\n- 检测和恢复： 定期检测系统中是否存在死锁，一旦检测到死锁，采取恢复措施。常见的方法包括进程终止、资源抢占和回滚操作等。\n\n- 避免资源竞争： 设计资源分配策略，尽量减少进程之间的资源竞争。例如，使用资源分配顺序来避免循环等待条件。\n\n- 加锁顺序： 规定所有进程对资源的访问顺序，确保所有进程以相同的顺序请求资源，从而避免环路的形成。\n\n- 超时机制： 对于等待资源的进程，设置超时机制，如果等待时间超过一定阈值，就放弃等待并释放已持有的资源，从而避免死锁。\n\n---\n\n### coding\n    合并两个升序链表\n\n---\n\n### 评价   \n# 寄！","slug":"tecent_interview","published":1,"date":"2024-04-09T05:17:38.076Z","updated":"2024-08-03T16:06:05.662Z","_id":"clut6jjd20000k6vkcg7wax8j","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"date-4-1-19-00\"><a href=\"#date-4-1-19-00\" class=\"headerlink\" title=\"date 4.1 19:00\"></a><strong>date</strong> 4.1 19:00</h2><h2 id=\"面试部门-QQ浏览器\"><a href=\"#面试部门-QQ浏览器\" class=\"headerlink\" title=\"面试部门 QQ浏览器\"></a><strong>面试部门</strong> QQ浏览器</h2><hr>\n<h2 id=\"HTTP-UDP-区别\"><a href=\"#HTTP-UDP-区别\" class=\"headerlink\" title=\"HTTP UDP 区别\"></a>HTTP UDP 区别</h2><table>\n<thead>\n<tr>\n<th>item</th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>面向连接的</td>\n<td>无连接的</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>提供可靠传输</td>\n<td>尽最大努力交付，不保证可靠传输</td>\n</tr>\n<tr>\n<td></td>\n<td>有拥塞控制机制</td>\n<td>无拥塞控制机制，不会降低源主机的发送速率，适合用于实时应用 语音 视频 直播</td>\n</tr>\n<tr>\n<td>传输对象</td>\n<td>字节流</td>\n<td>报文段</td>\n</tr>\n<tr>\n<td>传输效率</td>\n<td>慢</td>\n<td>快</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>20-60</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>场景</td>\n<td>适用于要求传输可靠的场景，如文件邮件传输</td>\n<td>适用于通信速率要求高 即时通讯场景，域名服务 语音视频</td>\n</tr>\n<tr>\n<td></td>\n<td>一对一</td>\n<td>一对多 一对一 多对一 多对多</td>\n</tr>\n<tr>\n<td>示例</td>\n<td>使用TCP的应用层协议有 FTP Telnet SMTP POP3 HTTP</td>\n<td>DNS SNMP TFTP</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"HTTP1-0-与-HTTP1-1-HTTP-2-0\"><a href=\"#HTTP1-0-与-HTTP1-1-HTTP-2-0\" class=\"headerlink\" title=\"HTTP1.0 与 HTTP1.1 HTTP 2.0\"></a>HTTP1.0 与 HTTP1.1 HTTP 2.0</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HTTP 1.0</th>\n<th>HTTP 1.1</th>\n<th>HTTP 2.0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>持久连接</td>\n<td>不支持</td>\n<td>允许在单个连接上发送多个请求和响应</td>\n<td>允许在单个连接上多路复用多个请求和响应</td>\n</tr>\n<tr>\n<td>头部压缩</td>\n<td>不支持</td>\n<td>引入了部分头部压缩机制</td>\n<td>引入了头部压缩，减少了重复的头部信息传输</td>\n</tr>\n<tr>\n<td>多路复用</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持多路复用，允许同时发送和接收多个请求和响应</td>\n</tr>\n<tr>\n<td>二进制传输</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>使用二进制格式传输数据，提高传输效率</td>\n</tr>\n<tr>\n<td>请求优先级</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持请求优先级，允许指定请求的优先级顺序</td>\n</tr>\n<tr>\n<td>流控制</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持流控制，避免了发送者超负荷发送数据</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"断点续传如何实现的\"><a href=\"#断点续传如何实现的\" class=\"headerlink\" title=\"断点续传如何实现的\"></a>断点续传如何实现的</h2><p>断点续传（Resumable Download）是一种通过在下载过程中保存已下载数据的方式，使用户可以在下载中断后继续下载而不必重新开始的技术。它通常在网络下载和上传中使用，尤其是针对大型文件或不稳定网络环境下的文件传输。</p>\n<p>实现断点续传通常包括以下步骤：</p>\n<ol>\n<li><p>服务器端支持： 服务器端需要支持断点续传功能。这通常涉及配置服务器以处理范围请求（Range Requests）。服务器接收到范围请求后，会返回请求的部分内容而不是整个文件。HTTP协议中使用的是Range头部来指示客户端需要的数据范围。</p>\n</li>\n<li><p>客户端实现： 客户端需要能够处理断点续传的逻辑。当下载中断后，客户端会向服务器发送一个包含已下载部分范围的范围请求。服务器会根据这个范围请求返回相应的数据。然后客户端会将这些数据与之前已下载的数据进行合并，从而实现断点续传。</p>\n</li>\n<li><p>断点记录： 客户端通常会记录已经下载的文件片段的信息，包括文件的大小、已下载的数据大小等。当下载中断时，客户端可以使用这些信息来向服务器发送范围请求。</p>\n</li>\n<li><p>续传标识： 服务器端通常会使用特定的HTTP头部（如Accept-Ranges和Content-Range）来指示客户端服务器是否支持范围请求以及返回的数据的范围。</p>\n</li>\n</ol>\n<p>总的来说，断点续传是通过客户端和服务器之间的协作来实现的。客户端在下载中断时发送范围请求，服务器根据请求返回相应的数据片段，客户端将这些数据片段与已下载的部分合并，从而实现断点续传。 </p>\n<hr>\n<h2 id=\"数据库技术\"><a href=\"#数据库技术\" class=\"headerlink\" title=\"数据库技术\"></a>数据库技术</h2><p>没学，寄！ </p>\n<hr>\n<h2 id=\"停止等待ARQ协议-连续ARQ协议\"><a href=\"#停止等待ARQ协议-连续ARQ协议\" class=\"headerlink\" title=\"停止等待ARQ协议 连续ARQ协议\"></a>停止等待ARQ协议 连续ARQ协议</h2><p>TCP使用的是什么协议？ </p>\n<hr>\n<h2 id=\"new-和-malloc-的区别\"><a href=\"#new-和-malloc-的区别\" class=\"headerlink\" title=\"new 和 malloc 的区别\"></a>new 和 malloc 的区别</h2><hr>\n<h2 id=\"hash如何实现\"><a href=\"#hash如何实现\" class=\"headerlink\" title=\"hash如何实现\"></a>hash如何实现</h2><p>hash_table 开放寻址法 拉链法</p>\n<hr>\n<h2 id=\"如何实现TCP那样的可靠传输协议-有哪些难点\"><a href=\"#如何实现TCP那样的可靠传输协议-有哪些难点\" class=\"headerlink\" title=\"如何实现TCP那样的可靠传输协议 有哪些难点\"></a>如何实现TCP那样的可靠传输协议 有哪些难点</h2><p> 编号重排序， 校验和， 冗余丢弃，超时重传，拥塞控制， 流量控制</p>\n<hr>\n<h2 id=\"线程与进程\"><a href=\"#线程与进程\" class=\"headerlink\" title=\"线程与进程\"></a>线程与进程</h2><table>\n<thead>\n<tr>\n<th>特征</th>\n<th>线程</th>\n<th>进程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义</td>\n<td>线程是进程的一部分，是程序执行的最小单元。</td>\n<td>进程是操作系统分配资源的最小单位。</td>\n</tr>\n<tr>\n<td>资源占用</td>\n<td>线程共享进程的资源，如内存空间、文件句柄等。</td>\n<td>进程有独立的资源空间，如内存、文件句柄等。</td>\n</tr>\n<tr>\n<td>切换开销</td>\n<td>线程切换开销小，因为共享相同的地址空间。</td>\n<td>进程切换开销大，因为需要切换不同的地址空间。</td>\n</tr>\n<tr>\n<td>通信方式</td>\n<td>线程间通信相对容易，因为共享相同的地址空间。</td>\n<td>进程间通信相对复杂，需要使用IPC机制。</td>\n</tr>\n<tr>\n<td>并发性</td>\n<td>线程并发性高，多个线程可同时执行不同的任务。</td>\n<td>进程并发性低，多个进程之间执行互不干扰。</td>\n</tr>\n<tr>\n<td>创建开销</td>\n<td>创建线程的开销较小，通常只需要分配栈空间。</td>\n<td>创建进程的开销较大，需要分配独立的地址空间、PCB等。</td>\n</tr>\n<tr>\n<td>故障隔离</td>\n<td>一个线程崩溃可能导致整个进程崩溃。</td>\n<td>一个进程崩溃不会影响其他进程。</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>线程间切换开销小，适合处理密集型任务。</td>\n<td>进程间切换开销大，适合处理CPU密集型任务。</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><ol>\n<li><p>互斥条件：至少有一个资源是非共享的，即一次只能被一个进程使用。如果一个进程在使用该资源时，其他进程不能使用，直到该进程释放该资源。</p>\n</li>\n<li><p>请求与保持条件：一个进程可以请求资源并保持对其他资源的占用。即当一个进程在请求资源时，它可以继续持有已分配的资源，不释放。</p>\n</li>\n<li><p>不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程抢占，只能由该进程自己释放。</p>\n</li>\n<li><p>循环等待条件：若干个进程之间形成一种循环等待资源的关系，即每个进程都在等待下一个进程所持有的资源。</p>\n</li>\n</ol>\n<h1 id=\"构造一个死锁\"><a href=\"#构造一个死锁\" class=\"headerlink\" title=\"构造一个死锁\"></a>构造一个死锁</h1><p>构造死锁的一个常见方式是通过多个进程之间的资源竞争，同时满足死锁的四个条件。例如，考虑两个进程A和B，它们都需要两个资源，但是资源的顺序分配不同，这可能导致死锁。具体来说：</p>\n<ul>\n<li>进程A获取资源1，进程B获取资源2。</li>\n<li>进程A请求资源2，但由于资源2已被进程B持有，所以进程A等待。</li>\n<li>同时，进程B请求资源1，但由于资源1已被进程A持有，所以进程B也等待。<br>这样，进程A等待进程B释放资源2，而进程B等待进程A释放资源1，导致了死锁的发生。</li>\n</ul>\n<h1 id=\"打破死锁\"><a href=\"#打破死锁\" class=\"headerlink\" title=\"打破死锁\"></a>打破死锁</h1><p>要打破死锁或预防死锁，可以采取以下方法：</p>\n<ul>\n<li><p>避免死锁： 通过设计算法和协议来避免进程陷入死锁状态。例如，银行家算法可以在分配资源时避免死锁。</p>\n</li>\n<li><p>检测和恢复： 定期检测系统中是否存在死锁，一旦检测到死锁，采取恢复措施。常见的方法包括进程终止、资源抢占和回滚操作等。</p>\n</li>\n<li><p>避免资源竞争： 设计资源分配策略，尽量减少进程之间的资源竞争。例如，使用资源分配顺序来避免循环等待条件。</p>\n</li>\n<li><p>加锁顺序： 规定所有进程对资源的访问顺序，确保所有进程以相同的顺序请求资源，从而避免环路的形成。</p>\n</li>\n<li><p>超时机制： 对于等待资源的进程，设置超时机制，如果等待时间超过一定阈值，就放弃等待并释放已持有的资源，从而避免死锁。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><pre><code>合并两个升序链表\n</code></pre>\n<hr>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h3><h1 id=\"寄！\"><a href=\"#寄！\" class=\"headerlink\" title=\"寄！\"></a>寄！</h1>","cover":false,"excerpt":"","more":"<h2 id=\"date-4-1-19-00\"><a href=\"#date-4-1-19-00\" class=\"headerlink\" title=\"date 4.1 19:00\"></a><strong>date</strong> 4.1 19:00</h2><h2 id=\"面试部门-QQ浏览器\"><a href=\"#面试部门-QQ浏览器\" class=\"headerlink\" title=\"面试部门 QQ浏览器\"></a><strong>面试部门</strong> QQ浏览器</h2><hr>\n<h2 id=\"HTTP-UDP-区别\"><a href=\"#HTTP-UDP-区别\" class=\"headerlink\" title=\"HTTP UDP 区别\"></a>HTTP UDP 区别</h2><table>\n<thead>\n<tr>\n<th>item</th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>面向连接的</td>\n<td>无连接的</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>提供可靠传输</td>\n<td>尽最大努力交付，不保证可靠传输</td>\n</tr>\n<tr>\n<td></td>\n<td>有拥塞控制机制</td>\n<td>无拥塞控制机制，不会降低源主机的发送速率，适合用于实时应用 语音 视频 直播</td>\n</tr>\n<tr>\n<td>传输对象</td>\n<td>字节流</td>\n<td>报文段</td>\n</tr>\n<tr>\n<td>传输效率</td>\n<td>慢</td>\n<td>快</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>20-60</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>场景</td>\n<td>适用于要求传输可靠的场景，如文件邮件传输</td>\n<td>适用于通信速率要求高 即时通讯场景，域名服务 语音视频</td>\n</tr>\n<tr>\n<td></td>\n<td>一对一</td>\n<td>一对多 一对一 多对一 多对多</td>\n</tr>\n<tr>\n<td>示例</td>\n<td>使用TCP的应用层协议有 FTP Telnet SMTP POP3 HTTP</td>\n<td>DNS SNMP TFTP</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"HTTP1-0-与-HTTP1-1-HTTP-2-0\"><a href=\"#HTTP1-0-与-HTTP1-1-HTTP-2-0\" class=\"headerlink\" title=\"HTTP1.0 与 HTTP1.1 HTTP 2.0\"></a>HTTP1.0 与 HTTP1.1 HTTP 2.0</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>HTTP 1.0</th>\n<th>HTTP 1.1</th>\n<th>HTTP 2.0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>持久连接</td>\n<td>不支持</td>\n<td>允许在单个连接上发送多个请求和响应</td>\n<td>允许在单个连接上多路复用多个请求和响应</td>\n</tr>\n<tr>\n<td>头部压缩</td>\n<td>不支持</td>\n<td>引入了部分头部压缩机制</td>\n<td>引入了头部压缩，减少了重复的头部信息传输</td>\n</tr>\n<tr>\n<td>多路复用</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持多路复用，允许同时发送和接收多个请求和响应</td>\n</tr>\n<tr>\n<td>二进制传输</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>使用二进制格式传输数据，提高传输效率</td>\n</tr>\n<tr>\n<td>请求优先级</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持请求优先级，允许指定请求的优先级顺序</td>\n</tr>\n<tr>\n<td>流控制</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持流控制，避免了发送者超负荷发送数据</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"断点续传如何实现的\"><a href=\"#断点续传如何实现的\" class=\"headerlink\" title=\"断点续传如何实现的\"></a>断点续传如何实现的</h2><p>断点续传（Resumable Download）是一种通过在下载过程中保存已下载数据的方式，使用户可以在下载中断后继续下载而不必重新开始的技术。它通常在网络下载和上传中使用，尤其是针对大型文件或不稳定网络环境下的文件传输。</p>\n<p>实现断点续传通常包括以下步骤：</p>\n<ol>\n<li><p>服务器端支持： 服务器端需要支持断点续传功能。这通常涉及配置服务器以处理范围请求（Range Requests）。服务器接收到范围请求后，会返回请求的部分内容而不是整个文件。HTTP协议中使用的是Range头部来指示客户端需要的数据范围。</p>\n</li>\n<li><p>客户端实现： 客户端需要能够处理断点续传的逻辑。当下载中断后，客户端会向服务器发送一个包含已下载部分范围的范围请求。服务器会根据这个范围请求返回相应的数据。然后客户端会将这些数据与之前已下载的数据进行合并，从而实现断点续传。</p>\n</li>\n<li><p>断点记录： 客户端通常会记录已经下载的文件片段的信息，包括文件的大小、已下载的数据大小等。当下载中断时，客户端可以使用这些信息来向服务器发送范围请求。</p>\n</li>\n<li><p>续传标识： 服务器端通常会使用特定的HTTP头部（如Accept-Ranges和Content-Range）来指示客户端服务器是否支持范围请求以及返回的数据的范围。</p>\n</li>\n</ol>\n<p>总的来说，断点续传是通过客户端和服务器之间的协作来实现的。客户端在下载中断时发送范围请求，服务器根据请求返回相应的数据片段，客户端将这些数据片段与已下载的部分合并，从而实现断点续传。 </p>\n<hr>\n<h2 id=\"数据库技术\"><a href=\"#数据库技术\" class=\"headerlink\" title=\"数据库技术\"></a>数据库技术</h2><p>没学，寄！ </p>\n<hr>\n<h2 id=\"停止等待ARQ协议-连续ARQ协议\"><a href=\"#停止等待ARQ协议-连续ARQ协议\" class=\"headerlink\" title=\"停止等待ARQ协议 连续ARQ协议\"></a>停止等待ARQ协议 连续ARQ协议</h2><p>TCP使用的是什么协议？ </p>\n<hr>\n<h2 id=\"new-和-malloc-的区别\"><a href=\"#new-和-malloc-的区别\" class=\"headerlink\" title=\"new 和 malloc 的区别\"></a>new 和 malloc 的区别</h2><hr>\n<h2 id=\"hash如何实现\"><a href=\"#hash如何实现\" class=\"headerlink\" title=\"hash如何实现\"></a>hash如何实现</h2><p>hash_table 开放寻址法 拉链法</p>\n<hr>\n<h2 id=\"如何实现TCP那样的可靠传输协议-有哪些难点\"><a href=\"#如何实现TCP那样的可靠传输协议-有哪些难点\" class=\"headerlink\" title=\"如何实现TCP那样的可靠传输协议 有哪些难点\"></a>如何实现TCP那样的可靠传输协议 有哪些难点</h2><p> 编号重排序， 校验和， 冗余丢弃，超时重传，拥塞控制， 流量控制</p>\n<hr>\n<h2 id=\"线程与进程\"><a href=\"#线程与进程\" class=\"headerlink\" title=\"线程与进程\"></a>线程与进程</h2><table>\n<thead>\n<tr>\n<th>特征</th>\n<th>线程</th>\n<th>进程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义</td>\n<td>线程是进程的一部分，是程序执行的最小单元。</td>\n<td>进程是操作系统分配资源的最小单位。</td>\n</tr>\n<tr>\n<td>资源占用</td>\n<td>线程共享进程的资源，如内存空间、文件句柄等。</td>\n<td>进程有独立的资源空间，如内存、文件句柄等。</td>\n</tr>\n<tr>\n<td>切换开销</td>\n<td>线程切换开销小，因为共享相同的地址空间。</td>\n<td>进程切换开销大，因为需要切换不同的地址空间。</td>\n</tr>\n<tr>\n<td>通信方式</td>\n<td>线程间通信相对容易，因为共享相同的地址空间。</td>\n<td>进程间通信相对复杂，需要使用IPC机制。</td>\n</tr>\n<tr>\n<td>并发性</td>\n<td>线程并发性高，多个线程可同时执行不同的任务。</td>\n<td>进程并发性低，多个进程之间执行互不干扰。</td>\n</tr>\n<tr>\n<td>创建开销</td>\n<td>创建线程的开销较小，通常只需要分配栈空间。</td>\n<td>创建进程的开销较大，需要分配独立的地址空间、PCB等。</td>\n</tr>\n<tr>\n<td>故障隔离</td>\n<td>一个线程崩溃可能导致整个进程崩溃。</td>\n<td>一个进程崩溃不会影响其他进程。</td>\n</tr>\n<tr>\n<td>灵活性</td>\n<td>线程间切换开销小，适合处理密集型任务。</td>\n<td>进程间切换开销大，适合处理CPU密集型任务。</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><ol>\n<li><p>互斥条件：至少有一个资源是非共享的，即一次只能被一个进程使用。如果一个进程在使用该资源时，其他进程不能使用，直到该进程释放该资源。</p>\n</li>\n<li><p>请求与保持条件：一个进程可以请求资源并保持对其他资源的占用。即当一个进程在请求资源时，它可以继续持有已分配的资源，不释放。</p>\n</li>\n<li><p>不剥夺条件：进程已经获得的资源在未使用完之前，不能被其他进程抢占，只能由该进程自己释放。</p>\n</li>\n<li><p>循环等待条件：若干个进程之间形成一种循环等待资源的关系，即每个进程都在等待下一个进程所持有的资源。</p>\n</li>\n</ol>\n<h1 id=\"构造一个死锁\"><a href=\"#构造一个死锁\" class=\"headerlink\" title=\"构造一个死锁\"></a>构造一个死锁</h1><p>构造死锁的一个常见方式是通过多个进程之间的资源竞争，同时满足死锁的四个条件。例如，考虑两个进程A和B，它们都需要两个资源，但是资源的顺序分配不同，这可能导致死锁。具体来说：</p>\n<ul>\n<li>进程A获取资源1，进程B获取资源2。</li>\n<li>进程A请求资源2，但由于资源2已被进程B持有，所以进程A等待。</li>\n<li>同时，进程B请求资源1，但由于资源1已被进程A持有，所以进程B也等待。<br>这样，进程A等待进程B释放资源2，而进程B等待进程A释放资源1，导致了死锁的发生。</li>\n</ul>\n<h1 id=\"打破死锁\"><a href=\"#打破死锁\" class=\"headerlink\" title=\"打破死锁\"></a>打破死锁</h1><p>要打破死锁或预防死锁，可以采取以下方法：</p>\n<ul>\n<li><p>避免死锁： 通过设计算法和协议来避免进程陷入死锁状态。例如，银行家算法可以在分配资源时避免死锁。</p>\n</li>\n<li><p>检测和恢复： 定期检测系统中是否存在死锁，一旦检测到死锁，采取恢复措施。常见的方法包括进程终止、资源抢占和回滚操作等。</p>\n</li>\n<li><p>避免资源竞争： 设计资源分配策略，尽量减少进程之间的资源竞争。例如，使用资源分配顺序来避免循环等待条件。</p>\n</li>\n<li><p>加锁顺序： 规定所有进程对资源的访问顺序，确保所有进程以相同的顺序请求资源，从而避免环路的形成。</p>\n</li>\n<li><p>超时机制： 对于等待资源的进程，设置超时机制，如果等待时间超过一定阈值，就放弃等待并释放已持有的资源，从而避免死锁。</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><pre><code>合并两个升序链表\n</code></pre>\n<hr>\n<h3 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h3><h1 id=\"寄！\"><a href=\"#寄！\" class=\"headerlink\" title=\"寄！\"></a>寄！</h1>"},{"title":"排序方法 总结","_content":"\n总结一下各种排序方法 和模版\n主要包括 快速排序，归并排序，冒泡排序，堆排序，希尔排序\n以及sort函数的自定义比较函数的使用\n\n## 快速排序 升序排序\n```c++\nvoid quicksort(vector<int>& nums, int l, int r){\n    if(l >= r) return;\n    int i = l, j = r; //这里选择哨兵是最左边的元素，\n    while (i < j) {\n        while(i < j && nums[j] >= nums[l]) j--; // 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 < nums[l] 的元素\n        while(i < j && nums[i] <= nums[l]) i++; // 这样 循环外的 swap（nums[l], nums[j]) 才是对的；\n        swap(nums[i],nums[j]);\n    }\n    swap(nums[l], nums[j]);\n\n    // 递归\n    quicksort(nums, l, j - 1);\n    quicksort(nums, j + 1, r);\n\n}\n```\n\n\n 降序排序\n\n```c++ \nvoid quicksort(vector<int>& nums, int l, int r){\n    if(l >= r) return;\n    int i = l, j = r; //这里选择哨兵是最左边的元素，\n    while (i < j) {\n        while(i < j && nums[j] <= nums[l]) j--; // 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 < nums[l] 的元素\n        while(i < j && nums[i] >= nums[l]) i++; // 这样 循环外的 swap（nums[l], nums[j]) 才是对的；\n        swap(nums[i],nums[j]);\n    }\n    swap(nums[l], nums[j]);\n\n    // 递归\n    quicksort(nums, l, j - 1);\n    quicksort(nums, j + 1, r);\n```\n\n快速排序的特殊用途\n在o(n)的时间复杂度下得出第k小的数\n方法 由于哨兵就是分界点，某次递归的时候发现哨兵的位置i就是k，那么说明当前位置的哨兵就是第k小的值\n\n> 空间复杂度 <mark style=\"background-color: yellow;\">o(1)</mark>  \n> 平均时间复杂度 <mark style=\"background-color: yellow;\">o(nlogn)</mark>  \n> 最坏情况复杂度 <mark style=\"background-color: yellow;\">o(n2)</mark> 每次都选中了最小的 或者最大的\n\n\n## 归并排序\n```c++\nvoid merged_sort(vector<int>& nums, vector<int>& temp, int l, int r){\n    if(l >= r) return;\n    int m = l + (r - l) / 2;\n    merged_sort(nums, temp, l, m);\n    merged_sort(nums, temp, m+1, r);\n\n    //合并过程, 递归下去的时候两部分已经弄好了，所以需要使用temp 来保存\n    // 有序的左右2part， nums用于返回排序好的部分\n    int i = l, j = m + 1;\n\n    for(int k = l; k <= r; k++){\n        temp[k] = nums[k];\n    }\n    // 开始合并\n    for(int k = l; k <= r; k++){\n        if(i >= m+1){\n            nums[k] = temp[j++];\n        }else if(j > r || temp[i] <= temp[j]){\n            nums[k] = temp[i++];\n        }else{\n            nums[k] = temp[j++]; // ====求逆序数在这统计即可======\n        }\n    }\n\n}\n```\n归并排序的特殊用途：\n- 归并排序的特殊用途， 求逆序数 ，但是不能用于求每个位置的逆序数，只能求逆序数的总和\n- 在注释的位置加上统计操作，返回统计结果就可以了\n- 求每个位置的逆序数需要使用树状数组，树状数组也可以求逆序数的和\n\n\n> 空间复杂度 o(N);\n> 平均时间复杂度 o(nlogn)\n> 最坏情况复杂度 o(nlogn)\n\n\n\n## 冒泡排序\n```c++\nvoid bubbleSort(vector<int>& nums) {\n    int n = nums.size();\n    bool swapped; // 标记是否发生交换\n\n    for (int i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (nums[j] > nums[j + 1]) {\n                swap(nums[j], nums[j + 1]);\n                swapped = true;\n            }\n        }\n        // 如果本轮没有发生交换，则数组已经有序，可以提前结束\n        if (!swapped) break;\n    }\n}\n```\n> 时间复杂度 <mark style=\"background-color:yellow\"> o(n2) </mark>\n> 空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark>\n\n\n## 堆排序\n```c++\nvoid heapify(vector<int>& nums, int n, int i) {\n    int largest = i; // 将当前节点标记为最大值\n    int left = 2 * i + 1; // 左子节点的索引\n    int right = 2 * i + 2; // 右子节点的索引\n\n    // 找出当前节点、左子节点和右子节点中的最大值\n    if (left < n && nums[left] > nums[largest]) {\n        largest = left;\n    }\n    if (right < n && nums[right] > nums[largest]) {\n        largest = right;\n    }\n\n    // 如果最大值不是当前节点，则将最大值与当前节点交换，并递归调整\n    if (largest != i) {\n        swap(nums, i, largest);\n        heapify(nums, n, largest);\n    }\n}\n\n// 堆排序函数\nvoid heapSort(vector<int>& nums) {\n    int n = nums.size();\n\n    // 构建最大堆，从最后一个非叶子节点开始向上调整\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(nums, n, i);\n    }\n\n    // 依次将堆顶元素与末尾元素交换，并调整堆\n    for (int i = n - 1; i > 0; i--) {\n        swap(nums, 0, i); // 将堆顶元素（最大值）与当前末尾元素交换\n        heapify(nums, i, 0); // 调整堆，使剩余部分重新成为最大堆\n    }\n}\n\n```\n\n> 空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark>\n> 平均时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark>\n> 最坏时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark>\n>\n>***它的性能表现良好，在实践中通常比较高效，尤其适用于大型数据集。然而，堆排序的主要缺点是不稳定性，即相同值的元素在排序后可能会改变相对顺序。***\n\n\n## 希尔排序","source":"_posts/排序方法.md","raw":"---\ntitle: 排序方法 总结\n---\n\n总结一下各种排序方法 和模版\n主要包括 快速排序，归并排序，冒泡排序，堆排序，希尔排序\n以及sort函数的自定义比较函数的使用\n\n## 快速排序 升序排序\n```c++\nvoid quicksort(vector<int>& nums, int l, int r){\n    if(l >= r) return;\n    int i = l, j = r; //这里选择哨兵是最左边的元素，\n    while (i < j) {\n        while(i < j && nums[j] >= nums[l]) j--; // 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 < nums[l] 的元素\n        while(i < j && nums[i] <= nums[l]) i++; // 这样 循环外的 swap（nums[l], nums[j]) 才是对的；\n        swap(nums[i],nums[j]);\n    }\n    swap(nums[l], nums[j]);\n\n    // 递归\n    quicksort(nums, l, j - 1);\n    quicksort(nums, j + 1, r);\n\n}\n```\n\n\n 降序排序\n\n```c++ \nvoid quicksort(vector<int>& nums, int l, int r){\n    if(l >= r) return;\n    int i = l, j = r; //这里选择哨兵是最左边的元素，\n    while (i < j) {\n        while(i < j && nums[j] <= nums[l]) j--; // 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 < nums[l] 的元素\n        while(i < j && nums[i] >= nums[l]) i++; // 这样 循环外的 swap（nums[l], nums[j]) 才是对的；\n        swap(nums[i],nums[j]);\n    }\n    swap(nums[l], nums[j]);\n\n    // 递归\n    quicksort(nums, l, j - 1);\n    quicksort(nums, j + 1, r);\n```\n\n快速排序的特殊用途\n在o(n)的时间复杂度下得出第k小的数\n方法 由于哨兵就是分界点，某次递归的时候发现哨兵的位置i就是k，那么说明当前位置的哨兵就是第k小的值\n\n> 空间复杂度 <mark style=\"background-color: yellow;\">o(1)</mark>  \n> 平均时间复杂度 <mark style=\"background-color: yellow;\">o(nlogn)</mark>  \n> 最坏情况复杂度 <mark style=\"background-color: yellow;\">o(n2)</mark> 每次都选中了最小的 或者最大的\n\n\n## 归并排序\n```c++\nvoid merged_sort(vector<int>& nums, vector<int>& temp, int l, int r){\n    if(l >= r) return;\n    int m = l + (r - l) / 2;\n    merged_sort(nums, temp, l, m);\n    merged_sort(nums, temp, m+1, r);\n\n    //合并过程, 递归下去的时候两部分已经弄好了，所以需要使用temp 来保存\n    // 有序的左右2part， nums用于返回排序好的部分\n    int i = l, j = m + 1;\n\n    for(int k = l; k <= r; k++){\n        temp[k] = nums[k];\n    }\n    // 开始合并\n    for(int k = l; k <= r; k++){\n        if(i >= m+1){\n            nums[k] = temp[j++];\n        }else if(j > r || temp[i] <= temp[j]){\n            nums[k] = temp[i++];\n        }else{\n            nums[k] = temp[j++]; // ====求逆序数在这统计即可======\n        }\n    }\n\n}\n```\n归并排序的特殊用途：\n- 归并排序的特殊用途， 求逆序数 ，但是不能用于求每个位置的逆序数，只能求逆序数的总和\n- 在注释的位置加上统计操作，返回统计结果就可以了\n- 求每个位置的逆序数需要使用树状数组，树状数组也可以求逆序数的和\n\n\n> 空间复杂度 o(N);\n> 平均时间复杂度 o(nlogn)\n> 最坏情况复杂度 o(nlogn)\n\n\n\n## 冒泡排序\n```c++\nvoid bubbleSort(vector<int>& nums) {\n    int n = nums.size();\n    bool swapped; // 标记是否发生交换\n\n    for (int i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (nums[j] > nums[j + 1]) {\n                swap(nums[j], nums[j + 1]);\n                swapped = true;\n            }\n        }\n        // 如果本轮没有发生交换，则数组已经有序，可以提前结束\n        if (!swapped) break;\n    }\n}\n```\n> 时间复杂度 <mark style=\"background-color:yellow\"> o(n2) </mark>\n> 空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark>\n\n\n## 堆排序\n```c++\nvoid heapify(vector<int>& nums, int n, int i) {\n    int largest = i; // 将当前节点标记为最大值\n    int left = 2 * i + 1; // 左子节点的索引\n    int right = 2 * i + 2; // 右子节点的索引\n\n    // 找出当前节点、左子节点和右子节点中的最大值\n    if (left < n && nums[left] > nums[largest]) {\n        largest = left;\n    }\n    if (right < n && nums[right] > nums[largest]) {\n        largest = right;\n    }\n\n    // 如果最大值不是当前节点，则将最大值与当前节点交换，并递归调整\n    if (largest != i) {\n        swap(nums, i, largest);\n        heapify(nums, n, largest);\n    }\n}\n\n// 堆排序函数\nvoid heapSort(vector<int>& nums) {\n    int n = nums.size();\n\n    // 构建最大堆，从最后一个非叶子节点开始向上调整\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(nums, n, i);\n    }\n\n    // 依次将堆顶元素与末尾元素交换，并调整堆\n    for (int i = n - 1; i > 0; i--) {\n        swap(nums, 0, i); // 将堆顶元素（最大值）与当前末尾元素交换\n        heapify(nums, i, 0); // 调整堆，使剩余部分重新成为最大堆\n    }\n}\n\n```\n\n> 空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark>\n> 平均时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark>\n> 最坏时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark>\n>\n>***它的性能表现良好，在实践中通常比较高效，尤其适用于大型数据集。然而，堆排序的主要缺点是不稳定性，即相同值的元素在排序后可能会改变相对顺序。***\n\n\n## 希尔排序","slug":"排序方法","published":1,"date":"2024-04-12T08:40:20.022Z","updated":"2024-04-28T13:09:14.800Z","_id":"cluwf44f800007qvkbetga849","comments":1,"layout":"post","photos":[],"content":"<p>总结一下各种排序方法 和模版<br>主要包括 快速排序，归并排序，冒泡排序，堆排序，希尔排序<br>以及sort函数的自定义比较函数的使用</p>\n<h2 id=\"快速排序-升序排序\"><a href=\"#快速排序-升序排序\" class=\"headerlink\" title=\"快速排序 升序排序\"></a>快速排序 升序排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = r; <span class=\"comment\">//这里选择哨兵是最左边的元素，</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--; <span class=\"comment\">// 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 &lt; nums[l] 的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++; <span class=\"comment\">// 这样 循环外的 swap（nums[l], nums[j]) 才是对的；</span></span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums[i],nums[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(nums[l], nums[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归</span></span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, l, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, j + <span class=\"number\">1</span>, r);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p> 降序排序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = r; <span class=\"comment\">//这里选择哨兵是最左边的元素，</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[j] &lt;= nums[l]) j--; <span class=\"comment\">// 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 &lt; nums[l] 的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[i] &gt;= nums[l]) i++; <span class=\"comment\">// 这样 循环外的 swap（nums[l], nums[j]) 才是对的；</span></span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums[i],nums[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(nums[l], nums[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归</span></span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, l, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, j + <span class=\"number\">1</span>, r);</span><br></pre></td></tr></table></figure>\n\n<p>快速排序的特殊用途<br>在o(n)的时间复杂度下得出第k小的数<br>方法 由于哨兵就是分界点，某次递归的时候发现哨兵的位置i就是k，那么说明当前位置的哨兵就是第k小的值</p>\n<blockquote>\n<p>空间复杂度 <mark style=\"background-color: yellow;\">o(1)</mark><br>平均时间复杂度 <mark style=\"background-color: yellow;\">o(nlogn)</mark><br>最坏情况复杂度 <mark style=\"background-color: yellow;\">o(n2)</mark> 每次都选中了最小的 或者最大的</p>\n</blockquote>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merged_sort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">int</span>&gt;&amp; temp, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = l + (r - l) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">merged_sort</span>(nums, temp, l, m);</span><br><span class=\"line\">    <span class=\"built_in\">merged_sort</span>(nums, temp, m+<span class=\"number\">1</span>, r);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并过程, 递归下去的时候两部分已经弄好了，所以需要使用temp 来保存</span></span><br><span class=\"line\">    <span class=\"comment\">// 有序的左右2part， nums用于返回排序好的部分</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = m + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class=\"line\">        temp[k] = nums[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 开始合并</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= m+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            nums[k] = temp[j++];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &gt; r || temp[i] &lt;= temp[j])&#123;</span><br><span class=\"line\">            nums[k] = temp[i++];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            nums[k] = temp[j++]; <span class=\"comment\">// ====求逆序数在这统计即可======</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>归并排序的特殊用途：</p>\n<ul>\n<li>归并排序的特殊用途， 求逆序数 ，但是不能用于求每个位置的逆序数，只能求逆序数的总和</li>\n<li>在注释的位置加上统计操作，返回统计结果就可以了</li>\n<li>求每个位置的逆序数需要使用树状数组，树状数组也可以求逆序数的和</li>\n</ul>\n<blockquote>\n<p>空间复杂度 o(N);<br>平均时间复杂度 o(nlogn)<br>最坏情况复杂度 o(nlogn)</p>\n</blockquote>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">bool</span> swapped; <span class=\"comment\">// 标记是否发生交换</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        swapped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[j], nums[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                swapped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果本轮没有发生交换，则数组已经有序，可以提前结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!swapped) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>时间复杂度 <mark style=\"background-color:yellow\"> o(n2) </mark><br>空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark></p>\n</blockquote>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapify</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> n, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> largest = i; <span class=\"comment\">// 将当前节点标记为最大值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>; <span class=\"comment\">// 左子节点的索引</span></span><br><span class=\"line\">    <span class=\"type\">int</span> right = <span class=\"number\">2</span> * i + <span class=\"number\">2</span>; <span class=\"comment\">// 右子节点的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 找出当前节点、左子节点和右子节点中的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class=\"line\">        largest = left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class=\"line\">        largest = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果最大值不是当前节点，则将最大值与当前节点交换，并递归调整</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums, i, largest);</span><br><span class=\"line\">        <span class=\"built_in\">heapify</span>(nums, n, largest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆排序函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建最大堆，从最后一个非叶子节点开始向上调整</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">heapify</span>(nums, n, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 依次将堆顶元素与末尾元素交换，并调整堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums, <span class=\"number\">0</span>, i); <span class=\"comment\">// 将堆顶元素（最大值）与当前末尾元素交换</span></span><br><span class=\"line\">        <span class=\"built_in\">heapify</span>(nums, i, <span class=\"number\">0</span>); <span class=\"comment\">// 调整堆，使剩余部分重新成为最大堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark><br>平均时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark><br>最坏时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark></p>\n<p><em><strong>它的性能表现良好，在实践中通常比较高效，尤其适用于大型数据集。然而，堆排序的主要缺点是不稳定性，即相同值的元素在排序后可能会改变相对顺序。</strong></em></p>\n</blockquote>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2>","cover":false,"excerpt":"","more":"<p>总结一下各种排序方法 和模版<br>主要包括 快速排序，归并排序，冒泡排序，堆排序，希尔排序<br>以及sort函数的自定义比较函数的使用</p>\n<h2 id=\"快速排序-升序排序\"><a href=\"#快速排序-升序排序\" class=\"headerlink\" title=\"快速排序 升序排序\"></a>快速排序 升序排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = r; <span class=\"comment\">//这里选择哨兵是最左边的元素，</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--; <span class=\"comment\">// 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 &lt; nums[l] 的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++; <span class=\"comment\">// 这样 循环外的 swap（nums[l], nums[j]) 才是对的；</span></span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums[i],nums[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(nums[l], nums[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归</span></span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, l, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, j + <span class=\"number\">1</span>, r);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p> 降序排序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quicksort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = r; <span class=\"comment\">//这里选择哨兵是最左边的元素，</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[j] &lt;= nums[l]) j--; <span class=\"comment\">// 这里的顺序也有要求， 先 j 再 i 最后退出外层循环的才是 j = i = 一个 &lt; nums[l] 的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j &amp;&amp; nums[i] &gt;= nums[l]) i++; <span class=\"comment\">// 这样 循环外的 swap（nums[l], nums[j]) 才是对的；</span></span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums[i],nums[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(nums[l], nums[j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归</span></span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, l, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quicksort</span>(nums, j + <span class=\"number\">1</span>, r);</span><br></pre></td></tr></table></figure>\n\n<p>快速排序的特殊用途<br>在o(n)的时间复杂度下得出第k小的数<br>方法 由于哨兵就是分界点，某次递归的时候发现哨兵的位置i就是k，那么说明当前位置的哨兵就是第k小的值</p>\n<blockquote>\n<p>空间复杂度 <mark style=\"background-color: yellow;\">o(1)</mark><br>平均时间复杂度 <mark style=\"background-color: yellow;\">o(nlogn)</mark><br>最坏情况复杂度 <mark style=\"background-color: yellow;\">o(n2)</mark> 每次都选中了最小的 或者最大的</p>\n</blockquote>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merged_sort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">int</span>&gt;&amp; temp, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = l + (r - l) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">merged_sort</span>(nums, temp, l, m);</span><br><span class=\"line\">    <span class=\"built_in\">merged_sort</span>(nums, temp, m+<span class=\"number\">1</span>, r);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//合并过程, 递归下去的时候两部分已经弄好了，所以需要使用temp 来保存</span></span><br><span class=\"line\">    <span class=\"comment\">// 有序的左右2part， nums用于返回排序好的部分</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = m + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class=\"line\">        temp[k] = nums[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 开始合并</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= m+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            nums[k] = temp[j++];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j &gt; r || temp[i] &lt;= temp[j])&#123;</span><br><span class=\"line\">            nums[k] = temp[i++];</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            nums[k] = temp[j++]; <span class=\"comment\">// ====求逆序数在这统计即可======</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>归并排序的特殊用途：</p>\n<ul>\n<li>归并排序的特殊用途， 求逆序数 ，但是不能用于求每个位置的逆序数，只能求逆序数的总和</li>\n<li>在注释的位置加上统计操作，返回统计结果就可以了</li>\n<li>求每个位置的逆序数需要使用树状数组，树状数组也可以求逆序数的和</li>\n</ul>\n<blockquote>\n<p>空间复杂度 o(N);<br>平均时间复杂度 o(nlogn)<br>最坏情况复杂度 o(nlogn)</p>\n</blockquote>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">bool</span> swapped; <span class=\"comment\">// 标记是否发生交换</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        swapped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[j], nums[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                swapped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果本轮没有发生交换，则数组已经有序，可以提前结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!swapped) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>时间复杂度 <mark style=\"background-color:yellow\"> o(n2) </mark><br>空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark></p>\n</blockquote>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapify</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> n, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> largest = i; <span class=\"comment\">// 将当前节点标记为最大值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>; <span class=\"comment\">// 左子节点的索引</span></span><br><span class=\"line\">    <span class=\"type\">int</span> right = <span class=\"number\">2</span> * i + <span class=\"number\">2</span>; <span class=\"comment\">// 右子节点的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 找出当前节点、左子节点和右子节点中的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class=\"line\">        largest = left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class=\"line\">        largest = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果最大值不是当前节点，则将最大值与当前节点交换，并递归调整</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (largest != i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums, i, largest);</span><br><span class=\"line\">        <span class=\"built_in\">heapify</span>(nums, n, largest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆排序函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建最大堆，从最后一个非叶子节点开始向上调整</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">heapify</span>(nums, n, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 依次将堆顶元素与末尾元素交换，并调整堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums, <span class=\"number\">0</span>, i); <span class=\"comment\">// 将堆顶元素（最大值）与当前末尾元素交换</span></span><br><span class=\"line\">        <span class=\"built_in\">heapify</span>(nums, i, <span class=\"number\">0</span>); <span class=\"comment\">// 调整堆，使剩余部分重新成为最大堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>空间复杂度 <mark style=\"background-color:yellow\"> o(1) </mark><br>平均时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark><br>最坏时间复杂度 <mark style=\"background-color:yellow\"> o(nlogn) </mark></p>\n<p><em><strong>它的性能表现良好，在实践中通常比较高效，尤其适用于大型数据集。然而，堆排序的主要缺点是不稳定性，即相同值的元素在排序后可能会改变相对顺序。</strong></em></p>\n</blockquote>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2>"},{"title":"docker","_content":"","source":"_posts/Docker.md","raw":"---\ntitle: docker\n---","slug":"Docker","published":1,"date":"2024-04-12T13:01:53.273Z","updated":"2024-04-12T13:02:08.339Z","comments":1,"layout":"post","photos":[],"_id":"cluwq56w700000cvke4vkh9ab","content":"","cover":false,"excerpt":"","more":""},{"title":"cpp learning","_content":"","source":"_posts/cpp.md","raw":"---\ntitle: cpp learning\n---","slug":"cpp","published":1,"date":"2024-04-12T13:03:15.439Z","updated":"2024-04-12T13:48:58.418Z","comments":1,"layout":"post","photos":[],"_id":"cluwq56w900010cvkabxb20d5","content":"","cover":false,"excerpt":"","more":""},{"title":"os learning","_content":"","source":"_posts/操作系统.md","raw":"---\ntitle: os learning\n---","slug":"操作系统","published":1,"date":"2024-04-12T12:44:59.591Z","updated":"2024-04-12T12:45:29.858Z","comments":1,"layout":"post","photos":[],"_id":"cluwq56wb00030cvk2i7x72ui","content":"","cover":false,"excerpt":"","more":""},{"title":"数据库-mysql","_content":"","source":"_posts/数据库-mysql.md","raw":"---\ntitle: 数据库-mysql\n---","slug":"数据库-mysql","published":1,"date":"2024-04-12T12:47:31.515Z","updated":"2024-04-12T12:48:43.038Z","comments":1,"layout":"post","photos":[],"_id":"cluwq56wb00040cvkasvt01b1","content":"","cover":false,"excerpt":"","more":""},{"title":"数据库-redis","_content":"","source":"_posts/数据库-redis.md","raw":"---\ntitle: 数据库-redis\n---","slug":"数据库-redis","published":1,"date":"2024-04-12T12:47:18.163Z","updated":"2024-04-12T14:05:05.409Z","_id":"cluwq56wc00050cvkhmch7lqs","comments":1,"layout":"post","photos":[],"content":"","cover":false,"excerpt":"","more":""},{"title":"计算机网络","_content":"\n---\ntitle: 计网\n\n\n---\n\n## 模型架构\n\n三种模型 分别是OSI TCP/IP 五层模型\n\n> 为什么要设计不同的layer？\n\n对于同一台设备的不同进程的通信，有很多方式 <font color = blue>管道，消息队列，信号，共享内存 </font>,  但是对于不同设备的进程间通信，就会使用到网络通信， 各种设备具有不同的特性，为了兼容，就协商出了一套通用的网络协议\n\n网络的分层：\n\n1. **模块化设计**：网络分层将整个网络系统分解为多个层次，每个层次都有特定的功能和责任。这种模块化设计使得网络结构更加清晰，降低了网络系统的复杂度，方便了系统的设计、开发和维护。\n2. **标准化**：每个网络层次都有相应的标准和协议，定义了该层次的功能、数据格式、传输方式等规范。这些标准和协议使得不同厂商的网络设备和软件可以互相兼容和通信，促进了网络设备的互联互通。\n3. **提高可靠性**：各层之间解耦合，由于每个层次都有明确的功能和责任，网络分层可以提高网络系统的可靠性。当一个层次出现问题时，只需修复该层次，而不会影响到其他层次，从而提高了网络系统的稳定性和可靠性。\n4. **提高性能**：网络分层可以使网络通信过程更加高效。每个层次只需关注自己的功能和责任，而不需要关心其他层次的具体实现细节，从而提高了网络通信的效率。\n5. **降低成本**：网络分层可以将网络系统分解为多个相对独立的模块，降低了系统设计、开发和维护的成本。此外，通过使用标准化的协议和技术，可以降低网络设备和软件的开发成本，提高了网络系统的经济效益。\n\n### TCP/IP 网络模型\n\n#### 应用层\n\n进程需要通信时，就把数据传给下一层，应用层只需要关注为用户提供功能，如HTPTP，FTP，Telnet，DNS, SMTP;\n\n应用层不关心怎么传输，只负责把数据给传输层\n\n工作在用户态\n\n\n\n#### 传输层\n\n应用层的数据包会给传输层，传输层负责给应用层提供服务\n\n##### 两个协议TCP和UDP\n\nTransmission Control Protocol, 大部分应用使用的都是传输控制协议TCP，如HTTP，TCP面向连接，多了很多特性，保证可靠的交付，UDP不保证可靠交付，但是传输效率较高\n\n> 要实现可靠的UDP也可以，只需要在UDP上把TCP的特性实现一遍就行了，拥塞控制，流量控制，超时重传...\n\n\n\n要传输的数据可能很大，直接传不太方便，所以需要对数据包进行分块，TCP传输的数据是报文段，传输的数据大小超过了MSS（TCP最大报文段长度），就需要对数据包分块，这样即使有一个包丢失了，只需要重传丢失的即可。\n\n\n\n传输层在接收方需要干的事情就是 负责处理下层送上的数据，去掉之前加上的头部，顺序重组，校验和... 然后上传给应用层\n\n> 如何区分是哪个应用呢？端口号\n>\n> 80 web服务器使用的端口号，22 ssh服务使用的端口号...\n\n\n\n#### 网络层\n\n传输层只负责传输过程的一些预处理，但实际上并不负责传输\n\n实际上的网络环境十分复杂，有非常多的节点和设备，需要进行路径和节点的选择，这部分交给传输层做就有点冗余了，因此把这一部分分出来给网络层做，进一步解耦。\n\n网络层最常使用的就是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP头部组成IP报文，如果IP报文超过了MTU（1500 bytes normally），就再次分段，得到一个IP报文段。\n\n\n\n> 网络层负责将数据传输到另外一个设备，世界上这么多设备，如何找到对方呢？网络层需要有 区分不同设备的编号 -> <mark background-color=\"yellow\">IP</mark>\n\n\n\n网络号 主机号 子网掩码\n\n在寻址过程中，先找到对应的网络号（先找到学校），再去找主机号（在找对应的人）\n\n除了寻址，网络层还有一件事情就是路由，数据传输过程中，并不是一条网线走到黑，而是需要经过一系列的节点（交换机，路由器，转发），所以网络层需要通过路由算法来决定下一步走哪个节点\n\nIP协议告诉你要去哪里，路由告诉你下一跳该去哪，一个是大局，一个是细节\n\n\n\n#### 网络接口层\n\n加上了IP头部之后，交给网络接口层，在头部再加上MAC头部，封装成一个数据帧发送到网络上\n\n\n\nIP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们就可以知道这个包要去哪，但是在以太网的世界中，是行不通的，\n\n以太网是一种在局域网内将附近的设备连接起来进行通信的技术。以太网在区分设备的时候是通过MAC地址判断的，MAC就是设备网卡的硬件地址，出厂时唯一设定，\n\n\n\nMAC头部是以太网使用的头部，包含接收方和发送方的MAC地址信息，可以通过ARP协议获取MAC地址，\n\n\n\n网络接口层为网络提供 **链路级别** 传输的服务，负责在以太网，WIFI这样的底层网络上发送数据包，工作在网卡这个层次，使用MAC地址来标识网络设备\n\n| 层级        | 地址类型 | 功能                       |\n| ----------- | -------- | -------------------------- |\n| 网络层 (IP) | IP地址   | 在网络中唯一标识设备       |\n| 数据链路层  | MAC地址  | 在同一局域网内唯一标识设备 |\n\n\n\n\n\n#### 总结\n\n**上至下**\n\n|   layer    | 数据包格式 |              处理操作               |\n| :--------: | :--------: | :---------------------------------: |\n|   应用层   |   数据包   |                 无                  |\n|   传输层   |   报文段   |   加上TCP头（校验和，ack，syn等等   |\n|   网络层   |   ip报文   |  加上ip头，加入目标地址ip原地址ip   |\n| 网络接口层 |   MAC帧    | 加上mac头，下一跳mac地址，帧头 帧尾 |\n|   物理层   |  01比特流  |                                     |\n\n\n\n**下至上**\n\n|   layer    | 数据包格式 |                           处理操作                           |\n| :--------: | :--------: | :----------------------------------------------------------: |\n|   应用层   |   数据包   |                           处理数据                           |\n|   传输层   |   报文段   | 去掉TCP头，按照序号重组，验证校验和... 发送给对应应用层端口号 |\n|   网络层   |   ip报文   |                   去掉IP头尾 发送到上一层                    |\n| 网络接口层 |   MAC帧    |                 去掉mac帧 头尾，发送到上一层                 |\n|   物理层   |  01比特流  |                                                              |\n\n\n\n\n\n### 输入url点击回车，发送了什么？\n\n#### HTTP (Hypertext Transfer Protocol)\n\n首先要做解析 URL，从而生成发送给web服务器的请求信息\n\nhttp://web-server/dir/file.html\n\n| 协议名字 | 分隔符 | 服务器名字 | 目录名 | ...  | 文件名    |\n| -------- | ------ | ---------- | ------ | ---- | --------- |\n| http     | //     | web-server | dir    |      | file.html |\n| https    |        |            |        |      |           |\n\n\n\nWeb-server : /-  <font color = \"blue\">根目录</font>\n\n​\t\t\t|-dir1\n\n​\t\t\t|-dir2\n\n​\t\t\t|-dir3- file.html\t\n\n当没有指定文件的时候，返回的是根目录下的默认文件\n\n\n\n对url进行解析之后，浏览器确定了服务器和文件名以及对应的协议， 根据这些信息就可以生成HTTP请求消息了。\n\n\n\n#### DNS （Domain Name System） 地址解析协议\n\nweb-server 一般是一个 域名 如 www.baidu.com = www.baidu.com. ，但是网络中的地址是IP地址，如何通过域名得到IP？ -> DNS 协议\n\n在域名中，**越靠右**的位置表示其层级**越高**。\n\n域名使用. 来分隔，实际上域名最后还有一个点. 表示根域名，根域名 <mark background-color = \"yellow\"> . </mark> ，顶级域名 <mark background-color=\"red\">.com</mark> , \n\n域名的层级关系类似一颗树\n\n- 根DNS服务器 .\n- 顶级域DNS服务器 .com\n- 权威DNS服务器 Baidu.com\n\n---\n\n域名解析的工作流程\n\n1. 客户端首先发起一个DNS请求，问www.server.com的ip是什么，并且发送给本地的DNS服务器（也就是客户端TCP/IP设置中填写的DNS服务器地址，如114.114.114.114\n2. 本地域名服务器收到客户端的请求之后，如果缓存有www.server.com的记录，就直接返回，如果没有，本地DNS会去询问他的根域名服务器，根具有所有域名的IP，但并不能直接告诉，只能指路\n3. 根DNS收到本地请求之后，发现有.com ,于是回复 这个事情归小弟 .com顶级域名服务器管理，你去问他吧\n4. 本地DNS收到了根返回的  .com顶级域名服务器 地址， 于是向他询问\n5. 顶级域com服务器 回复 给 负责www.server.com区域的权威DNS地址\n6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。\n7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。\n8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。\n\n\n\n> 是否每次解析域名都要经过这么复杂的步骤？\n\n这个时候缓存就发挥作用了，如果***浏览器自身***有这个域名对应的缓存，就直接返回，没有的话就去问***操作系统的缓存***，还没有就去***hosts文件***查看，再没有才去问***DNS服务器***\n\n\n\n<font color = \"blue\"> 现在已经获得目的计算机的IP了，接下来数据包要怎么做呢？</font>\n\n#### 协议栈\n\n获得目的IP之后，就可以吧HTTP的传输工作交给操作系统的协议栈\n\n协议栈分为几个部分，分别承担不同的工作，上面负责委托下面工作，下面负责为上面提供服务\n\n> GPT: 协议栈（Protocol Stack）是指在计算机网络中，一组按照层次结构组织的网络协议的集合。这些协议按照功能和责任被分成不同的层次，每一层都负责执行特定的功能，从物理层到应用层依次排列。协议栈的每一层都建立在下一层的基础上，并为上一层提供服务。\n\n应用程序 通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP\n\n下半部分是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。\n\n此外 IP 中还包括 `ICMP` 协议和 `ARP` 协议。\n\n- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。\n- `ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。\n\n\n\nIP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作\n\n#### TCP\n\nTCP协议 可靠传输\n\n\n\n#### IP\n\n\n\n#### MAC\n\n\n\n#### 网卡\n\n\n\n#### 交换机\n\n\n\n#### 路由器\n\n\n\n\n\n## HTTP\n\n### HTTP基本概念\n\n#### HTTP是什么？\n\nHTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。\n\n##### 协议\n\nHTTP是一个用在计算机世界里的协议， 它确定了一种计算机之间<font color = \"blue\">交流与通信的规范</font>，以及相关的<font color=\"red\">各种控制和错误处理方式</font>\n\n##### 传输\n\nHTTP是一个双向协议，也就是A - B 之间的传输，数据虽然是在AB之间传输，但是运行中间有中转和接力，只需要中间人也满足HTTP协议，不打扰正常的数据传输，可以添加任意额外的东西\n\nHTTP 是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范。\n\n##### 超文本\n\nHTTP 传输的内容是「超文本」。\n\n我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。\n\n再来理解「超文本」，它就是**超越了普通文本的文本**，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。\n\nHTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。\n\n\n\n<mark background-color = \"yellow\">**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」** </mark>\n\n#### HTTP常见的状态码\n\n<font color=\"blue\">1xx</font> 提示信息，表示目前是协议处理的中间状态，还需要后续处理，实际用到的比较少\n\n\n\n<font color=\"blue\">2xx</font> 表示服务器成功处理了客户端的请求\n\n- 「**200 OK**」 最常见的成功状态码，表示一切正常，如果是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。\n- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。\n- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。\n\n<font color=\"blue\">3xx</font>  状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**\n\n- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。\n- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。\n\n301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。\n\n- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。\n\n<font color=\"blue\">4xx </font> 表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。\n\n- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。\n- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。\n- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。\n\n<font color=\"blue\">5xx </font> 表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。\n\n- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。\n- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。\n- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。\n- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。\n\n \n\n#### HTTP常见字段\n\n\n\n### HTTP1.0\n\n短连接\n\n### HTTP1.1\n\n实现了长连接\n\n优点：\n\n- 简单：` header+body `, 头部信息也是`key-value`的简单格式\n\n- 灵活和易于扩展\n\n- 应用广泛和跨平台\n\n缺点：\n\n- 无状态\n- 明文传输\n- 不安全\n\n#### 特性\n\n##### 长连接\n\n##### 管道网络传输 \n\n不是默认开启， 并且浏览器基本没有支持\n\n##### 队头堵塞\n\n\n\n##### Http1.1 断点续传\n\n1、客户端发起请求，并在请求包含Range字段：**Range：bytes=start-end**\n\n2、服务器收到请求之后，返回指定范围的数据，响应状态码为206，表示部分内容成功返回 响应字段有Content-Range: bytes 0-499/22400 返回数据的范围和接数据总的大小；\n\n3、客户端收到部分响应之后，保存到本地的临时文件中，并且继续请求\n\n4、下载完成之后，客户端将文件合并到最终的文件，从而实现整个文件的下载\n\n\n\n此外 因为服务器上的数据可能会被更改，所以需要断点续传需要判断是否发生过更改 if_modified ETag  ..\n\n\n\n#### 性能瓶颈\n\n- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；\n\n- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；\n\n- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；\n\n- 没有请求优先级控制；\n\n- 请求只能从客户端开始，服务器只能被动响应。\n\n  \n\n### HTTP2.0\n\n基于HTTPS实现，HTTP是明文传输 所以在安全上有以下三个问题：\n\n> 窃听风险：明文可以直接被其他人看到\n>\n> 篡改风险：明文容易被直接修改内容\n>\n> 冒充风险：容易被冒充服务端\n\n\n\nHTTP<font color='blue'>**S**</font>，在HTTP于TCP层之间加入了`SSL/TLS`协议，可以解决上述的风险：\n\n- 信息加密:  信息加密 无法破解 <font color='blue'>混合加密 = > 机密性 </font>\n- 校验机制：保证内容是没被修改过的  <font color='blue'>摘要算法 => 完整性</font>\n- 数字身份证书：保证和你通信的对端是server端  <font color='blue'>数字证书=> \"唯一性\"</font>\n\n\n\n#### HTTPS \n\n默认端口 ***443***\n\n消息机密性  通过混合加密的方式\n\n消息完整性  摘要算法保证消息的完整性（hash值）\n\n身份认证 数字证书CA认证\n\n##### 1、混合加密\n\n非对称加密：加密解密效率高，但是需要交换密钥，容易被截获\n\n常用的有RSA，DSA，ECC，DH\n\n对称加密：加密解密效率低，但是相对安全\n\n常用的有AES，DES，IDEA... \n\n> 私钥加密 公钥解密 -> 保证消息不会被冒充，因私钥是不可泄漏的，能解密出来合法的消息说明发送方也是合法的\n>\n> 公钥加密 私钥揭秘 -> 内容只有一个人（持有私钥）可以破译 保证消息机密\n\n结合二者的优点 =》 **混合加密**\n\n- 在通信建立阶段使用非对称加密的方法进行  `会话密钥`  交换，\n\n- 通信过程中使用对称加密的  `会话密钥`  加密明文数据进行通信\n\n\n\n##### 2、摘要算法 + 数字签名\n\n为了保证数据的完整性，需要针对内容计算一个「指纹」,然后和内容一起传输\n\n对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。\n\n\n\n那么，在计算机里会**用摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。\n\n通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**\n\n\n\n所以非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。\n\n\n\n##### 3、数字证书\n\n已经解决了完整性和机密性，但是还不够，但是这还远远不够，**还缺少身份验证的环节**，万一公钥是被伪造的呢？\n\n\n\n因此需要一个权威机构来认证服务器分发公钥的合法性，在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<font color='blue'> 数字证书 = 服务器公钥 + CA的数字签名 </font>+ 一些信息\n\n> CA 会使用自己的<font color='blue'>私钥</font>将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；\n\n\n\n##### HTTPS 如何建立连接？\n\nSSL/TLS 协议基本流程：”Secure Sockets Layer\" / \"Transport Layer Security\"\n\n- 客户端向服务器所要数字证书，验证公钥\n- 双方协商产生  `会话密钥`\n- 使用  `会话密钥`  通信\n\nTLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_rsa.html)和 [ECDHE 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_ecdhe.html)。\n\n具体的四次握手 略\n\n证书的验证过程中**还存在一个证书信任链的问题** \n\n最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？\n\n**这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题**\n\n\n\n##### HTTPS 的应用数据是如何保证完整性的？\n\nTLS 在实现上分为**握手协议**和**记录协议**两层：\n\n- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；\n- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；\n\nTLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，具体过程如下：\n\n- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。\n- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。\n- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。\n- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。\n\n记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。\n\n##### HTTPS一定安全可靠吗？\n\n理论上是可靠的，只要用户不擅自信任未知来源的网站\n\n\n\n客户端 --- 中间人 ---- 服务器\n\n解决中间人转发的问题 HTTPS双向认证，加上服务器对客户端的认证，服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。\n\n\n\n#### 特性\n\n##### 1、头部压缩\n\n压缩头部，如果同时发出多个请求，头是一样的，协议会消除重复的部分 HPAC算法\n\n\n\n##### 2、二进制格式\n\n不像HTTP1.1 是纯文本格式，采用的二进制，统称为帧，头和body 都是二进制，对计算机友好，直接解析二进制报文，增加了数据传输的效率\n\n\n\n##### 3、并发传输\n\n引入了stream概念，多个stream复用在一个TCP连接，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。\n\n<font color='blue'>解决了队头堵塞的问题</font>\n\n\n\n##### 4、服务器推送\n\nclient和server都可以建立stream <font color='blue'>客户端建立的stream必须是奇数， server必须是偶数</font>\n\n奇数steam 传输客户端向服务器请求的资源，偶数stream传输服务器主动推动的资源\n\n<font color=blue>但是如果需要频繁推送资源 就需要使用Websocket了</font>\n\n\n\n#### 缺陷\n\nHTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。\n\n\n\n也就是内核接收到的数据包如果乱序或者丢包了，那么这个数据报就会被卡在内核，直到数据全部到齐，TCP重组成功再返回给应用层，<font color='blue'>也就是HTTP2.0是由于采用的TCP协议堵塞在内核里面的！</font>\n\n### HTTP3.0\n\nHTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**\n\nUDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输\n\n\n\n#### 特性\n\n##### 1、无队头堵塞\n\nQUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。 再加上 协议更换成了UDP，内核层面的堵塞也没有了，所以没有队头堵塞\n\n##### 2、更快的连接建立\n\n对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。\n\nHTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。\n\n但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，\n\n##### 3、连接迁移\n\n基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。\n\n那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。\n\n而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。\n\n\n\n#### 缺陷\n\n有待普及\n\n### HTTP版本总结\n\n|      | http 1.0                              | http 1.1                                                     | http 2.0                                                     | http 3.0                                                    |\n| ---- | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------------- |\n| 改进 |                                       | 1、更改为长连接  2、增加了管道机制，允许请求端一次性发送多个请求3、支持断点续传4、支持先发送header而不发送body，先用header判断是否成功，再发送数据，节约带宽 | 1、基于HTTP S，安全性有保障 2、头部压缩 3、二进制格式 3、并发传输 4、服务器主动推送资源 | TCP改成了UDP QUIC协议来保证可靠传输 更快的连接建立 连接迁移 |\n| 缺陷 | 短连接，每次重复连接TCP带来的性能开销 | 1、首部不能压缩，只能压缩body，导致冗余，2、头部冗长，每次都要发送冗长的头部效率较低 3、server端只能按照请求顺序响应，会有队头堵塞问题 4、没有请求优先级控制 5、请求只能从客户端开始，服务器只能被动响应 | 通过stream的并发能力，不同的请求可以使用不同的stream ID来发送解决了队头堵塞的问题，但是只解决了HTTP的队头堵塞，TCP的“队头堵塞“还没有解决：发生丢包x则x+1之后的数据会被堵塞在内核直到包x重传 | 尚未普及                                                    |\n\nSSL/TLS  Secure Sockets Layer / Transport Layer security\n\n\n\n\n\n\n\n### HTTP缓存技术\n\n##### 为什么需要缓存？\n\n如果每次向服务器请求的响应都是一样的，那么就没必要向服务器请求响应，只需要由浏览器缓存下来，然后判断缓存是否可用，直接处理即可\n\n##### 强制缓存\n\n只要浏览器判断缓存没有过期，直接使用本地缓存，<font color='blue'>决定是否使用缓存的主动性在浏览器这边</font>\n\nHTTP响应头部使用 **Cache-Control** 相对时间   ， **Expires** 绝对时间 两个字段来实现\n\n如果同时有两个字段 ，**前者优先级高**\n\nCache-control <font color='red'>选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存</font>。具体的实现流程如下：\n\n- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；\n- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；\n- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。\n\n##### 协商缓存\n\n某些请求的响应码是304， 这就是服务器在告诉浏览器可以使用本地缓存的资源，<font color='blue'>这种服务器通知客户端可以使用本地缓存的方式-> 协商缓存</font>\n\n###### 实现方式1 **请求头中的If-Modified-Sincce + 响应头的Last-Modified**\n\n响应头的Last-Modified：标识这个响应资源的最后修改时间\n\n请求头中的If-Modified-Sincce ： \n\n- 当资源过期了，发现响应头有Last-Modified，则再次请求的时候带上Last-Modified，(If-Modified-Since = Last-Modified)\n-  服务器收到请求后发现有If-Modified-Since字段与资源的最后修改时间(Last-Modified)对比\n- 如果Last-Modified大（更新），返回最新资源 HTTP200 OK\n- 如果Last-Modified小（更旧），资源无修改，返回HTTP 304 走缓存\n\n###### 实现方式2 **请求头中的If-None+Match + 响应头的Etag**\n\n<font color='blue'>这种方法的优先级更高</font>\n\n> 因为ETag 主要能解决 Last-Modified 几个比较难以解决的问题：\n>\n> 1、在没有修改文件内容的时候，修改时间可能也会变，比如touch命令，导致客户端还是需要重新请求资源响应\n>\n> 2、有些文件实在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次\n>\n> 3、有些服务器不能精确获取文件最后的修改时间\n\n\n\n响应头部中的Etag：响应资源的唯一标识\n\n请求头部中的If-None-Match：\n\n- 当资源过期的时候，发现响应头里面有Etag，则再次发起请求的时候，就把If-None-Match的值设置为Etag的值\n- 服务器收到请求之后比对，如果资源更改返回HTTP 200 ok\n- 没有更改返回 HTTP 304\n\n##### 总结\n\n​\t协商缓存这两个字段都需要配合强制缓存中的`Cache-Control`来使用，只有未能命中强制缓存，才能发起带有协商缓存字段的请求。\n\n也即是：\n\n<font color='green'>浏览器请求->是否有缓存-> Cache-Control是否过期-> 是否有Etag ->是否有Last-Modified </font>\n\n\n\n\n\n\n\n\n\n什么是同步和异步？\n\n\n\n## 负载均衡\n\n#### 普通哈希\n\n对客户端的IP+port 进行哈希 ，然后的得到的 值 对服务器集群的数量进行取模， 也就是hash(ip+port) % num, 即可得到由哪台服务器提供服务\n\n问题：一旦要对 服务器集群进行扩容和缩容，就会出现原有的**哈希映射失效，数据需要重新分配**，在集群数量比较多的时候，这是非常繁琐麻烦的\n\n\n\n#### 一致性哈希\n\nHash(ip+port) % 2^32 对固定的数字取模，而不是对服务器集群的数量取模，\n\n两个步骤：1、 先对 集群服务器的每个节点（IP）做一次哈希，然后可以得到这个节点在**哈希环**上的位置\n\n​\t\t    2、 客户端发起请求， 进行哈希，然后在哈希环上顺时针遇到的第一个节点就是提供服务的节点\n\n\n\n问题：当需要缩容的时候，需要缩容的节点可能在哈希环上是很多客户端选择的节点，把这个服务器节点A从哈希环上去掉，就会发生 这个A顺时针往下的一个节点B突然接收到A所负责的这部分请求，从而导致B崩溃\n\n\n\n\n\n#### 虚拟节点\n\n在哈希环上引入虚拟节点， A-01，A-02，A-03， B-01，B-02，B-03，C-01，C-02，C-03，遇到虚拟节点的就会去找虚拟节点对应的真实节点， 虚拟节点在哈希环上是均匀分布的\n\n当A服务器要下线的时候，A的虚拟节点承载的请求会被均衡分配到BC的虚拟节点，也就是分给不同的服务器处理而不是一致性哈希只给一台服务器处理，这样就**分散了压力**\n\n","source":"_posts/计算机网络.md","raw":"---\ntitle: 计算机网络\n---\n\n---\ntitle: 计网\n\n\n---\n\n## 模型架构\n\n三种模型 分别是OSI TCP/IP 五层模型\n\n> 为什么要设计不同的layer？\n\n对于同一台设备的不同进程的通信，有很多方式 <font color = blue>管道，消息队列，信号，共享内存 </font>,  但是对于不同设备的进程间通信，就会使用到网络通信， 各种设备具有不同的特性，为了兼容，就协商出了一套通用的网络协议\n\n网络的分层：\n\n1. **模块化设计**：网络分层将整个网络系统分解为多个层次，每个层次都有特定的功能和责任。这种模块化设计使得网络结构更加清晰，降低了网络系统的复杂度，方便了系统的设计、开发和维护。\n2. **标准化**：每个网络层次都有相应的标准和协议，定义了该层次的功能、数据格式、传输方式等规范。这些标准和协议使得不同厂商的网络设备和软件可以互相兼容和通信，促进了网络设备的互联互通。\n3. **提高可靠性**：各层之间解耦合，由于每个层次都有明确的功能和责任，网络分层可以提高网络系统的可靠性。当一个层次出现问题时，只需修复该层次，而不会影响到其他层次，从而提高了网络系统的稳定性和可靠性。\n4. **提高性能**：网络分层可以使网络通信过程更加高效。每个层次只需关注自己的功能和责任，而不需要关心其他层次的具体实现细节，从而提高了网络通信的效率。\n5. **降低成本**：网络分层可以将网络系统分解为多个相对独立的模块，降低了系统设计、开发和维护的成本。此外，通过使用标准化的协议和技术，可以降低网络设备和软件的开发成本，提高了网络系统的经济效益。\n\n### TCP/IP 网络模型\n\n#### 应用层\n\n进程需要通信时，就把数据传给下一层，应用层只需要关注为用户提供功能，如HTPTP，FTP，Telnet，DNS, SMTP;\n\n应用层不关心怎么传输，只负责把数据给传输层\n\n工作在用户态\n\n\n\n#### 传输层\n\n应用层的数据包会给传输层，传输层负责给应用层提供服务\n\n##### 两个协议TCP和UDP\n\nTransmission Control Protocol, 大部分应用使用的都是传输控制协议TCP，如HTTP，TCP面向连接，多了很多特性，保证可靠的交付，UDP不保证可靠交付，但是传输效率较高\n\n> 要实现可靠的UDP也可以，只需要在UDP上把TCP的特性实现一遍就行了，拥塞控制，流量控制，超时重传...\n\n\n\n要传输的数据可能很大，直接传不太方便，所以需要对数据包进行分块，TCP传输的数据是报文段，传输的数据大小超过了MSS（TCP最大报文段长度），就需要对数据包分块，这样即使有一个包丢失了，只需要重传丢失的即可。\n\n\n\n传输层在接收方需要干的事情就是 负责处理下层送上的数据，去掉之前加上的头部，顺序重组，校验和... 然后上传给应用层\n\n> 如何区分是哪个应用呢？端口号\n>\n> 80 web服务器使用的端口号，22 ssh服务使用的端口号...\n\n\n\n#### 网络层\n\n传输层只负责传输过程的一些预处理，但实际上并不负责传输\n\n实际上的网络环境十分复杂，有非常多的节点和设备，需要进行路径和节点的选择，这部分交给传输层做就有点冗余了，因此把这一部分分出来给网络层做，进一步解耦。\n\n网络层最常使用的就是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP头部组成IP报文，如果IP报文超过了MTU（1500 bytes normally），就再次分段，得到一个IP报文段。\n\n\n\n> 网络层负责将数据传输到另外一个设备，世界上这么多设备，如何找到对方呢？网络层需要有 区分不同设备的编号 -> <mark background-color=\"yellow\">IP</mark>\n\n\n\n网络号 主机号 子网掩码\n\n在寻址过程中，先找到对应的网络号（先找到学校），再去找主机号（在找对应的人）\n\n除了寻址，网络层还有一件事情就是路由，数据传输过程中，并不是一条网线走到黑，而是需要经过一系列的节点（交换机，路由器，转发），所以网络层需要通过路由算法来决定下一步走哪个节点\n\nIP协议告诉你要去哪里，路由告诉你下一跳该去哪，一个是大局，一个是细节\n\n\n\n#### 网络接口层\n\n加上了IP头部之后，交给网络接口层，在头部再加上MAC头部，封装成一个数据帧发送到网络上\n\n\n\nIP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们就可以知道这个包要去哪，但是在以太网的世界中，是行不通的，\n\n以太网是一种在局域网内将附近的设备连接起来进行通信的技术。以太网在区分设备的时候是通过MAC地址判断的，MAC就是设备网卡的硬件地址，出厂时唯一设定，\n\n\n\nMAC头部是以太网使用的头部，包含接收方和发送方的MAC地址信息，可以通过ARP协议获取MAC地址，\n\n\n\n网络接口层为网络提供 **链路级别** 传输的服务，负责在以太网，WIFI这样的底层网络上发送数据包，工作在网卡这个层次，使用MAC地址来标识网络设备\n\n| 层级        | 地址类型 | 功能                       |\n| ----------- | -------- | -------------------------- |\n| 网络层 (IP) | IP地址   | 在网络中唯一标识设备       |\n| 数据链路层  | MAC地址  | 在同一局域网内唯一标识设备 |\n\n\n\n\n\n#### 总结\n\n**上至下**\n\n|   layer    | 数据包格式 |              处理操作               |\n| :--------: | :--------: | :---------------------------------: |\n|   应用层   |   数据包   |                 无                  |\n|   传输层   |   报文段   |   加上TCP头（校验和，ack，syn等等   |\n|   网络层   |   ip报文   |  加上ip头，加入目标地址ip原地址ip   |\n| 网络接口层 |   MAC帧    | 加上mac头，下一跳mac地址，帧头 帧尾 |\n|   物理层   |  01比特流  |                                     |\n\n\n\n**下至上**\n\n|   layer    | 数据包格式 |                           处理操作                           |\n| :--------: | :--------: | :----------------------------------------------------------: |\n|   应用层   |   数据包   |                           处理数据                           |\n|   传输层   |   报文段   | 去掉TCP头，按照序号重组，验证校验和... 发送给对应应用层端口号 |\n|   网络层   |   ip报文   |                   去掉IP头尾 发送到上一层                    |\n| 网络接口层 |   MAC帧    |                 去掉mac帧 头尾，发送到上一层                 |\n|   物理层   |  01比特流  |                                                              |\n\n\n\n\n\n### 输入url点击回车，发送了什么？\n\n#### HTTP (Hypertext Transfer Protocol)\n\n首先要做解析 URL，从而生成发送给web服务器的请求信息\n\nhttp://web-server/dir/file.html\n\n| 协议名字 | 分隔符 | 服务器名字 | 目录名 | ...  | 文件名    |\n| -------- | ------ | ---------- | ------ | ---- | --------- |\n| http     | //     | web-server | dir    |      | file.html |\n| https    |        |            |        |      |           |\n\n\n\nWeb-server : /-  <font color = \"blue\">根目录</font>\n\n​\t\t\t|-dir1\n\n​\t\t\t|-dir2\n\n​\t\t\t|-dir3- file.html\t\n\n当没有指定文件的时候，返回的是根目录下的默认文件\n\n\n\n对url进行解析之后，浏览器确定了服务器和文件名以及对应的协议， 根据这些信息就可以生成HTTP请求消息了。\n\n\n\n#### DNS （Domain Name System） 地址解析协议\n\nweb-server 一般是一个 域名 如 www.baidu.com = www.baidu.com. ，但是网络中的地址是IP地址，如何通过域名得到IP？ -> DNS 协议\n\n在域名中，**越靠右**的位置表示其层级**越高**。\n\n域名使用. 来分隔，实际上域名最后还有一个点. 表示根域名，根域名 <mark background-color = \"yellow\"> . </mark> ，顶级域名 <mark background-color=\"red\">.com</mark> , \n\n域名的层级关系类似一颗树\n\n- 根DNS服务器 .\n- 顶级域DNS服务器 .com\n- 权威DNS服务器 Baidu.com\n\n---\n\n域名解析的工作流程\n\n1. 客户端首先发起一个DNS请求，问www.server.com的ip是什么，并且发送给本地的DNS服务器（也就是客户端TCP/IP设置中填写的DNS服务器地址，如114.114.114.114\n2. 本地域名服务器收到客户端的请求之后，如果缓存有www.server.com的记录，就直接返回，如果没有，本地DNS会去询问他的根域名服务器，根具有所有域名的IP，但并不能直接告诉，只能指路\n3. 根DNS收到本地请求之后，发现有.com ,于是回复 这个事情归小弟 .com顶级域名服务器管理，你去问他吧\n4. 本地DNS收到了根返回的  .com顶级域名服务器 地址， 于是向他询问\n5. 顶级域com服务器 回复 给 负责www.server.com区域的权威DNS地址\n6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。\n7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。\n8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。\n\n\n\n> 是否每次解析域名都要经过这么复杂的步骤？\n\n这个时候缓存就发挥作用了，如果***浏览器自身***有这个域名对应的缓存，就直接返回，没有的话就去问***操作系统的缓存***，还没有就去***hosts文件***查看，再没有才去问***DNS服务器***\n\n\n\n<font color = \"blue\"> 现在已经获得目的计算机的IP了，接下来数据包要怎么做呢？</font>\n\n#### 协议栈\n\n获得目的IP之后，就可以吧HTTP的传输工作交给操作系统的协议栈\n\n协议栈分为几个部分，分别承担不同的工作，上面负责委托下面工作，下面负责为上面提供服务\n\n> GPT: 协议栈（Protocol Stack）是指在计算机网络中，一组按照层次结构组织的网络协议的集合。这些协议按照功能和责任被分成不同的层次，每一层都负责执行特定的功能，从物理层到应用层依次排列。协议栈的每一层都建立在下一层的基础上，并为上一层提供服务。\n\n应用程序 通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP\n\n下半部分是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。\n\n此外 IP 中还包括 `ICMP` 协议和 `ARP` 协议。\n\n- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。\n- `ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。\n\n\n\nIP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作\n\n#### TCP\n\nTCP协议 可靠传输\n\n\n\n#### IP\n\n\n\n#### MAC\n\n\n\n#### 网卡\n\n\n\n#### 交换机\n\n\n\n#### 路由器\n\n\n\n\n\n## HTTP\n\n### HTTP基本概念\n\n#### HTTP是什么？\n\nHTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。\n\n##### 协议\n\nHTTP是一个用在计算机世界里的协议， 它确定了一种计算机之间<font color = \"blue\">交流与通信的规范</font>，以及相关的<font color=\"red\">各种控制和错误处理方式</font>\n\n##### 传输\n\nHTTP是一个双向协议，也就是A - B 之间的传输，数据虽然是在AB之间传输，但是运行中间有中转和接力，只需要中间人也满足HTTP协议，不打扰正常的数据传输，可以添加任意额外的东西\n\nHTTP 是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范。\n\n##### 超文本\n\nHTTP 传输的内容是「超文本」。\n\n我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。\n\n再来理解「超文本」，它就是**超越了普通文本的文本**，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。\n\nHTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。\n\n\n\n<mark background-color = \"yellow\">**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」** </mark>\n\n#### HTTP常见的状态码\n\n<font color=\"blue\">1xx</font> 提示信息，表示目前是协议处理的中间状态，还需要后续处理，实际用到的比较少\n\n\n\n<font color=\"blue\">2xx</font> 表示服务器成功处理了客户端的请求\n\n- 「**200 OK**」 最常见的成功状态码，表示一切正常，如果是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。\n- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。\n- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。\n\n<font color=\"blue\">3xx</font>  状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**\n\n- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。\n- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。\n\n301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。\n\n- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。\n\n<font color=\"blue\">4xx </font> 表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。\n\n- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。\n- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。\n- 「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。\n\n<font color=\"blue\">5xx </font> 表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。\n\n- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。\n- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。\n- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。\n- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。\n\n \n\n#### HTTP常见字段\n\n\n\n### HTTP1.0\n\n短连接\n\n### HTTP1.1\n\n实现了长连接\n\n优点：\n\n- 简单：` header+body `, 头部信息也是`key-value`的简单格式\n\n- 灵活和易于扩展\n\n- 应用广泛和跨平台\n\n缺点：\n\n- 无状态\n- 明文传输\n- 不安全\n\n#### 特性\n\n##### 长连接\n\n##### 管道网络传输 \n\n不是默认开启， 并且浏览器基本没有支持\n\n##### 队头堵塞\n\n\n\n##### Http1.1 断点续传\n\n1、客户端发起请求，并在请求包含Range字段：**Range：bytes=start-end**\n\n2、服务器收到请求之后，返回指定范围的数据，响应状态码为206，表示部分内容成功返回 响应字段有Content-Range: bytes 0-499/22400 返回数据的范围和接数据总的大小；\n\n3、客户端收到部分响应之后，保存到本地的临时文件中，并且继续请求\n\n4、下载完成之后，客户端将文件合并到最终的文件，从而实现整个文件的下载\n\n\n\n此外 因为服务器上的数据可能会被更改，所以需要断点续传需要判断是否发生过更改 if_modified ETag  ..\n\n\n\n#### 性能瓶颈\n\n- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；\n\n- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；\n\n- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；\n\n- 没有请求优先级控制；\n\n- 请求只能从客户端开始，服务器只能被动响应。\n\n  \n\n### HTTP2.0\n\n基于HTTPS实现，HTTP是明文传输 所以在安全上有以下三个问题：\n\n> 窃听风险：明文可以直接被其他人看到\n>\n> 篡改风险：明文容易被直接修改内容\n>\n> 冒充风险：容易被冒充服务端\n\n\n\nHTTP<font color='blue'>**S**</font>，在HTTP于TCP层之间加入了`SSL/TLS`协议，可以解决上述的风险：\n\n- 信息加密:  信息加密 无法破解 <font color='blue'>混合加密 = > 机密性 </font>\n- 校验机制：保证内容是没被修改过的  <font color='blue'>摘要算法 => 完整性</font>\n- 数字身份证书：保证和你通信的对端是server端  <font color='blue'>数字证书=> \"唯一性\"</font>\n\n\n\n#### HTTPS \n\n默认端口 ***443***\n\n消息机密性  通过混合加密的方式\n\n消息完整性  摘要算法保证消息的完整性（hash值）\n\n身份认证 数字证书CA认证\n\n##### 1、混合加密\n\n非对称加密：加密解密效率高，但是需要交换密钥，容易被截获\n\n常用的有RSA，DSA，ECC，DH\n\n对称加密：加密解密效率低，但是相对安全\n\n常用的有AES，DES，IDEA... \n\n> 私钥加密 公钥解密 -> 保证消息不会被冒充，因私钥是不可泄漏的，能解密出来合法的消息说明发送方也是合法的\n>\n> 公钥加密 私钥揭秘 -> 内容只有一个人（持有私钥）可以破译 保证消息机密\n\n结合二者的优点 =》 **混合加密**\n\n- 在通信建立阶段使用非对称加密的方法进行  `会话密钥`  交换，\n\n- 通信过程中使用对称加密的  `会话密钥`  加密明文数据进行通信\n\n\n\n##### 2、摘要算法 + 数字签名\n\n为了保证数据的完整性，需要针对内容计算一个「指纹」,然后和内容一起传输\n\n对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。\n\n\n\n那么，在计算机里会**用摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。\n\n通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**\n\n\n\n所以非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。\n\n\n\n##### 3、数字证书\n\n已经解决了完整性和机密性，但是还不够，但是这还远远不够，**还缺少身份验证的环节**，万一公钥是被伪造的呢？\n\n\n\n因此需要一个权威机构来认证服务器分发公钥的合法性，在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<font color='blue'> 数字证书 = 服务器公钥 + CA的数字签名 </font>+ 一些信息\n\n> CA 会使用自己的<font color='blue'>私钥</font>将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；\n\n\n\n##### HTTPS 如何建立连接？\n\nSSL/TLS 协议基本流程：”Secure Sockets Layer\" / \"Transport Layer Security\"\n\n- 客户端向服务器所要数字证书，验证公钥\n- 双方协商产生  `会话密钥`\n- 使用  `会话密钥`  通信\n\nTLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_rsa.html)和 [ECDHE 算法 (opens new window)](https://xiaolincoding.com/network/2_http/https_ecdhe.html)。\n\n具体的四次握手 略\n\n证书的验证过程中**还存在一个证书信任链的问题** \n\n最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？\n\n**这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题**\n\n\n\n##### HTTPS 的应用数据是如何保证完整性的？\n\nTLS 在实现上分为**握手协议**和**记录协议**两层：\n\n- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；\n- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；\n\nTLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，具体过程如下：\n\n- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。\n- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。\n- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。\n- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。\n\n记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。\n\n##### HTTPS一定安全可靠吗？\n\n理论上是可靠的，只要用户不擅自信任未知来源的网站\n\n\n\n客户端 --- 中间人 ---- 服务器\n\n解决中间人转发的问题 HTTPS双向认证，加上服务器对客户端的认证，服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。\n\n\n\n#### 特性\n\n##### 1、头部压缩\n\n压缩头部，如果同时发出多个请求，头是一样的，协议会消除重复的部分 HPAC算法\n\n\n\n##### 2、二进制格式\n\n不像HTTP1.1 是纯文本格式，采用的二进制，统称为帧，头和body 都是二进制，对计算机友好，直接解析二进制报文，增加了数据传输的效率\n\n\n\n##### 3、并发传输\n\n引入了stream概念，多个stream复用在一个TCP连接，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。\n\n<font color='blue'>解决了队头堵塞的问题</font>\n\n\n\n##### 4、服务器推送\n\nclient和server都可以建立stream <font color='blue'>客户端建立的stream必须是奇数， server必须是偶数</font>\n\n奇数steam 传输客户端向服务器请求的资源，偶数stream传输服务器主动推动的资源\n\n<font color=blue>但是如果需要频繁推送资源 就需要使用Websocket了</font>\n\n\n\n#### 缺陷\n\nHTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。\n\n\n\n也就是内核接收到的数据包如果乱序或者丢包了，那么这个数据报就会被卡在内核，直到数据全部到齐，TCP重组成功再返回给应用层，<font color='blue'>也就是HTTP2.0是由于采用的TCP协议堵塞在内核里面的！</font>\n\n### HTTP3.0\n\nHTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**\n\nUDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输\n\n\n\n#### 特性\n\n##### 1、无队头堵塞\n\nQUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。 再加上 协议更换成了UDP，内核层面的堵塞也没有了，所以没有队头堵塞\n\n##### 2、更快的连接建立\n\n对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。\n\nHTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。\n\n但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，\n\n##### 3、连接迁移\n\n基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。\n\n那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。\n\n而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。\n\n\n\n#### 缺陷\n\n有待普及\n\n### HTTP版本总结\n\n|      | http 1.0                              | http 1.1                                                     | http 2.0                                                     | http 3.0                                                    |\n| ---- | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------------- |\n| 改进 |                                       | 1、更改为长连接  2、增加了管道机制，允许请求端一次性发送多个请求3、支持断点续传4、支持先发送header而不发送body，先用header判断是否成功，再发送数据，节约带宽 | 1、基于HTTP S，安全性有保障 2、头部压缩 3、二进制格式 3、并发传输 4、服务器主动推送资源 | TCP改成了UDP QUIC协议来保证可靠传输 更快的连接建立 连接迁移 |\n| 缺陷 | 短连接，每次重复连接TCP带来的性能开销 | 1、首部不能压缩，只能压缩body，导致冗余，2、头部冗长，每次都要发送冗长的头部效率较低 3、server端只能按照请求顺序响应，会有队头堵塞问题 4、没有请求优先级控制 5、请求只能从客户端开始，服务器只能被动响应 | 通过stream的并发能力，不同的请求可以使用不同的stream ID来发送解决了队头堵塞的问题，但是只解决了HTTP的队头堵塞，TCP的“队头堵塞“还没有解决：发生丢包x则x+1之后的数据会被堵塞在内核直到包x重传 | 尚未普及                                                    |\n\nSSL/TLS  Secure Sockets Layer / Transport Layer security\n\n\n\n\n\n\n\n### HTTP缓存技术\n\n##### 为什么需要缓存？\n\n如果每次向服务器请求的响应都是一样的，那么就没必要向服务器请求响应，只需要由浏览器缓存下来，然后判断缓存是否可用，直接处理即可\n\n##### 强制缓存\n\n只要浏览器判断缓存没有过期，直接使用本地缓存，<font color='blue'>决定是否使用缓存的主动性在浏览器这边</font>\n\nHTTP响应头部使用 **Cache-Control** 相对时间   ， **Expires** 绝对时间 两个字段来实现\n\n如果同时有两个字段 ，**前者优先级高**\n\nCache-control <font color='red'>选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存</font>。具体的实现流程如下：\n\n- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；\n- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；\n- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。\n\n##### 协商缓存\n\n某些请求的响应码是304， 这就是服务器在告诉浏览器可以使用本地缓存的资源，<font color='blue'>这种服务器通知客户端可以使用本地缓存的方式-> 协商缓存</font>\n\n###### 实现方式1 **请求头中的If-Modified-Sincce + 响应头的Last-Modified**\n\n响应头的Last-Modified：标识这个响应资源的最后修改时间\n\n请求头中的If-Modified-Sincce ： \n\n- 当资源过期了，发现响应头有Last-Modified，则再次请求的时候带上Last-Modified，(If-Modified-Since = Last-Modified)\n-  服务器收到请求后发现有If-Modified-Since字段与资源的最后修改时间(Last-Modified)对比\n- 如果Last-Modified大（更新），返回最新资源 HTTP200 OK\n- 如果Last-Modified小（更旧），资源无修改，返回HTTP 304 走缓存\n\n###### 实现方式2 **请求头中的If-None+Match + 响应头的Etag**\n\n<font color='blue'>这种方法的优先级更高</font>\n\n> 因为ETag 主要能解决 Last-Modified 几个比较难以解决的问题：\n>\n> 1、在没有修改文件内容的时候，修改时间可能也会变，比如touch命令，导致客户端还是需要重新请求资源响应\n>\n> 2、有些文件实在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次\n>\n> 3、有些服务器不能精确获取文件最后的修改时间\n\n\n\n响应头部中的Etag：响应资源的唯一标识\n\n请求头部中的If-None-Match：\n\n- 当资源过期的时候，发现响应头里面有Etag，则再次发起请求的时候，就把If-None-Match的值设置为Etag的值\n- 服务器收到请求之后比对，如果资源更改返回HTTP 200 ok\n- 没有更改返回 HTTP 304\n\n##### 总结\n\n​\t协商缓存这两个字段都需要配合强制缓存中的`Cache-Control`来使用，只有未能命中强制缓存，才能发起带有协商缓存字段的请求。\n\n也即是：\n\n<font color='green'>浏览器请求->是否有缓存-> Cache-Control是否过期-> 是否有Etag ->是否有Last-Modified </font>\n\n\n\n\n\n\n\n\n\n什么是同步和异步？\n\n\n\n## 负载均衡\n\n#### 普通哈希\n\n对客户端的IP+port 进行哈希 ，然后的得到的 值 对服务器集群的数量进行取模， 也就是hash(ip+port) % num, 即可得到由哪台服务器提供服务\n\n问题：一旦要对 服务器集群进行扩容和缩容，就会出现原有的**哈希映射失效，数据需要重新分配**，在集群数量比较多的时候，这是非常繁琐麻烦的\n\n\n\n#### 一致性哈希\n\nHash(ip+port) % 2^32 对固定的数字取模，而不是对服务器集群的数量取模，\n\n两个步骤：1、 先对 集群服务器的每个节点（IP）做一次哈希，然后可以得到这个节点在**哈希环**上的位置\n\n​\t\t    2、 客户端发起请求， 进行哈希，然后在哈希环上顺时针遇到的第一个节点就是提供服务的节点\n\n\n\n问题：当需要缩容的时候，需要缩容的节点可能在哈希环上是很多客户端选择的节点，把这个服务器节点A从哈希环上去掉，就会发生 这个A顺时针往下的一个节点B突然接收到A所负责的这部分请求，从而导致B崩溃\n\n\n\n\n\n#### 虚拟节点\n\n在哈希环上引入虚拟节点， A-01，A-02，A-03， B-01，B-02，B-03，C-01，C-02，C-03，遇到虚拟节点的就会去找虚拟节点对应的真实节点， 虚拟节点在哈希环上是均匀分布的\n\n当A服务器要下线的时候，A的虚拟节点承载的请求会被均衡分配到BC的虚拟节点，也就是分给不同的服务器处理而不是一致性哈希只给一台服务器处理，这样就**分散了压力**\n\n","slug":"计算机网络","published":1,"date":"2024-04-12T12:46:09.868Z","updated":"2024-05-21T08:23:45.665Z","_id":"cluwq56wc00060cvk0046f2ku","comments":1,"layout":"post","photos":[],"content":"<hr>\n<p>title: 计网</p>\n<hr>\n<h2 id=\"模型架构\"><a href=\"#模型架构\" class=\"headerlink\" title=\"模型架构\"></a>模型架构</h2><p>三种模型 分别是OSI TCP&#x2F;IP 五层模型</p>\n<blockquote>\n<p>为什么要设计不同的layer？</p>\n</blockquote>\n<p>对于同一台设备的不同进程的通信，有很多方式 <font color = blue>管道，消息队列，信号，共享内存 </font>,  但是对于不同设备的进程间通信，就会使用到网络通信， 各种设备具有不同的特性，为了兼容，就协商出了一套通用的网络协议</p>\n<p>网络的分层：</p>\n<ol>\n<li><strong>模块化设计</strong>：网络分层将整个网络系统分解为多个层次，每个层次都有特定的功能和责任。这种模块化设计使得网络结构更加清晰，降低了网络系统的复杂度，方便了系统的设计、开发和维护。</li>\n<li><strong>标准化</strong>：每个网络层次都有相应的标准和协议，定义了该层次的功能、数据格式、传输方式等规范。这些标准和协议使得不同厂商的网络设备和软件可以互相兼容和通信，促进了网络设备的互联互通。</li>\n<li><strong>提高可靠性</strong>：各层之间解耦合，由于每个层次都有明确的功能和责任，网络分层可以提高网络系统的可靠性。当一个层次出现问题时，只需修复该层次，而不会影响到其他层次，从而提高了网络系统的稳定性和可靠性。</li>\n<li><strong>提高性能</strong>：网络分层可以使网络通信过程更加高效。每个层次只需关注自己的功能和责任，而不需要关心其他层次的具体实现细节，从而提高了网络通信的效率。</li>\n<li><strong>降低成本</strong>：网络分层可以将网络系统分解为多个相对独立的模块，降低了系统设计、开发和维护的成本。此外，通过使用标准化的协议和技术，可以降低网络设备和软件的开发成本，提高了网络系统的经济效益。</li>\n</ol>\n<h3 id=\"TCP-IP-网络模型\"><a href=\"#TCP-IP-网络模型\" class=\"headerlink\" title=\"TCP&#x2F;IP 网络模型\"></a>TCP&#x2F;IP 网络模型</h3><h4 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h4><p>进程需要通信时，就把数据传给下一层，应用层只需要关注为用户提供功能，如HTPTP，FTP，Telnet，DNS, SMTP;</p>\n<p>应用层不关心怎么传输，只负责把数据给传输层</p>\n<p>工作在用户态</p>\n<h4 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h4><p>应用层的数据包会给传输层，传输层负责给应用层提供服务</p>\n<h5 id=\"两个协议TCP和UDP\"><a href=\"#两个协议TCP和UDP\" class=\"headerlink\" title=\"两个协议TCP和UDP\"></a>两个协议TCP和UDP</h5><p>Transmission Control Protocol, 大部分应用使用的都是传输控制协议TCP，如HTTP，TCP面向连接，多了很多特性，保证可靠的交付，UDP不保证可靠交付，但是传输效率较高</p>\n<blockquote>\n<p>要实现可靠的UDP也可以，只需要在UDP上把TCP的特性实现一遍就行了，拥塞控制，流量控制，超时重传…</p>\n</blockquote>\n<p>要传输的数据可能很大，直接传不太方便，所以需要对数据包进行分块，TCP传输的数据是报文段，传输的数据大小超过了MSS（TCP最大报文段长度），就需要对数据包分块，这样即使有一个包丢失了，只需要重传丢失的即可。</p>\n<p>传输层在接收方需要干的事情就是 负责处理下层送上的数据，去掉之前加上的头部，顺序重组，校验和… 然后上传给应用层</p>\n<blockquote>\n<p>如何区分是哪个应用呢？端口号</p>\n<p>80 web服务器使用的端口号，22 ssh服务使用的端口号…</p>\n</blockquote>\n<h4 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h4><p>传输层只负责传输过程的一些预处理，但实际上并不负责传输</p>\n<p>实际上的网络环境十分复杂，有非常多的节点和设备，需要进行路径和节点的选择，这部分交给传输层做就有点冗余了，因此把这一部分分出来给网络层做，进一步解耦。</p>\n<p>网络层最常使用的就是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP头部组成IP报文，如果IP报文超过了MTU（1500 bytes normally），就再次分段，得到一个IP报文段。</p>\n<blockquote>\n<p>网络层负责将数据传输到另外一个设备，世界上这么多设备，如何找到对方呢？网络层需要有 区分不同设备的编号 -&gt; <mark background-color=\"yellow\">IP</mark></p>\n</blockquote>\n<p>网络号 主机号 子网掩码</p>\n<p>在寻址过程中，先找到对应的网络号（先找到学校），再去找主机号（在找对应的人）</p>\n<p>除了寻址，网络层还有一件事情就是路由，数据传输过程中，并不是一条网线走到黑，而是需要经过一系列的节点（交换机，路由器，转发），所以网络层需要通过路由算法来决定下一步走哪个节点</p>\n<p>IP协议告诉你要去哪里，路由告诉你下一跳该去哪，一个是大局，一个是细节</p>\n<h4 id=\"网络接口层\"><a href=\"#网络接口层\" class=\"headerlink\" title=\"网络接口层\"></a>网络接口层</h4><p>加上了IP头部之后，交给网络接口层，在头部再加上MAC头部，封装成一个数据帧发送到网络上</p>\n<p>IP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们就可以知道这个包要去哪，但是在以太网的世界中，是行不通的，</p>\n<p>以太网是一种在局域网内将附近的设备连接起来进行通信的技术。以太网在区分设备的时候是通过MAC地址判断的，MAC就是设备网卡的硬件地址，出厂时唯一设定，</p>\n<p>MAC头部是以太网使用的头部，包含接收方和发送方的MAC地址信息，可以通过ARP协议获取MAC地址，</p>\n<p>网络接口层为网络提供 <strong>链路级别</strong> 传输的服务，负责在以太网，WIFI这样的底层网络上发送数据包，工作在网卡这个层次，使用MAC地址来标识网络设备</p>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>地址类型</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网络层 (IP)</td>\n<td>IP地址</td>\n<td>在网络中唯一标识设备</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>MAC地址</td>\n<td>在同一局域网内唯一标识设备</td>\n</tr>\n</tbody></table>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><strong>上至下</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">layer</th>\n<th align=\"center\">数据包格式</th>\n<th align=\"center\">处理操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">应用层</td>\n<td align=\"center\">数据包</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">传输层</td>\n<td align=\"center\">报文段</td>\n<td align=\"center\">加上TCP头（校验和，ack，syn等等</td>\n</tr>\n<tr>\n<td align=\"center\">网络层</td>\n<td align=\"center\">ip报文</td>\n<td align=\"center\">加上ip头，加入目标地址ip原地址ip</td>\n</tr>\n<tr>\n<td align=\"center\">网络接口层</td>\n<td align=\"center\">MAC帧</td>\n<td align=\"center\">加上mac头，下一跳mac地址，帧头 帧尾</td>\n</tr>\n<tr>\n<td align=\"center\">物理层</td>\n<td align=\"center\">01比特流</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>下至上</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">layer</th>\n<th align=\"center\">数据包格式</th>\n<th align=\"center\">处理操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">应用层</td>\n<td align=\"center\">数据包</td>\n<td align=\"center\">处理数据</td>\n</tr>\n<tr>\n<td align=\"center\">传输层</td>\n<td align=\"center\">报文段</td>\n<td align=\"center\">去掉TCP头，按照序号重组，验证校验和… 发送给对应应用层端口号</td>\n</tr>\n<tr>\n<td align=\"center\">网络层</td>\n<td align=\"center\">ip报文</td>\n<td align=\"center\">去掉IP头尾 发送到上一层</td>\n</tr>\n<tr>\n<td align=\"center\">网络接口层</td>\n<td align=\"center\">MAC帧</td>\n<td align=\"center\">去掉mac帧 头尾，发送到上一层</td>\n</tr>\n<tr>\n<td align=\"center\">物理层</td>\n<td align=\"center\">01比特流</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"输入url点击回车，发送了什么？\"><a href=\"#输入url点击回车，发送了什么？\" class=\"headerlink\" title=\"输入url点击回车，发送了什么？\"></a>输入url点击回车，发送了什么？</h3><h4 id=\"HTTP-Hypertext-Transfer-Protocol\"><a href=\"#HTTP-Hypertext-Transfer-Protocol\" class=\"headerlink\" title=\"HTTP (Hypertext Transfer Protocol)\"></a>HTTP (Hypertext Transfer Protocol)</h4><p>首先要做解析 URL，从而生成发送给web服务器的请求信息</p>\n<p><a href=\"http://web-server/dir/file.html\">http://web-server/dir/file.html</a></p>\n<table>\n<thead>\n<tr>\n<th>协议名字</th>\n<th>分隔符</th>\n<th>服务器名字</th>\n<th>目录名</th>\n<th>…</th>\n<th>文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>http</td>\n<td>&#x2F;&#x2F;</td>\n<td>web-server</td>\n<td>dir</td>\n<td></td>\n<td>file.html</td>\n</tr>\n<tr>\n<td>https</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>Web-server : &#x2F;-  <font color = \"blue\">根目录</font></p>\n<p>​\t\t\t|-dir1</p>\n<p>​\t\t\t|-dir2</p>\n<p>​\t\t\t|-dir3- file.html\t</p>\n<p>当没有指定文件的时候，返回的是根目录下的默认文件</p>\n<p>对url进行解析之后，浏览器确定了服务器和文件名以及对应的协议， 根据这些信息就可以生成HTTP请求消息了。</p>\n<h4 id=\"DNS-（Domain-Name-System）-地址解析协议\"><a href=\"#DNS-（Domain-Name-System）-地址解析协议\" class=\"headerlink\" title=\"DNS （Domain Name System） 地址解析协议\"></a>DNS （Domain Name System） 地址解析协议</h4><p>web-server 一般是一个 域名 如 <a href=\"http://www.baidu.com/\">www.baidu.com</a> &#x3D; <a href=\"http://www.baidu.com/\">www.baidu.com</a>. ，但是网络中的地址是IP地址，如何通过域名得到IP？ -&gt; DNS 协议</p>\n<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>\n<p>域名使用. 来分隔，实际上域名最后还有一个点. 表示根域名，根域名 <mark background-color = \"yellow\"> . </mark> ，顶级域名 <mark background-color=\"red\">.com</mark> , </p>\n<p>域名的层级关系类似一颗树</p>\n<ul>\n<li>根DNS服务器 .</li>\n<li>顶级域DNS服务器 .com</li>\n<li>权威DNS服务器 Baidu.com</li>\n</ul>\n<hr>\n<p>域名解析的工作流程</p>\n<ol>\n<li>客户端首先发起一个DNS请求，问<a href=\"http://www.server.com的ip是什么,并且发送给本地的dns服务器(也就是客户端tcp/IP%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%A1%AB%E5%86%99%E7%9A%84DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%A6%82114.114.114.114\">www.server.com的ip是什么，并且发送给本地的DNS服务器（也就是客户端TCP/IP设置中填写的DNS服务器地址，如114.114.114.114</a></li>\n<li>本地域名服务器收到客户端的请求之后，如果缓存有<a href=\"http://www.server.com的记录,就直接返回,如果没有,本地dns会去询问他的根域名服务器,根具有所有域名的ip,但并不能直接告诉,只能指路/\">www.server.com的记录，就直接返回，如果没有，本地DNS会去询问他的根域名服务器，根具有所有域名的IP，但并不能直接告诉，只能指路</a></li>\n<li>根DNS收到本地请求之后，发现有.com ,于是回复 这个事情归小弟 .com顶级域名服务器管理，你去问他吧</li>\n<li>本地DNS收到了根返回的  .com顶级域名服务器 地址， 于是向他询问</li>\n<li>顶级域com服务器 回复 给 负责<a href=\"http://www.server.com区域的权威dns地址/\">www.server.com区域的权威DNS地址</a></li>\n<li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href=\"http://www.server.com对应的IP是啥呀？”\">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>\n<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>\n<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>\n</ol>\n<blockquote>\n<p>是否每次解析域名都要经过这么复杂的步骤？</p>\n</blockquote>\n<p>这个时候缓存就发挥作用了，如果<em><strong>浏览器自身</strong></em>有这个域名对应的缓存，就直接返回，没有的话就去问<em><strong>操作系统的缓存</strong></em>，还没有就去<em><strong>hosts文件</strong></em>查看，再没有才去问<em><strong>DNS服务器</strong></em></p>\n<p><font color = \"blue\"> 现在已经获得目的计算机的IP了，接下来数据包要怎么做呢？</font></p>\n<h4 id=\"协议栈\"><a href=\"#协议栈\" class=\"headerlink\" title=\"协议栈\"></a>协议栈</h4><p>获得目的IP之后，就可以吧HTTP的传输工作交给操作系统的协议栈</p>\n<p>协议栈分为几个部分，分别承担不同的工作，上面负责委托下面工作，下面负责为上面提供服务</p>\n<blockquote>\n<p>GPT: 协议栈（Protocol Stack）是指在计算机网络中，一组按照层次结构组织的网络协议的集合。这些协议按照功能和责任被分成不同的层次，每一层都负责执行特定的功能，从物理层到应用层依次排列。协议栈的每一层都建立在下一层的基础上，并为上一层提供服务。</p>\n</blockquote>\n<p>应用程序 通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP</p>\n<p>下半部分是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>\n<p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p>\n<ul>\n<li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li>\n<li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li>\n</ul>\n<p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作</p>\n<h4 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h4><p>TCP协议 可靠传输</p>\n<h4 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h4><h4 id=\"MAC\"><a href=\"#MAC\" class=\"headerlink\" title=\"MAC\"></a>MAC</h4><h4 id=\"网卡\"><a href=\"#网卡\" class=\"headerlink\" title=\"网卡\"></a>网卡</h4><h4 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h4><h4 id=\"路由器\"><a href=\"#路由器\" class=\"headerlink\" title=\"路由器\"></a>路由器</h4><h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP基本概念\"><a href=\"#HTTP基本概念\" class=\"headerlink\" title=\"HTTP基本概念\"></a>HTTP基本概念</h3><h4 id=\"HTTP是什么？\"><a href=\"#HTTP是什么？\" class=\"headerlink\" title=\"HTTP是什么？\"></a>HTTP是什么？</h4><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p>\n<h5 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h5><p>HTTP是一个用在计算机世界里的协议， 它确定了一种计算机之间<font color = \"blue\">交流与通信的规范</font>，以及相关的<font color=\"red\">各种控制和错误处理方式</font></p>\n<h5 id=\"传输\"><a href=\"#传输\" class=\"headerlink\" title=\"传输\"></a>传输</h5><p>HTTP是一个双向协议，也就是A - B 之间的传输，数据虽然是在AB之间传输，但是运行中间有中转和接力，只需要中间人也满足HTTP协议，不打扰正常的数据传输，可以添加任意额外的东西</p>\n<p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p>\n<h5 id=\"超文本\"><a href=\"#超文本\" class=\"headerlink\" title=\"超文本\"></a>超文本</h5><p>HTTP 传输的内容是「超文本」。</p>\n<p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p>\n<p>再来理解「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p>\n<p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p>\n<p><mark background-color = \"yellow\"><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong> </mark></p>\n<h4 id=\"HTTP常见的状态码\"><a href=\"#HTTP常见的状态码\" class=\"headerlink\" title=\"HTTP常见的状态码\"></a>HTTP常见的状态码</h4><p><font color=\"blue\">1xx</font> 提示信息，表示目前是协议处理的中间状态，还需要后续处理，实际用到的比较少</p>\n<p><font color=\"blue\">2xx</font> 表示服务器成功处理了客户端的请求</p>\n<ul>\n<li>「<strong>200 OK</strong>」 最常见的成功状态码，表示一切正常，如果是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>\n<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>\n<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>\n</ul>\n<p><font color=\"blue\">3xx</font>  状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong></p>\n<ul>\n<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>\n<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>\n</ul>\n<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>\n<ul>\n<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>\n</ul>\n<p><font color=\"blue\">4xx </font> 表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>\n<ul>\n<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>\n<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>\n<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>\n</ul>\n<p><font color=\"blue\">5xx </font> 表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>\n<ul>\n<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>\n<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>\n<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>\n<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>\n</ul>\n<h4 id=\"HTTP常见字段\"><a href=\"#HTTP常见字段\" class=\"headerlink\" title=\"HTTP常见字段\"></a>HTTP常见字段</h4><h3 id=\"HTTP1-0\"><a href=\"#HTTP1-0\" class=\"headerlink\" title=\"HTTP1.0\"></a>HTTP1.0</h3><p>短连接</p>\n<h3 id=\"HTTP1-1\"><a href=\"#HTTP1-1\" class=\"headerlink\" title=\"HTTP1.1\"></a>HTTP1.1</h3><p>实现了长连接</p>\n<p>优点：</p>\n<ul>\n<li><p>简单：<code>header+body</code>, 头部信息也是<code>key-value</code>的简单格式</p>\n</li>\n<li><p>灵活和易于扩展</p>\n</li>\n<li><p>应用广泛和跨平台</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>无状态</li>\n<li>明文传输</li>\n<li>不安全</li>\n</ul>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h5><h5 id=\"管道网络传输\"><a href=\"#管道网络传输\" class=\"headerlink\" title=\"管道网络传输\"></a>管道网络传输</h5><p>不是默认开启， 并且浏览器基本没有支持</p>\n<h5 id=\"队头堵塞\"><a href=\"#队头堵塞\" class=\"headerlink\" title=\"队头堵塞\"></a>队头堵塞</h5><h5 id=\"Http1-1-断点续传\"><a href=\"#Http1-1-断点续传\" class=\"headerlink\" title=\"Http1.1 断点续传\"></a>Http1.1 断点续传</h5><p>1、客户端发起请求，并在请求包含Range字段：<strong>Range：bytes&#x3D;start-end</strong></p>\n<p>2、服务器收到请求之后，返回指定范围的数据，响应状态码为206，表示部分内容成功返回 响应字段有Content-Range: bytes 0-499&#x2F;22400 返回数据的范围和接数据总的大小；</p>\n<p>3、客户端收到部分响应之后，保存到本地的临时文件中，并且继续请求</p>\n<p>4、下载完成之后，客户端将文件合并到最终的文件，从而实现整个文件的下载</p>\n<p>此外 因为服务器上的数据可能会被更改，所以需要断点续传需要判断是否发生过更改 if_modified ETag  ..</p>\n<h4 id=\"性能瓶颈\"><a href=\"#性能瓶颈\" class=\"headerlink\" title=\"性能瓶颈\"></a>性能瓶颈</h4><ul>\n<li><p>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</p>\n</li>\n<li><p>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</p>\n</li>\n<li><p>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</p>\n</li>\n<li><p>没有请求优先级控制；</p>\n</li>\n<li><p>请求只能从客户端开始，服务器只能被动响应。</p>\n</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><p>基于HTTPS实现，HTTP是明文传输 所以在安全上有以下三个问题：</p>\n<blockquote>\n<p>窃听风险：明文可以直接被其他人看到</p>\n<p>篡改风险：明文容易被直接修改内容</p>\n<p>冒充风险：容易被冒充服务端</p>\n</blockquote>\n<p>HTTP<font color='blue'><strong>S</strong></font>，在HTTP于TCP层之间加入了<code>SSL/TLS</code>协议，可以解决上述的风险：</p>\n<ul>\n<li>信息加密:  信息加密 无法破解 <font color='blue'>混合加密 &#x3D; &gt; 机密性 </font></li>\n<li>校验机制：保证内容是没被修改过的  <font color='blue'>摘要算法 &#x3D;&gt; 完整性</font></li>\n<li>数字身份证书：保证和你通信的对端是server端  <font color='blue'>数字证书&#x3D;&gt; “唯一性”</font></li>\n</ul>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><p>默认端口 <em><strong>443</strong></em></p>\n<p>消息机密性  通过混合加密的方式</p>\n<p>消息完整性  摘要算法保证消息的完整性（hash值）</p>\n<p>身份认证 数字证书CA认证</p>\n<h5 id=\"1、混合加密\"><a href=\"#1、混合加密\" class=\"headerlink\" title=\"1、混合加密\"></a>1、混合加密</h5><p>非对称加密：加密解密效率高，但是需要交换密钥，容易被截获</p>\n<p>常用的有RSA，DSA，ECC，DH</p>\n<p>对称加密：加密解密效率低，但是相对安全</p>\n<p>常用的有AES，DES，IDEA… </p>\n<blockquote>\n<p>私钥加密 公钥解密 -&gt; 保证消息不会被冒充，因私钥是不可泄漏的，能解密出来合法的消息说明发送方也是合法的</p>\n<p>公钥加密 私钥揭秘 -&gt; 内容只有一个人（持有私钥）可以破译 保证消息机密</p>\n</blockquote>\n<p>结合二者的优点 &#x3D;》 <strong>混合加密</strong></p>\n<ul>\n<li><p>在通信建立阶段使用非对称加密的方法进行  <code>会话密钥</code>  交换，</p>\n</li>\n<li><p>通信过程中使用对称加密的  <code>会话密钥</code>  加密明文数据进行通信</p>\n</li>\n</ul>\n<h5 id=\"2、摘要算法-数字签名\"><a href=\"#2、摘要算法-数字签名\" class=\"headerlink\" title=\"2、摘要算法 + 数字签名\"></a>2、摘要算法 + 数字签名</h5><p>为了保证数据的完整性，需要针对内容计算一个「指纹」,然后和内容一起传输</p>\n<p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p>\n<p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p>\n<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong></p>\n<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>\n<h5 id=\"3、数字证书\"><a href=\"#3、数字证书\" class=\"headerlink\" title=\"3、数字证书\"></a>3、数字证书</h5><p>已经解决了完整性和机密性，但是还不够，但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p>\n<p>因此需要一个权威机构来认证服务器分发公钥的合法性，在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<font color='blue'> 数字证书 &#x3D; 服务器公钥 + CA的数字签名 </font>+ 一些信息</p>\n<blockquote>\n<p>CA 会使用自己的<font color='blue'>私钥</font>将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p>\n</blockquote>\n<h5 id=\"HTTPS-如何建立连接？\"><a href=\"#HTTPS-如何建立连接？\" class=\"headerlink\" title=\"HTTPS 如何建立连接？\"></a>HTTPS 如何建立连接？</h5><p>SSL&#x2F;TLS 协议基本流程：”Secure Sockets Layer” &#x2F; “Transport Layer Security”</p>\n<ul>\n<li>客户端向服务器所要数字证书，验证公钥</li>\n<li>双方协商产生  <code>会话密钥</code></li>\n<li>使用  <code>会话密钥</code>  通信</li>\n</ul>\n<p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href=\"https://xiaolincoding.com/network/2_http/https_rsa.html\">RSA 算法 (opens new window)</a>和 <a href=\"https://xiaolincoding.com/network/2_http/https_ecdhe.html\">ECDHE 算法 (opens new window)</a>。</p>\n<p>具体的四次握手 略</p>\n<p>证书的验证过程中<strong>还存在一个证书信任链的问题</strong> </p>\n<p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p>\n<p><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</strong></p>\n<h5 id=\"HTTPS-的应用数据是如何保证完整性的？\"><a href=\"#HTTPS-的应用数据是如何保证完整性的？\" class=\"headerlink\" title=\"HTTPS 的应用数据是如何保证完整性的？\"></a>HTTPS 的应用数据是如何保证完整性的？</h5><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p>\n<ul>\n<li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li>\n<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li>\n</ul>\n<p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，具体过程如下：</p>\n<ul>\n<li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li>\n<li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>\n<li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>\n<li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>\n</ul>\n<p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p>\n<h5 id=\"HTTPS一定安全可靠吗？\"><a href=\"#HTTPS一定安全可靠吗？\" class=\"headerlink\" title=\"HTTPS一定安全可靠吗？\"></a>HTTPS一定安全可靠吗？</h5><p>理论上是可靠的，只要用户不擅自信任未知来源的网站</p>\n<p>客户端 — 中间人 —- 服务器</p>\n<p>解决中间人转发的问题 HTTPS双向认证，加上服务器对客户端的认证，服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>\n<h4 id=\"特性-1\"><a href=\"#特性-1\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"1、头部压缩\"><a href=\"#1、头部压缩\" class=\"headerlink\" title=\"1、头部压缩\"></a>1、头部压缩</h5><p>压缩头部，如果同时发出多个请求，头是一样的，协议会消除重复的部分 HPAC算法</p>\n<h5 id=\"2、二进制格式\"><a href=\"#2、二进制格式\" class=\"headerlink\" title=\"2、二进制格式\"></a>2、二进制格式</h5><p>不像HTTP1.1 是纯文本格式，采用的二进制，统称为帧，头和body 都是二进制，对计算机友好，直接解析二进制报文，增加了数据传输的效率</p>\n<h5 id=\"3、并发传输\"><a href=\"#3、并发传输\" class=\"headerlink\" title=\"3、并发传输\"></a>3、并发传输</h5><p>引入了stream概念，多个stream复用在一个TCP连接，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</p>\n<p><font color='blue'>解决了队头堵塞的问题</font></p>\n<h5 id=\"4、服务器推送\"><a href=\"#4、服务器推送\" class=\"headerlink\" title=\"4、服务器推送\"></a>4、服务器推送</h5><p>client和server都可以建立stream <font color='blue'>客户端建立的stream必须是奇数， server必须是偶数</font></p>\n<p>奇数steam 传输客户端向服务器请求的资源，偶数stream传输服务器主动推动的资源</p>\n<p><font color=blue>但是如果需要频繁推送资源 就需要使用Websocket了</font></p>\n<h4 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h4><p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p>\n<p>也就是内核接收到的数据包如果乱序或者丢包了，那么这个数据报就会被卡在内核，直到数据全部到齐，TCP重组成功再返回给应用层，<font color='blue'>也就是HTTP2.0是由于采用的TCP协议堵塞在内核里面的！</font></p>\n<h3 id=\"HTTP3-0\"><a href=\"#HTTP3-0\" class=\"headerlink\" title=\"HTTP3.0\"></a>HTTP3.0</h3><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>\n<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输</p>\n<h4 id=\"特性-2\"><a href=\"#特性-2\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"1、无队头堵塞\"><a href=\"#1、无队头堵塞\" class=\"headerlink\" title=\"1、无队头堵塞\"></a>1、无队头堵塞</h5><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。 再加上 协议更换成了UDP，内核层面的堵塞也没有了，所以没有队头堵塞</p>\n<h5 id=\"2、更快的连接建立\"><a href=\"#2、更快的连接建立\" class=\"headerlink\" title=\"2、更快的连接建立\"></a>2、更快的连接建立</h5><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>\n<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>\n<p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，</p>\n<h5 id=\"3、连接迁移\"><a href=\"#3、连接迁移\" class=\"headerlink\" title=\"3、连接迁移\"></a>3、连接迁移</h5><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>\n<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>\n<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>\n<h4 id=\"缺陷-1\"><a href=\"#缺陷-1\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h4><p>有待普及</p>\n<h3 id=\"HTTP版本总结\"><a href=\"#HTTP版本总结\" class=\"headerlink\" title=\"HTTP版本总结\"></a>HTTP版本总结</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>http 1.0</th>\n<th>http 1.1</th>\n<th>http 2.0</th>\n<th>http 3.0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>改进</td>\n<td></td>\n<td>1、更改为长连接  2、增加了管道机制，允许请求端一次性发送多个请求3、支持断点续传4、支持先发送header而不发送body，先用header判断是否成功，再发送数据，节约带宽</td>\n<td>1、基于HTTP S，安全性有保障 2、头部压缩 3、二进制格式 3、并发传输 4、服务器主动推送资源</td>\n<td>TCP改成了UDP QUIC协议来保证可靠传输 更快的连接建立 连接迁移</td>\n</tr>\n<tr>\n<td>缺陷</td>\n<td>短连接，每次重复连接TCP带来的性能开销</td>\n<td>1、首部不能压缩，只能压缩body，导致冗余，2、头部冗长，每次都要发送冗长的头部效率较低 3、server端只能按照请求顺序响应，会有队头堵塞问题 4、没有请求优先级控制 5、请求只能从客户端开始，服务器只能被动响应</td>\n<td>通过stream的并发能力，不同的请求可以使用不同的stream ID来发送解决了队头堵塞的问题，但是只解决了HTTP的队头堵塞，TCP的“队头堵塞“还没有解决：发生丢包x则x+1之后的数据会被堵塞在内核直到包x重传</td>\n<td>尚未普及</td>\n</tr>\n</tbody></table>\n<p>SSL&#x2F;TLS  Secure Sockets Layer &#x2F; Transport Layer security</p>\n<h3 id=\"HTTP缓存技术\"><a href=\"#HTTP缓存技术\" class=\"headerlink\" title=\"HTTP缓存技术\"></a>HTTP缓存技术</h3><h5 id=\"为什么需要缓存？\"><a href=\"#为什么需要缓存？\" class=\"headerlink\" title=\"为什么需要缓存？\"></a>为什么需要缓存？</h5><p>如果每次向服务器请求的响应都是一样的，那么就没必要向服务器请求响应，只需要由浏览器缓存下来，然后判断缓存是否可用，直接处理即可</p>\n<h5 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h5><p>只要浏览器判断缓存没有过期，直接使用本地缓存，<font color='blue'>决定是否使用缓存的主动性在浏览器这边</font></p>\n<p>HTTP响应头部使用 <strong>Cache-Control</strong> 相对时间   ， <strong>Expires</strong> 绝对时间 两个字段来实现</p>\n<p>如果同时有两个字段 ，<strong>前者优先级高</strong></p>\n<p>Cache-control <font color='red'>选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存</font>。具体的实现流程如下：</p>\n<ul>\n<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>\n<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>\n<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>\n</ul>\n<h5 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h5><p>某些请求的响应码是304， 这就是服务器在告诉浏览器可以使用本地缓存的资源，<font color='blue'>这种服务器通知客户端可以使用本地缓存的方式-&gt; 协商缓存</font></p>\n<h6 id=\"实现方式1-请求头中的If-Modified-Sincce-响应头的Last-Modified\"><a href=\"#实现方式1-请求头中的If-Modified-Sincce-响应头的Last-Modified\" class=\"headerlink\" title=\"实现方式1 请求头中的If-Modified-Sincce + 响应头的Last-Modified\"></a>实现方式1 <strong>请求头中的If-Modified-Sincce + 响应头的Last-Modified</strong></h6><p>响应头的Last-Modified：标识这个响应资源的最后修改时间</p>\n<p>请求头中的If-Modified-Sincce ： </p>\n<ul>\n<li>当资源过期了，发现响应头有Last-Modified，则再次请求的时候带上Last-Modified，(If-Modified-Since &#x3D; Last-Modified)</li>\n<li>服务器收到请求后发现有If-Modified-Since字段与资源的最后修改时间(Last-Modified)对比</li>\n<li>如果Last-Modified大（更新），返回最新资源 HTTP200 OK</li>\n<li>如果Last-Modified小（更旧），资源无修改，返回HTTP 304 走缓存</li>\n</ul>\n<h6 id=\"实现方式2-请求头中的If-None-Match-响应头的Etag\"><a href=\"#实现方式2-请求头中的If-None-Match-响应头的Etag\" class=\"headerlink\" title=\"实现方式2 请求头中的If-None+Match + 响应头的Etag\"></a>实现方式2 <strong>请求头中的If-None+Match + 响应头的Etag</strong></h6><p><font color='blue'>这种方法的优先级更高</font></p>\n<blockquote>\n<p>因为ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p>\n<p>1、在没有修改文件内容的时候，修改时间可能也会变，比如touch命令，导致客户端还是需要重新请求资源响应</p>\n<p>2、有些文件实在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次</p>\n<p>3、有些服务器不能精确获取文件最后的修改时间</p>\n</blockquote>\n<p>响应头部中的Etag：响应资源的唯一标识</p>\n<p>请求头部中的If-None-Match：</p>\n<ul>\n<li>当资源过期的时候，发现响应头里面有Etag，则再次发起请求的时候，就把If-None-Match的值设置为Etag的值</li>\n<li>服务器收到请求之后比对，如果资源更改返回HTTP 200 ok</li>\n<li>没有更改返回 HTTP 304</li>\n</ul>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>​\t协商缓存这两个字段都需要配合强制缓存中的<code>Cache-Control</code>来使用，只有未能命中强制缓存，才能发起带有协商缓存字段的请求。</p>\n<p>也即是：</p>\n<p><font color='green'>浏览器请求-&gt;是否有缓存-&gt; Cache-Control是否过期-&gt; 是否有Etag -&gt;是否有Last-Modified </font></p>\n<p>什么是同步和异步？</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><h4 id=\"普通哈希\"><a href=\"#普通哈希\" class=\"headerlink\" title=\"普通哈希\"></a>普通哈希</h4><p>对客户端的IP+port 进行哈希 ，然后的得到的 值 对服务器集群的数量进行取模， 也就是hash(ip+port) % num, 即可得到由哪台服务器提供服务</p>\n<p>问题：一旦要对 服务器集群进行扩容和缩容，就会出现原有的<strong>哈希映射失效，数据需要重新分配</strong>，在集群数量比较多的时候，这是非常繁琐麻烦的</p>\n<h4 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h4><p>Hash(ip+port) % 2^32 对固定的数字取模，而不是对服务器集群的数量取模，</p>\n<p>两个步骤：1、 先对 集群服务器的每个节点（IP）做一次哈希，然后可以得到这个节点在<strong>哈希环</strong>上的位置</p>\n<p>​\t\t    2、 客户端发起请求， 进行哈希，然后在哈希环上顺时针遇到的第一个节点就是提供服务的节点</p>\n<p>问题：当需要缩容的时候，需要缩容的节点可能在哈希环上是很多客户端选择的节点，把这个服务器节点A从哈希环上去掉，就会发生 这个A顺时针往下的一个节点B突然接收到A所负责的这部分请求，从而导致B崩溃</p>\n<h4 id=\"虚拟节点\"><a href=\"#虚拟节点\" class=\"headerlink\" title=\"虚拟节点\"></a>虚拟节点</h4><p>在哈希环上引入虚拟节点， A-01，A-02，A-03， B-01，B-02，B-03，C-01，C-02，C-03，遇到虚拟节点的就会去找虚拟节点对应的真实节点， 虚拟节点在哈希环上是均匀分布的</p>\n<p>当A服务器要下线的时候，A的虚拟节点承载的请求会被均衡分配到BC的虚拟节点，也就是分给不同的服务器处理而不是一致性哈希只给一台服务器处理，这样就<strong>分散了压力</strong></p>\n","cover":false,"excerpt":"","more":"<hr>\n<p>title: 计网</p>\n<hr>\n<h2 id=\"模型架构\"><a href=\"#模型架构\" class=\"headerlink\" title=\"模型架构\"></a>模型架构</h2><p>三种模型 分别是OSI TCP&#x2F;IP 五层模型</p>\n<blockquote>\n<p>为什么要设计不同的layer？</p>\n</blockquote>\n<p>对于同一台设备的不同进程的通信，有很多方式 <font color = blue>管道，消息队列，信号，共享内存 </font>,  但是对于不同设备的进程间通信，就会使用到网络通信， 各种设备具有不同的特性，为了兼容，就协商出了一套通用的网络协议</p>\n<p>网络的分层：</p>\n<ol>\n<li><strong>模块化设计</strong>：网络分层将整个网络系统分解为多个层次，每个层次都有特定的功能和责任。这种模块化设计使得网络结构更加清晰，降低了网络系统的复杂度，方便了系统的设计、开发和维护。</li>\n<li><strong>标准化</strong>：每个网络层次都有相应的标准和协议，定义了该层次的功能、数据格式、传输方式等规范。这些标准和协议使得不同厂商的网络设备和软件可以互相兼容和通信，促进了网络设备的互联互通。</li>\n<li><strong>提高可靠性</strong>：各层之间解耦合，由于每个层次都有明确的功能和责任，网络分层可以提高网络系统的可靠性。当一个层次出现问题时，只需修复该层次，而不会影响到其他层次，从而提高了网络系统的稳定性和可靠性。</li>\n<li><strong>提高性能</strong>：网络分层可以使网络通信过程更加高效。每个层次只需关注自己的功能和责任，而不需要关心其他层次的具体实现细节，从而提高了网络通信的效率。</li>\n<li><strong>降低成本</strong>：网络分层可以将网络系统分解为多个相对独立的模块，降低了系统设计、开发和维护的成本。此外，通过使用标准化的协议和技术，可以降低网络设备和软件的开发成本，提高了网络系统的经济效益。</li>\n</ol>\n<h3 id=\"TCP-IP-网络模型\"><a href=\"#TCP-IP-网络模型\" class=\"headerlink\" title=\"TCP&#x2F;IP 网络模型\"></a>TCP&#x2F;IP 网络模型</h3><h4 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h4><p>进程需要通信时，就把数据传给下一层，应用层只需要关注为用户提供功能，如HTPTP，FTP，Telnet，DNS, SMTP;</p>\n<p>应用层不关心怎么传输，只负责把数据给传输层</p>\n<p>工作在用户态</p>\n<h4 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h4><p>应用层的数据包会给传输层，传输层负责给应用层提供服务</p>\n<h5 id=\"两个协议TCP和UDP\"><a href=\"#两个协议TCP和UDP\" class=\"headerlink\" title=\"两个协议TCP和UDP\"></a>两个协议TCP和UDP</h5><p>Transmission Control Protocol, 大部分应用使用的都是传输控制协议TCP，如HTTP，TCP面向连接，多了很多特性，保证可靠的交付，UDP不保证可靠交付，但是传输效率较高</p>\n<blockquote>\n<p>要实现可靠的UDP也可以，只需要在UDP上把TCP的特性实现一遍就行了，拥塞控制，流量控制，超时重传…</p>\n</blockquote>\n<p>要传输的数据可能很大，直接传不太方便，所以需要对数据包进行分块，TCP传输的数据是报文段，传输的数据大小超过了MSS（TCP最大报文段长度），就需要对数据包分块，这样即使有一个包丢失了，只需要重传丢失的即可。</p>\n<p>传输层在接收方需要干的事情就是 负责处理下层送上的数据，去掉之前加上的头部，顺序重组，校验和… 然后上传给应用层</p>\n<blockquote>\n<p>如何区分是哪个应用呢？端口号</p>\n<p>80 web服务器使用的端口号，22 ssh服务使用的端口号…</p>\n</blockquote>\n<h4 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h4><p>传输层只负责传输过程的一些预处理，但实际上并不负责传输</p>\n<p>实际上的网络环境十分复杂，有非常多的节点和设备，需要进行路径和节点的选择，这部分交给传输层做就有点冗余了，因此把这一部分分出来给网络层做，进一步解耦。</p>\n<p>网络层最常使用的就是IP协议，IP协议会将传输层的报文作为数据部分，再加上IP头部组成IP报文，如果IP报文超过了MTU（1500 bytes normally），就再次分段，得到一个IP报文段。</p>\n<blockquote>\n<p>网络层负责将数据传输到另外一个设备，世界上这么多设备，如何找到对方呢？网络层需要有 区分不同设备的编号 -&gt; <mark background-color=\"yellow\">IP</mark></p>\n</blockquote>\n<p>网络号 主机号 子网掩码</p>\n<p>在寻址过程中，先找到对应的网络号（先找到学校），再去找主机号（在找对应的人）</p>\n<p>除了寻址，网络层还有一件事情就是路由，数据传输过程中，并不是一条网线走到黑，而是需要经过一系列的节点（交换机，路由器，转发），所以网络层需要通过路由算法来决定下一步走哪个节点</p>\n<p>IP协议告诉你要去哪里，路由告诉你下一跳该去哪，一个是大局，一个是细节</p>\n<h4 id=\"网络接口层\"><a href=\"#网络接口层\" class=\"headerlink\" title=\"网络接口层\"></a>网络接口层</h4><p>加上了IP头部之后，交给网络接口层，在头部再加上MAC头部，封装成一个数据帧发送到网络上</p>\n<p>IP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们就可以知道这个包要去哪，但是在以太网的世界中，是行不通的，</p>\n<p>以太网是一种在局域网内将附近的设备连接起来进行通信的技术。以太网在区分设备的时候是通过MAC地址判断的，MAC就是设备网卡的硬件地址，出厂时唯一设定，</p>\n<p>MAC头部是以太网使用的头部，包含接收方和发送方的MAC地址信息，可以通过ARP协议获取MAC地址，</p>\n<p>网络接口层为网络提供 <strong>链路级别</strong> 传输的服务，负责在以太网，WIFI这样的底层网络上发送数据包，工作在网卡这个层次，使用MAC地址来标识网络设备</p>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>地址类型</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网络层 (IP)</td>\n<td>IP地址</td>\n<td>在网络中唯一标识设备</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>MAC地址</td>\n<td>在同一局域网内唯一标识设备</td>\n</tr>\n</tbody></table>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><strong>上至下</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">layer</th>\n<th align=\"center\">数据包格式</th>\n<th align=\"center\">处理操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">应用层</td>\n<td align=\"center\">数据包</td>\n<td align=\"center\">无</td>\n</tr>\n<tr>\n<td align=\"center\">传输层</td>\n<td align=\"center\">报文段</td>\n<td align=\"center\">加上TCP头（校验和，ack，syn等等</td>\n</tr>\n<tr>\n<td align=\"center\">网络层</td>\n<td align=\"center\">ip报文</td>\n<td align=\"center\">加上ip头，加入目标地址ip原地址ip</td>\n</tr>\n<tr>\n<td align=\"center\">网络接口层</td>\n<td align=\"center\">MAC帧</td>\n<td align=\"center\">加上mac头，下一跳mac地址，帧头 帧尾</td>\n</tr>\n<tr>\n<td align=\"center\">物理层</td>\n<td align=\"center\">01比特流</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>下至上</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">layer</th>\n<th align=\"center\">数据包格式</th>\n<th align=\"center\">处理操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">应用层</td>\n<td align=\"center\">数据包</td>\n<td align=\"center\">处理数据</td>\n</tr>\n<tr>\n<td align=\"center\">传输层</td>\n<td align=\"center\">报文段</td>\n<td align=\"center\">去掉TCP头，按照序号重组，验证校验和… 发送给对应应用层端口号</td>\n</tr>\n<tr>\n<td align=\"center\">网络层</td>\n<td align=\"center\">ip报文</td>\n<td align=\"center\">去掉IP头尾 发送到上一层</td>\n</tr>\n<tr>\n<td align=\"center\">网络接口层</td>\n<td align=\"center\">MAC帧</td>\n<td align=\"center\">去掉mac帧 头尾，发送到上一层</td>\n</tr>\n<tr>\n<td align=\"center\">物理层</td>\n<td align=\"center\">01比特流</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"输入url点击回车，发送了什么？\"><a href=\"#输入url点击回车，发送了什么？\" class=\"headerlink\" title=\"输入url点击回车，发送了什么？\"></a>输入url点击回车，发送了什么？</h3><h4 id=\"HTTP-Hypertext-Transfer-Protocol\"><a href=\"#HTTP-Hypertext-Transfer-Protocol\" class=\"headerlink\" title=\"HTTP (Hypertext Transfer Protocol)\"></a>HTTP (Hypertext Transfer Protocol)</h4><p>首先要做解析 URL，从而生成发送给web服务器的请求信息</p>\n<p><a href=\"http://web-server/dir/file.html\">http://web-server/dir/file.html</a></p>\n<table>\n<thead>\n<tr>\n<th>协议名字</th>\n<th>分隔符</th>\n<th>服务器名字</th>\n<th>目录名</th>\n<th>…</th>\n<th>文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>http</td>\n<td>&#x2F;&#x2F;</td>\n<td>web-server</td>\n<td>dir</td>\n<td></td>\n<td>file.html</td>\n</tr>\n<tr>\n<td>https</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>Web-server : &#x2F;-  <font color = \"blue\">根目录</font></p>\n<p>​\t\t\t|-dir1</p>\n<p>​\t\t\t|-dir2</p>\n<p>​\t\t\t|-dir3- file.html\t</p>\n<p>当没有指定文件的时候，返回的是根目录下的默认文件</p>\n<p>对url进行解析之后，浏览器确定了服务器和文件名以及对应的协议， 根据这些信息就可以生成HTTP请求消息了。</p>\n<h4 id=\"DNS-（Domain-Name-System）-地址解析协议\"><a href=\"#DNS-（Domain-Name-System）-地址解析协议\" class=\"headerlink\" title=\"DNS （Domain Name System） 地址解析协议\"></a>DNS （Domain Name System） 地址解析协议</h4><p>web-server 一般是一个 域名 如 <a href=\"http://www.baidu.com/\">www.baidu.com</a> &#x3D; <a href=\"http://www.baidu.com/\">www.baidu.com</a>. ，但是网络中的地址是IP地址，如何通过域名得到IP？ -&gt; DNS 协议</p>\n<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>\n<p>域名使用. 来分隔，实际上域名最后还有一个点. 表示根域名，根域名 <mark background-color = \"yellow\"> . </mark> ，顶级域名 <mark background-color=\"red\">.com</mark> , </p>\n<p>域名的层级关系类似一颗树</p>\n<ul>\n<li>根DNS服务器 .</li>\n<li>顶级域DNS服务器 .com</li>\n<li>权威DNS服务器 Baidu.com</li>\n</ul>\n<hr>\n<p>域名解析的工作流程</p>\n<ol>\n<li>客户端首先发起一个DNS请求，问<a href=\"http://www.server.com的ip是什么,并且发送给本地的dns服务器(也就是客户端tcp/IP%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%A1%AB%E5%86%99%E7%9A%84DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%A6%82114.114.114.114\">www.server.com的ip是什么，并且发送给本地的DNS服务器（也就是客户端TCP/IP设置中填写的DNS服务器地址，如114.114.114.114</a></li>\n<li>本地域名服务器收到客户端的请求之后，如果缓存有<a href=\"http://www.server.com的记录,就直接返回,如果没有,本地dns会去询问他的根域名服务器,根具有所有域名的ip,但并不能直接告诉,只能指路/\">www.server.com的记录，就直接返回，如果没有，本地DNS会去询问他的根域名服务器，根具有所有域名的IP，但并不能直接告诉，只能指路</a></li>\n<li>根DNS收到本地请求之后，发现有.com ,于是回复 这个事情归小弟 .com顶级域名服务器管理，你去问他吧</li>\n<li>本地DNS收到了根返回的  .com顶级域名服务器 地址， 于是向他询问</li>\n<li>顶级域com服务器 回复 给 负责<a href=\"http://www.server.com区域的权威dns地址/\">www.server.com区域的权威DNS地址</a></li>\n<li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href=\"http://www.server.com对应的IP是啥呀？”\">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>\n<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>\n<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>\n</ol>\n<blockquote>\n<p>是否每次解析域名都要经过这么复杂的步骤？</p>\n</blockquote>\n<p>这个时候缓存就发挥作用了，如果<em><strong>浏览器自身</strong></em>有这个域名对应的缓存，就直接返回，没有的话就去问<em><strong>操作系统的缓存</strong></em>，还没有就去<em><strong>hosts文件</strong></em>查看，再没有才去问<em><strong>DNS服务器</strong></em></p>\n<p><font color = \"blue\"> 现在已经获得目的计算机的IP了，接下来数据包要怎么做呢？</font></p>\n<h4 id=\"协议栈\"><a href=\"#协议栈\" class=\"headerlink\" title=\"协议栈\"></a>协议栈</h4><p>获得目的IP之后，就可以吧HTTP的传输工作交给操作系统的协议栈</p>\n<p>协议栈分为几个部分，分别承担不同的工作，上面负责委托下面工作，下面负责为上面提供服务</p>\n<blockquote>\n<p>GPT: 协议栈（Protocol Stack）是指在计算机网络中，一组按照层次结构组织的网络协议的集合。这些协议按照功能和责任被分成不同的层次，每一层都负责执行特定的功能，从物理层到应用层依次排列。协议栈的每一层都建立在下一层的基础上，并为上一层提供服务。</p>\n</blockquote>\n<p>应用程序 通过调用Socket库，来委托协议栈工作，协议栈的上半部分有两块，分别是负责收发数据的TCP和UDP</p>\n<p>下半部分是用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>\n<p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p>\n<ul>\n<li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li>\n<li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li>\n</ul>\n<p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作</p>\n<h4 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h4><p>TCP协议 可靠传输</p>\n<h4 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h4><h4 id=\"MAC\"><a href=\"#MAC\" class=\"headerlink\" title=\"MAC\"></a>MAC</h4><h4 id=\"网卡\"><a href=\"#网卡\" class=\"headerlink\" title=\"网卡\"></a>网卡</h4><h4 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h4><h4 id=\"路由器\"><a href=\"#路由器\" class=\"headerlink\" title=\"路由器\"></a>路由器</h4><h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP基本概念\"><a href=\"#HTTP基本概念\" class=\"headerlink\" title=\"HTTP基本概念\"></a>HTTP基本概念</h3><h4 id=\"HTTP是什么？\"><a href=\"#HTTP是什么？\" class=\"headerlink\" title=\"HTTP是什么？\"></a>HTTP是什么？</h4><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p>\n<h5 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h5><p>HTTP是一个用在计算机世界里的协议， 它确定了一种计算机之间<font color = \"blue\">交流与通信的规范</font>，以及相关的<font color=\"red\">各种控制和错误处理方式</font></p>\n<h5 id=\"传输\"><a href=\"#传输\" class=\"headerlink\" title=\"传输\"></a>传输</h5><p>HTTP是一个双向协议，也就是A - B 之间的传输，数据虽然是在AB之间传输，但是运行中间有中转和接力，只需要中间人也满足HTTP协议，不打扰正常的数据传输，可以添加任意额外的东西</p>\n<p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p>\n<h5 id=\"超文本\"><a href=\"#超文本\" class=\"headerlink\" title=\"超文本\"></a>超文本</h5><p>HTTP 传输的内容是「超文本」。</p>\n<p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p>\n<p>再来理解「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p>\n<p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p>\n<p><mark background-color = \"yellow\"><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong> </mark></p>\n<h4 id=\"HTTP常见的状态码\"><a href=\"#HTTP常见的状态码\" class=\"headerlink\" title=\"HTTP常见的状态码\"></a>HTTP常见的状态码</h4><p><font color=\"blue\">1xx</font> 提示信息，表示目前是协议处理的中间状态，还需要后续处理，实际用到的比较少</p>\n<p><font color=\"blue\">2xx</font> 表示服务器成功处理了客户端的请求</p>\n<ul>\n<li>「<strong>200 OK</strong>」 最常见的成功状态码，表示一切正常，如果是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>\n<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>\n<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>\n</ul>\n<p><font color=\"blue\">3xx</font>  状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong></p>\n<ul>\n<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>\n<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>\n</ul>\n<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>\n<ul>\n<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>\n</ul>\n<p><font color=\"blue\">4xx </font> 表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>\n<ul>\n<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>\n<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>\n<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>\n</ul>\n<p><font color=\"blue\">5xx </font> 表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>\n<ul>\n<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>\n<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>\n<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>\n<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>\n</ul>\n<h4 id=\"HTTP常见字段\"><a href=\"#HTTP常见字段\" class=\"headerlink\" title=\"HTTP常见字段\"></a>HTTP常见字段</h4><h3 id=\"HTTP1-0\"><a href=\"#HTTP1-0\" class=\"headerlink\" title=\"HTTP1.0\"></a>HTTP1.0</h3><p>短连接</p>\n<h3 id=\"HTTP1-1\"><a href=\"#HTTP1-1\" class=\"headerlink\" title=\"HTTP1.1\"></a>HTTP1.1</h3><p>实现了长连接</p>\n<p>优点：</p>\n<ul>\n<li><p>简单：<code>header+body</code>, 头部信息也是<code>key-value</code>的简单格式</p>\n</li>\n<li><p>灵活和易于扩展</p>\n</li>\n<li><p>应用广泛和跨平台</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>无状态</li>\n<li>明文传输</li>\n<li>不安全</li>\n</ul>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h5><h5 id=\"管道网络传输\"><a href=\"#管道网络传输\" class=\"headerlink\" title=\"管道网络传输\"></a>管道网络传输</h5><p>不是默认开启， 并且浏览器基本没有支持</p>\n<h5 id=\"队头堵塞\"><a href=\"#队头堵塞\" class=\"headerlink\" title=\"队头堵塞\"></a>队头堵塞</h5><h5 id=\"Http1-1-断点续传\"><a href=\"#Http1-1-断点续传\" class=\"headerlink\" title=\"Http1.1 断点续传\"></a>Http1.1 断点续传</h5><p>1、客户端发起请求，并在请求包含Range字段：<strong>Range：bytes&#x3D;start-end</strong></p>\n<p>2、服务器收到请求之后，返回指定范围的数据，响应状态码为206，表示部分内容成功返回 响应字段有Content-Range: bytes 0-499&#x2F;22400 返回数据的范围和接数据总的大小；</p>\n<p>3、客户端收到部分响应之后，保存到本地的临时文件中，并且继续请求</p>\n<p>4、下载完成之后，客户端将文件合并到最终的文件，从而实现整个文件的下载</p>\n<p>此外 因为服务器上的数据可能会被更改，所以需要断点续传需要判断是否发生过更改 if_modified ETag  ..</p>\n<h4 id=\"性能瓶颈\"><a href=\"#性能瓶颈\" class=\"headerlink\" title=\"性能瓶颈\"></a>性能瓶颈</h4><ul>\n<li><p>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</p>\n</li>\n<li><p>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</p>\n</li>\n<li><p>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</p>\n</li>\n<li><p>没有请求优先级控制；</p>\n</li>\n<li><p>请求只能从客户端开始，服务器只能被动响应。</p>\n</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><p>基于HTTPS实现，HTTP是明文传输 所以在安全上有以下三个问题：</p>\n<blockquote>\n<p>窃听风险：明文可以直接被其他人看到</p>\n<p>篡改风险：明文容易被直接修改内容</p>\n<p>冒充风险：容易被冒充服务端</p>\n</blockquote>\n<p>HTTP<font color='blue'><strong>S</strong></font>，在HTTP于TCP层之间加入了<code>SSL/TLS</code>协议，可以解决上述的风险：</p>\n<ul>\n<li>信息加密:  信息加密 无法破解 <font color='blue'>混合加密 &#x3D; &gt; 机密性 </font></li>\n<li>校验机制：保证内容是没被修改过的  <font color='blue'>摘要算法 &#x3D;&gt; 完整性</font></li>\n<li>数字身份证书：保证和你通信的对端是server端  <font color='blue'>数字证书&#x3D;&gt; “唯一性”</font></li>\n</ul>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><p>默认端口 <em><strong>443</strong></em></p>\n<p>消息机密性  通过混合加密的方式</p>\n<p>消息完整性  摘要算法保证消息的完整性（hash值）</p>\n<p>身份认证 数字证书CA认证</p>\n<h5 id=\"1、混合加密\"><a href=\"#1、混合加密\" class=\"headerlink\" title=\"1、混合加密\"></a>1、混合加密</h5><p>非对称加密：加密解密效率高，但是需要交换密钥，容易被截获</p>\n<p>常用的有RSA，DSA，ECC，DH</p>\n<p>对称加密：加密解密效率低，但是相对安全</p>\n<p>常用的有AES，DES，IDEA… </p>\n<blockquote>\n<p>私钥加密 公钥解密 -&gt; 保证消息不会被冒充，因私钥是不可泄漏的，能解密出来合法的消息说明发送方也是合法的</p>\n<p>公钥加密 私钥揭秘 -&gt; 内容只有一个人（持有私钥）可以破译 保证消息机密</p>\n</blockquote>\n<p>结合二者的优点 &#x3D;》 <strong>混合加密</strong></p>\n<ul>\n<li><p>在通信建立阶段使用非对称加密的方法进行  <code>会话密钥</code>  交换，</p>\n</li>\n<li><p>通信过程中使用对称加密的  <code>会话密钥</code>  加密明文数据进行通信</p>\n</li>\n</ul>\n<h5 id=\"2、摘要算法-数字签名\"><a href=\"#2、摘要算法-数字签名\" class=\"headerlink\" title=\"2、摘要算法 + 数字签名\"></a>2、摘要算法 + 数字签名</h5><p>为了保证数据的完整性，需要针对内容计算一个「指纹」,然后和内容一起传输</p>\n<p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p>\n<p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p>\n<p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong></p>\n<p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p>\n<h5 id=\"3、数字证书\"><a href=\"#3、数字证书\" class=\"headerlink\" title=\"3、数字证书\"></a>3、数字证书</h5><p>已经解决了完整性和机密性，但是还不够，但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p>\n<p>因此需要一个权威机构来认证服务器分发公钥的合法性，在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<font color='blue'> 数字证书 &#x3D; 服务器公钥 + CA的数字签名 </font>+ 一些信息</p>\n<blockquote>\n<p>CA 会使用自己的<font color='blue'>私钥</font>将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p>\n</blockquote>\n<h5 id=\"HTTPS-如何建立连接？\"><a href=\"#HTTPS-如何建立连接？\" class=\"headerlink\" title=\"HTTPS 如何建立连接？\"></a>HTTPS 如何建立连接？</h5><p>SSL&#x2F;TLS 协议基本流程：”Secure Sockets Layer” &#x2F; “Transport Layer Security”</p>\n<ul>\n<li>客户端向服务器所要数字证书，验证公钥</li>\n<li>双方协商产生  <code>会话密钥</code></li>\n<li>使用  <code>会话密钥</code>  通信</li>\n</ul>\n<p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href=\"https://xiaolincoding.com/network/2_http/https_rsa.html\">RSA 算法 (opens new window)</a>和 <a href=\"https://xiaolincoding.com/network/2_http/https_ecdhe.html\">ECDHE 算法 (opens new window)</a>。</p>\n<p>具体的四次握手 略</p>\n<p>证书的验证过程中<strong>还存在一个证书信任链的问题</strong> </p>\n<p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p>\n<p><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题</strong></p>\n<h5 id=\"HTTPS-的应用数据是如何保证完整性的？\"><a href=\"#HTTPS-的应用数据是如何保证完整性的？\" class=\"headerlink\" title=\"HTTPS 的应用数据是如何保证完整性的？\"></a>HTTPS 的应用数据是如何保证完整性的？</h5><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p>\n<ul>\n<li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li>\n<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li>\n</ul>\n<p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，具体过程如下：</p>\n<ul>\n<li>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</li>\n<li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>\n<li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>\n<li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>\n</ul>\n<p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p>\n<h5 id=\"HTTPS一定安全可靠吗？\"><a href=\"#HTTPS一定安全可靠吗？\" class=\"headerlink\" title=\"HTTPS一定安全可靠吗？\"></a>HTTPS一定安全可靠吗？</h5><p>理论上是可靠的，只要用户不擅自信任未知来源的网站</p>\n<p>客户端 — 中间人 —- 服务器</p>\n<p>解决中间人转发的问题 HTTPS双向认证，加上服务器对客户端的认证，服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>\n<h4 id=\"特性-1\"><a href=\"#特性-1\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"1、头部压缩\"><a href=\"#1、头部压缩\" class=\"headerlink\" title=\"1、头部压缩\"></a>1、头部压缩</h5><p>压缩头部，如果同时发出多个请求，头是一样的，协议会消除重复的部分 HPAC算法</p>\n<h5 id=\"2、二进制格式\"><a href=\"#2、二进制格式\" class=\"headerlink\" title=\"2、二进制格式\"></a>2、二进制格式</h5><p>不像HTTP1.1 是纯文本格式，采用的二进制，统称为帧，头和body 都是二进制，对计算机友好，直接解析二进制报文，增加了数据传输的效率</p>\n<h5 id=\"3、并发传输\"><a href=\"#3、并发传输\" class=\"headerlink\" title=\"3、并发传输\"></a>3、并发传输</h5><p>引入了stream概念，多个stream复用在一个TCP连接，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</p>\n<p><font color='blue'>解决了队头堵塞的问题</font></p>\n<h5 id=\"4、服务器推送\"><a href=\"#4、服务器推送\" class=\"headerlink\" title=\"4、服务器推送\"></a>4、服务器推送</h5><p>client和server都可以建立stream <font color='blue'>客户端建立的stream必须是奇数， server必须是偶数</font></p>\n<p>奇数steam 传输客户端向服务器请求的资源，偶数stream传输服务器主动推动的资源</p>\n<p><font color=blue>但是如果需要频繁推送资源 就需要使用Websocket了</font></p>\n<h4 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h4><p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p>\n<p>也就是内核接收到的数据包如果乱序或者丢包了，那么这个数据报就会被卡在内核，直到数据全部到齐，TCP重组成功再返回给应用层，<font color='blue'>也就是HTTP2.0是由于采用的TCP协议堵塞在内核里面的！</font></p>\n<h3 id=\"HTTP3-0\"><a href=\"#HTTP3-0\" class=\"headerlink\" title=\"HTTP3.0\"></a>HTTP3.0</h3><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>\n<p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输</p>\n<h4 id=\"特性-2\"><a href=\"#特性-2\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"1、无队头堵塞\"><a href=\"#1、无队头堵塞\" class=\"headerlink\" title=\"1、无队头堵塞\"></a>1、无队头堵塞</h5><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。 再加上 协议更换成了UDP，内核层面的堵塞也没有了，所以没有队头堵塞</p>\n<h5 id=\"2、更快的连接建立\"><a href=\"#2、更快的连接建立\" class=\"headerlink\" title=\"2、更快的连接建立\"></a>2、更快的连接建立</h5><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p>\n<p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>\n<p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，</p>\n<h5 id=\"3、连接迁移\"><a href=\"#3、连接迁移\" class=\"headerlink\" title=\"3、连接迁移\"></a>3、连接迁移</h5><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>\n<p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>\n<p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>\n<h4 id=\"缺陷-1\"><a href=\"#缺陷-1\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h4><p>有待普及</p>\n<h3 id=\"HTTP版本总结\"><a href=\"#HTTP版本总结\" class=\"headerlink\" title=\"HTTP版本总结\"></a>HTTP版本总结</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>http 1.0</th>\n<th>http 1.1</th>\n<th>http 2.0</th>\n<th>http 3.0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>改进</td>\n<td></td>\n<td>1、更改为长连接  2、增加了管道机制，允许请求端一次性发送多个请求3、支持断点续传4、支持先发送header而不发送body，先用header判断是否成功，再发送数据，节约带宽</td>\n<td>1、基于HTTP S，安全性有保障 2、头部压缩 3、二进制格式 3、并发传输 4、服务器主动推送资源</td>\n<td>TCP改成了UDP QUIC协议来保证可靠传输 更快的连接建立 连接迁移</td>\n</tr>\n<tr>\n<td>缺陷</td>\n<td>短连接，每次重复连接TCP带来的性能开销</td>\n<td>1、首部不能压缩，只能压缩body，导致冗余，2、头部冗长，每次都要发送冗长的头部效率较低 3、server端只能按照请求顺序响应，会有队头堵塞问题 4、没有请求优先级控制 5、请求只能从客户端开始，服务器只能被动响应</td>\n<td>通过stream的并发能力，不同的请求可以使用不同的stream ID来发送解决了队头堵塞的问题，但是只解决了HTTP的队头堵塞，TCP的“队头堵塞“还没有解决：发生丢包x则x+1之后的数据会被堵塞在内核直到包x重传</td>\n<td>尚未普及</td>\n</tr>\n</tbody></table>\n<p>SSL&#x2F;TLS  Secure Sockets Layer &#x2F; Transport Layer security</p>\n<h3 id=\"HTTP缓存技术\"><a href=\"#HTTP缓存技术\" class=\"headerlink\" title=\"HTTP缓存技术\"></a>HTTP缓存技术</h3><h5 id=\"为什么需要缓存？\"><a href=\"#为什么需要缓存？\" class=\"headerlink\" title=\"为什么需要缓存？\"></a>为什么需要缓存？</h5><p>如果每次向服务器请求的响应都是一样的，那么就没必要向服务器请求响应，只需要由浏览器缓存下来，然后判断缓存是否可用，直接处理即可</p>\n<h5 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h5><p>只要浏览器判断缓存没有过期，直接使用本地缓存，<font color='blue'>决定是否使用缓存的主动性在浏览器这边</font></p>\n<p>HTTP响应头部使用 <strong>Cache-Control</strong> 相对时间   ， <strong>Expires</strong> 绝对时间 两个字段来实现</p>\n<p>如果同时有两个字段 ，<strong>前者优先级高</strong></p>\n<p>Cache-control <font color='red'>选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存</font>。具体的实现流程如下：</p>\n<ul>\n<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>\n<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>\n<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>\n</ul>\n<h5 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h5><p>某些请求的响应码是304， 这就是服务器在告诉浏览器可以使用本地缓存的资源，<font color='blue'>这种服务器通知客户端可以使用本地缓存的方式-&gt; 协商缓存</font></p>\n<h6 id=\"实现方式1-请求头中的If-Modified-Sincce-响应头的Last-Modified\"><a href=\"#实现方式1-请求头中的If-Modified-Sincce-响应头的Last-Modified\" class=\"headerlink\" title=\"实现方式1 请求头中的If-Modified-Sincce + 响应头的Last-Modified\"></a>实现方式1 <strong>请求头中的If-Modified-Sincce + 响应头的Last-Modified</strong></h6><p>响应头的Last-Modified：标识这个响应资源的最后修改时间</p>\n<p>请求头中的If-Modified-Sincce ： </p>\n<ul>\n<li>当资源过期了，发现响应头有Last-Modified，则再次请求的时候带上Last-Modified，(If-Modified-Since &#x3D; Last-Modified)</li>\n<li>服务器收到请求后发现有If-Modified-Since字段与资源的最后修改时间(Last-Modified)对比</li>\n<li>如果Last-Modified大（更新），返回最新资源 HTTP200 OK</li>\n<li>如果Last-Modified小（更旧），资源无修改，返回HTTP 304 走缓存</li>\n</ul>\n<h6 id=\"实现方式2-请求头中的If-None-Match-响应头的Etag\"><a href=\"#实现方式2-请求头中的If-None-Match-响应头的Etag\" class=\"headerlink\" title=\"实现方式2 请求头中的If-None+Match + 响应头的Etag\"></a>实现方式2 <strong>请求头中的If-None+Match + 响应头的Etag</strong></h6><p><font color='blue'>这种方法的优先级更高</font></p>\n<blockquote>\n<p>因为ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p>\n<p>1、在没有修改文件内容的时候，修改时间可能也会变，比如touch命令，导致客户端还是需要重新请求资源响应</p>\n<p>2、有些文件实在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次</p>\n<p>3、有些服务器不能精确获取文件最后的修改时间</p>\n</blockquote>\n<p>响应头部中的Etag：响应资源的唯一标识</p>\n<p>请求头部中的If-None-Match：</p>\n<ul>\n<li>当资源过期的时候，发现响应头里面有Etag，则再次发起请求的时候，就把If-None-Match的值设置为Etag的值</li>\n<li>服务器收到请求之后比对，如果资源更改返回HTTP 200 ok</li>\n<li>没有更改返回 HTTP 304</li>\n</ul>\n<h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>​\t协商缓存这两个字段都需要配合强制缓存中的<code>Cache-Control</code>来使用，只有未能命中强制缓存，才能发起带有协商缓存字段的请求。</p>\n<p>也即是：</p>\n<p><font color='green'>浏览器请求-&gt;是否有缓存-&gt; Cache-Control是否过期-&gt; 是否有Etag -&gt;是否有Last-Modified </font></p>\n<p>什么是同步和异步？</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><h4 id=\"普通哈希\"><a href=\"#普通哈希\" class=\"headerlink\" title=\"普通哈希\"></a>普通哈希</h4><p>对客户端的IP+port 进行哈希 ，然后的得到的 值 对服务器集群的数量进行取模， 也就是hash(ip+port) % num, 即可得到由哪台服务器提供服务</p>\n<p>问题：一旦要对 服务器集群进行扩容和缩容，就会出现原有的<strong>哈希映射失效，数据需要重新分配</strong>，在集群数量比较多的时候，这是非常繁琐麻烦的</p>\n<h4 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h4><p>Hash(ip+port) % 2^32 对固定的数字取模，而不是对服务器集群的数量取模，</p>\n<p>两个步骤：1、 先对 集群服务器的每个节点（IP）做一次哈希，然后可以得到这个节点在<strong>哈希环</strong>上的位置</p>\n<p>​\t\t    2、 客户端发起请求， 进行哈希，然后在哈希环上顺时针遇到的第一个节点就是提供服务的节点</p>\n<p>问题：当需要缩容的时候，需要缩容的节点可能在哈希环上是很多客户端选择的节点，把这个服务器节点A从哈希环上去掉，就会发生 这个A顺时针往下的一个节点B突然接收到A所负责的这部分请求，从而导致B崩溃</p>\n<h4 id=\"虚拟节点\"><a href=\"#虚拟节点\" class=\"headerlink\" title=\"虚拟节点\"></a>虚拟节点</h4><p>在哈希环上引入虚拟节点， A-01，A-02，A-03， B-01，B-02，B-03，C-01，C-02，C-03，遇到虚拟节点的就会去找虚拟节点对应的真实节点， 虚拟节点在哈希环上是均匀分布的</p>\n<p>当A服务器要下线的时候，A的虚拟节点承载的请求会被均衡分配到BC的虚拟节点，也就是分给不同的服务器处理而不是一致性哈希只给一台服务器处理，这样就<strong>分散了压力</strong></p>\n"},{"title":"设计模式","_content":"\n设计模式\n\n# 单例模式\n\n是一种 <font color='blue'>创建型模式</font>\n\n常用到的有 <font color = 'gree'>日志模块 数据库模块</font> \n\n一个类创建对象，不管创建多少个对象，永远只能得到该类型一个对象的示例\n\n```c++\nclass SingleTon{\npublic:\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    return &instance;\n  }\nprivate:\n  \tstatic SinleTonl instance;// 2. 定义唯一的类的实例对象\n  \tSingleTon(){ // 1 .构造函数私有化\n      \n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon SingleTon::instance; //静态成员变量 类内声明 类外初始化\n\nint main(){\n  SingleTon* s1 = SingleTon::getInstance();\n  SingleTon* s2 = SingleTon::getInstance();\n  SingleTon* s3 = SingleTon::getInstance();\n}\n// 这是饿汉式，静态成员变量在数据段，还没调用，就直接生成了\n\n// 下是懒汉式\n\nclass SingleTon{\npublic:\n  // 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入）\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    if(instance == nullptr){\n    \tinstance  = new SingleTon();\n    }\n    return instance;\n  }\nprivate:\n  \tstatic SinleTonl* instance;// 2. 定义唯一的类的实例对象\n  \tSingleTon(){ // 1 .构造函数私有化\n      \n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon SingleTon::instance = nullptr; //静态成员变量 类内声明 类外初始化\n```\n\n\n\n\n\n饿汉式单例模式 ：还没开始使用单例 就已经创建单例了 <font color='blue'>***线程安全***</font> 缺点 启动过程可能时间较长初始化\n\n懒汉式单例模式 ：获取的时候才创建  不是线程安全的代码\n\n\n\n```c++\n//线程安全的 懒汉单例模式\nstd::mutex mtx;\nclass SingleTon{\npublic:\n  // 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入\n  // 加锁 保证原子性\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    // lock_guard<std::mutex> guard(mutex); // 锁的粒度太大了，每次获取单例都要加锁，效率低\n    if(instance == nullptr){\n      lock_guard<std::mutex> guard(mutex); // 放小粒度，放到里面\n      // 1.\n      if(instance == nullptr){\n\t\t\t\tinstance  = new SingleTon();\n      }\n      // 2. instance  = new SingleTon();\n      // 选1 还是 2 ？\n      /* 缩小锁的粒度，就要锁 + 双重判断，否则 还是会发生竞态条件，比如选2\n      \t 有 A B 两个线程进来了，A，获得锁了，继续new， B未获得锁，等待\n      \t A 释放锁， B获得锁，由于没有 双重判断， 导致instance又被new了一遍\n      */\n    }\n    return instance;\n  }\nprivate:\n  \tstatic SinleTonl *volatile instance;// 2. 定义唯一的类的实例对象 \n  \tSingleTon(){ // 1 .构造函数私有化\n      \n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon *volatile SingleTon::instance = nullptr; //静态成员变量 类内声明 类外初始化\n```\n\n其中 volatile 关键字 作用是为了防止cpu执行的时候加快多线程效率直接复制 instance的值，从而导致错误，加上volatile 之后，一旦有线程修改了这个值，其他线程就立马可见了\n\n\n\n```c++\n//也是线程安全的懒汉单例模式\nclass SingleTon{\npublic:\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    // g+++ -o run singleTon.cpp gdb run\n    // 函数静态局部变量的初始化，在汇编指令上已经自动加上线程互斥指令了\n    static SingleTon instance();\n    return &instance;\n  }\nprivate:\n  \tstatic SinleTonl instance;// 2. 定义唯一的类的实例对象\n  \tSingleTon(){ // 1 .构造函数私有化\n      //很多 构造代码，\n      // 会不会有一个线程执行到一半 还没构造完成，然后有又有一个线程进来 构造？\n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon SingleTon::instance; //静态成员变量 类内声明 类外初始化\n```\n\n\n\n# 工厂\n\n要工厂模式： 主要是封装了对象的创建\n\n## 简单工厂 Simple Factory\n\n```c++\nclass Car{\npublic:\n\tCar(string name): _name(name){}\n  virtual void show() = 0;\nprotected:\n  string _name;\n};\n\nclass Bmw: public Car{\npublic:\n  Bmw(string name) : Car(name){}\n  void show(){\n   \tcout << \"获取一辆宝马\" << _name << endl; \n  }\n};\n\nclass Audi: public Car{\npublic:\n  BMW(string name) : Car(name){}\n  void show(){\n   \tcout << \"获取一辆奥迪\" << _name << endl; \n  }\n};\n\nenum CarType{\n  BMW, AUDI\n};\nclass SimpleFactory{\npublic:\n  Car* createCar(CarType ct){\n    switch(ct){\n      case BMW:\n        return new Bmw(\"X1\");\n        break;\n      case AUDI:\n        return new Audi(\"A6\");\n        break;\n        \n      default:\n        cerr << \"para error\" << endl;\n      \tbreak;\n    }\n    return nullptr;\n  }\n};\nint main(){\n\t//Car *p1 = new Bmw(\"X1\");\n  // Car *p2 = new Audi(\"A6\");\n  SimpleFactory *factory = new SimpleFactory();\n  Car *p1 = factory->createCar(BMW);\n  Car *p2 = factory->createCar(AUDI);\n  return 0;\n}\n```\n\n违反了对修改封闭，对扩展开放\n\n## 工厂方法 Factory Method\n\n在简单工厂上部加了一个抽象类\n\n```c++\nclass Factory\n{\npublic:\n  virtual Car* createCar(string name) = 0;\n}\n\nclass BMWFactory() : public Factory{\npublic:\n \tCar* createCar(string name){\n    return new Bmw(name);\n  }\n}\n\nclass AudiFactory(): public Factory{\npublic:\n  Car* createCar(string name){\n    return new Audi(name);\n  }\n}\n\nclass OtherFactory(): public Factory{\n  //对修改封闭， 对扩展开放了， 扩展 增加子类就可以\n}\n```\n\n\n\n## 抽象工厂 Abstract Factory\n\n考虑产品 一类产品 一系列有关联的产品， 汽车 灯 座椅 车架 \n\n```c++\nclass Light{\npublic:\n  virtual void show() = 0;\n};\n\nclass BmwLight: public Light{\npublic:\n  void show(){\n\tcout << \"BMW Light\" << endl;}\n};\n\nclass AudiLight: public Light{\n  void show(){\n    cout << \"Audi Light\" << endl;\n  }\n};\n\n// 工厂方法 ->抽象工厂（对一组有关联关系的产品簇提供产品对象的统一创建）\n// 把有关联的工厂方法 联合组成抽象工厂 提供多个产品的创建接口  也就是宝马的工厂不仅生产车架 也有车灯 座椅\n// 缺点 抽象工厂的各个方法都必须实现，否则子类就还是抽象类\nclass AbstractFactory{\n  public:\n  virtual Car* createCar(string name) = 0; \n  virtual Light* createCarLight() = 0;\n}\n```\n\n\n\n简单工厂 ： 把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象\n\n优点 客户不用自己创建对象，不用了解对象创建的详细过程 \n\n缺点 提供创建对象实例的接口函数不闭合 不能对修改关闭 对扩展开放\n\n工厂方法：Factory 基类 提供一个纯虚函数（创建产品 ）定义派生类 （具体产品的工厂 ）负责创建对应的产品\n\n优点 可以做到不同的产品，在不同的工厂创建，对修改关闭，扩展开放\n\n缺点 实际上很多产品是有关联关系的， 属于一个产品簇，不应该放在不同的工厂进行创建，这样一不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护\n\n\n\n抽象工厂 把有关联关系的 属于一个产品簇的所有产品的创建的接口函数，放在一个抽象工厂里面\n\n派生类 （具体产品的工厂）应该负责创建该产品簇里面的所有产品\n\n# 观察者模式\n\n观察者 监听者模式（发布订阅模式） 行为型模式 \n\n主要关注的是对象的一对多的关系， 也就是多个对象都依赖一个对象，当该对象的状态发生变化时，其他对象都能接收到相应的通知\n\nEg： 一组数据 （数据对象） -> 通过一组数据 ->  曲线图（对象1） 柱状图（对象2） 圆饼图（对象3）\n\n当数据对象改变时，对象1， 对象2 ，对象3，<font color = 'blue'>应该及时收到相应的通知！</font>\n\nSubject(主题) observer1 observer2 observer3\n\n```c++\nclass Observer{\npublic:\n  virtual void handle(int msgid) = 0;\n};\n\nclass Observer1 : public Observer{\npublic:\n  void handle(int msgid){\n    switch(msgid){\n        case 1:\n        \tcout << \"observer1 recv 1 msg\" << endl;\n        \tbreak;\n      \tcase 2:\n        \tcout << \"observer1 recv 2 msg\" << endl;\n        \tbreak;\n      \tdefault:\n        \tcout << \"observer1 recv unknown msg!\" << endl;\n       \t \tbreak;\n    }\n  }\n};\nclass Observer2 : public Observer{\npublic:\n  void handle(int msgid){\n    switch(msgid){\n      \tcase 2:\n        \tcout << \"observer2 recv 2 msg\" << endl;\n        \tbreak;\n      \tdefault:\n        \tcout << \"observer1 recv unknown msg!\" << endl;\n       \t \tbreak;\n    }\n  }\n};\n\nclass Observer3 : public Observer{\npublic:\n  void handle(int msgid){\n    switch(msgid){\n      \tcase 1:\n        \tcout << \"observer3 recv 1 msg\" << endl;\n        \tbreak;\n      \tcase 3:\n        \tcout << \"observer3 recv 3 msg\" << endl;\n        \tbreak;\n      \tdefault:\n        \tcout << \"observer3 recv unknown msg!\" << endl;\n       \t \tbreak;\n    }\n  }\n};\n\nclass Subject{\npublic:\n  void addObserver(Observer* obser, int msgid){\n    //给主题 添加观察者\n    _subMap[msgid].push_back(obser); // msgid 原先有的话直接插入，没有的话会默认构造一个，然后再插入\n  }\n  void despatch(int msg){\n    //主题检测发生改变，通知相应的观察者对象处理事件\n    auto it = _subMap.find(msgid);\n    if(it != _subMap.end()){\n      for(Observer *pObser : it->second){\n        pObser->handle(msgid);\n      }\n    }\n  }\nprivate:\n  unordered_map<int, list<Observer*>> _subMap;\n};\n```\n\n\n\n# 适配器模式\n\n结构型 模式\n\n让不同的不兼容的接口可以在一起工作 为了避免重构代码 -> 适配器模式\n\n电脑接到投影仪 -> VGA HDMI DP TypeC\n\n类比 转接口\n\n\n\n```c++\nclass VGA{\npublic:\n  virtual void play() = 0;\n};\n\nclass TV01 : public VGA{\npublic:\n  void play(){\n    cout << \"通过VGA接口投影\" << endl;\n  }\n};\n\n\n//电脑只支持VGA接口\nclass Computer{\npublic:\n  void playVideo(VGA *pVGA){ //只支持VGA接口指针\n    pVGA->play();\n  }\n};\n\n//现在新进入了一批设备 支持HDMI\nclass HDMI{\npublic:\n  virtual void play() = 0;\n};\n\nclass TV02: public HDMI{\npublic:\n  void play(){\n    cout << \"通过HDMI接口投影\" << endl;\n  }\n};\n\n//方法1 ： 换一个HDMI的电脑-> 代码重构\n//方法2 ： 买一个转接头-> 添加 适配器\n\n//电脑只支持VGA 投影仪只支持HDMI 所以需要引入适配器\nclass VGAToHDMIAdapter : public VGA{\npublic:\n  VGAToHDMIAdapter(HDMI *p): pHdmi(p){}\n  void play(){ //该方法相当于就是转接头，做不同接口的信号转换的\n\t\t\tpHdmi->play();\n  }\nprivate:\n  HDMI *PHdmi;\n};\nint main(){\n  Computer c;\n  TV01 t;\n  c.playVideo(&t);\n  c.playViceo(new VGAToHDMIAdapter(new TV02()));\n  return 0;\n}\n\n\n```\n\n\n\n\n\n# 代理模式\n\n结构型模式 Proxy 通过代理类，来控制实际对象（委托类）的访问权限\n\n客户  \t助理Proxy \t老板（委托类）\n\n​\t\t客户和老板之间的权限控制\n\n<font color ='blue'>功能都是 委托类实现的， 代理类只是权限控制， 两者是组合关系</font>\n\n客户直接访问的是代理对象，由代理对象和委托类实现不同客户的功能权限控制\n\n```c++\nclass VideoSite{\npublic:\n  virtual void freeMovie() = 0;\t//免费电影\n  virtual void vipMovie() = 0; // VIP电影\n  virtual void ticketMoveie() = 0; // 用券观看的电影\n};\n\nclass\tMyVideoSite: public VideoSite{\n  virtual void freeMovie(){ //免费电影\n    cout << \"观看免费电影\" << endl;\n  }\n  virtual void vipMovie(){ // VIP电影\n    cout << \"观看VIP电影\" << endl;\n\t} \n  virtual void ticketMoveie(){ // 用券观看的电影\n    cout << \"观看券电影\" << endl;\n\t}\n};\n\n\nclass FreeVideoSiteProxy : public VideoSite{\npublic:\n  FreeVideoSiteProxy(){\n    pVideo = new MyVideoSite();\n  }\n  ~FreeVideoSiteProxy(){\n    delete pVideo;\n  }\n  virtual void freeMovie(){ //免费电影\n    pVideo->freeMovie(); // 通过代理对象的freeMovie， 来访问真正委托类对象的方法\n  }\t\n  virtual void vipMovie(){ // VIP电影\n    cout << \"无权限\" << endl;\n\t} \n  virtual void ticketMoveie(){ // 用券观看的电影\n    cout << \"无券\" << endl;\n\t}\nprivate:\n\tVideoSite *pVideo;\n};\n\nclass VIPVideoSiteProxy : public VideoSite{\npublic:\n  VIPVideoSiteProxy(){\n    pVideo = new MyVideoSite();\n  }\n  ~FreeVideoSiteProxy(){\n    delete pVideo;\n  }\n  virtual void freeMovie(){//免费电影\n    pVideo->freeMovie(); // 通过代理对象的freeMovie， 来访问真正委托类对象的方法\n  }\t\n  virtual void vipMovie()// VIP电影{\n    pVideo->vipMovie();// 通过代理对象的vipMovie， 来访问真正委托类对象的方法\n\t} \n  virtual void ticketMoveie(){ // 用券观看的电影\n    cout << \"无券\" << endl;\n\t}\nprivate:\n\tVideoSite *pVideo;\n};\n```\n\n\n\n# 装饰器模式\n\nDecorator 结构型模式\n\n\n\n***装饰器 主要是增加现有类的功能***， 但是增加现有类的功能还有一个方法 就是新增加一个子类 -> 导致类的数量非常多\n\n```c++\nclass Car{ //抽象基类\npublic:\n  virtual void show() = 0;\n};\n\n\n//三个实体汽车类\nclass BMW :public Car{\npublic:\n  void show(){\n    cout << \"BWM 汽车 基本配置\" << endl;\n  }\n};\n\nclass AUDI :public Car{\npublic:\n  void show(){\n    cout << \"Audi 汽车 基本配置\" << endl;\n  }\n};\n\nclass Benz:public Car{\npublic:\n  void show(){\n    cout << \"Benz 汽车 基本配置\" << endl;\n  }\n};\n\n\n\n//装饰器 1 定速巡航\nclass ConcreteDecorator01: public Car{\npublic:\n  ConcreteDecorator01(Car *p): pCar(p){}\n  void show(){\n    pCar->show();\n    cour << \"定速巡航\" << endl;\n  }\nprivate:\n  Car* pCar;\n};\n//自动刹车\nclass ConcreteDecorator02: public Car{\npublic:\n  ConcreteDecorator02(Car *p): pCar(p){}\n  void show(){\n    pCar->show();\n    cour << \"自动刹车\" << endl;\n  }\nprivate:\n  Car* pCar;\n};\n\n//车道偏离\nclass ConcreteDecorator03: public Car{\npublic:\n  ConcreteDecorator03(Car *p): pCar(p){}\n  void show(){\n    pCar->show();\n    cour <<\"车道偏离\" << endl;\n  }\nprivate:\n  Car* pCar;\n};\n```\n\n\n\n","source":"_posts/设计模式.md","raw":"---\ntitle: 设计模式\n---\n\n设计模式\n\n# 单例模式\n\n是一种 <font color='blue'>创建型模式</font>\n\n常用到的有 <font color = 'gree'>日志模块 数据库模块</font> \n\n一个类创建对象，不管创建多少个对象，永远只能得到该类型一个对象的示例\n\n```c++\nclass SingleTon{\npublic:\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    return &instance;\n  }\nprivate:\n  \tstatic SinleTonl instance;// 2. 定义唯一的类的实例对象\n  \tSingleTon(){ // 1 .构造函数私有化\n      \n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon SingleTon::instance; //静态成员变量 类内声明 类外初始化\n\nint main(){\n  SingleTon* s1 = SingleTon::getInstance();\n  SingleTon* s2 = SingleTon::getInstance();\n  SingleTon* s3 = SingleTon::getInstance();\n}\n// 这是饿汉式，静态成员变量在数据段，还没调用，就直接生成了\n\n// 下是懒汉式\n\nclass SingleTon{\npublic:\n  // 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入）\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    if(instance == nullptr){\n    \tinstance  = new SingleTon();\n    }\n    return instance;\n  }\nprivate:\n  \tstatic SinleTonl* instance;// 2. 定义唯一的类的实例对象\n  \tSingleTon(){ // 1 .构造函数私有化\n      \n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon SingleTon::instance = nullptr; //静态成员变量 类内声明 类外初始化\n```\n\n\n\n\n\n饿汉式单例模式 ：还没开始使用单例 就已经创建单例了 <font color='blue'>***线程安全***</font> 缺点 启动过程可能时间较长初始化\n\n懒汉式单例模式 ：获取的时候才创建  不是线程安全的代码\n\n\n\n```c++\n//线程安全的 懒汉单例模式\nstd::mutex mtx;\nclass SingleTon{\npublic:\n  // 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入\n  // 加锁 保证原子性\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    // lock_guard<std::mutex> guard(mutex); // 锁的粒度太大了，每次获取单例都要加锁，效率低\n    if(instance == nullptr){\n      lock_guard<std::mutex> guard(mutex); // 放小粒度，放到里面\n      // 1.\n      if(instance == nullptr){\n\t\t\t\tinstance  = new SingleTon();\n      }\n      // 2. instance  = new SingleTon();\n      // 选1 还是 2 ？\n      /* 缩小锁的粒度，就要锁 + 双重判断，否则 还是会发生竞态条件，比如选2\n      \t 有 A B 两个线程进来了，A，获得锁了，继续new， B未获得锁，等待\n      \t A 释放锁， B获得锁，由于没有 双重判断， 导致instance又被new了一遍\n      */\n    }\n    return instance;\n  }\nprivate:\n  \tstatic SinleTonl *volatile instance;// 2. 定义唯一的类的实例对象 \n  \tSingleTon(){ // 1 .构造函数私有化\n      \n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon *volatile SingleTon::instance = nullptr; //静态成员变量 类内声明 类外初始化\n```\n\n其中 volatile 关键字 作用是为了防止cpu执行的时候加快多线程效率直接复制 instance的值，从而导致错误，加上volatile 之后，一旦有线程修改了这个值，其他线程就立马可见了\n\n\n\n```c++\n//也是线程安全的懒汉单例模式\nclass SingleTon{\npublic:\n  static SingleTon* getInstace(){ //3. 获取类的唯一实例对象的接口方法\n    // g+++ -o run singleTon.cpp gdb run\n    // 函数静态局部变量的初始化，在汇编指令上已经自动加上线程互斥指令了\n    static SingleTon instance();\n    return &instance;\n  }\nprivate:\n  \tstatic SinleTonl instance;// 2. 定义唯一的类的实例对象\n  \tSingleTon(){ // 1 .构造函数私有化\n      //很多 构造代码，\n      // 会不会有一个线程执行到一半 还没构造完成，然后有又有一个线程进来 构造？\n    }\n  \tSingleTon(const SingleTon&) = delete;\n  \tSingleTon& operator=(const Single&) = delete; //限制构造方式 只能是默认的私有构造\n};\nSingleTon SingleTon::instance; //静态成员变量 类内声明 类外初始化\n```\n\n\n\n# 工厂\n\n要工厂模式： 主要是封装了对象的创建\n\n## 简单工厂 Simple Factory\n\n```c++\nclass Car{\npublic:\n\tCar(string name): _name(name){}\n  virtual void show() = 0;\nprotected:\n  string _name;\n};\n\nclass Bmw: public Car{\npublic:\n  Bmw(string name) : Car(name){}\n  void show(){\n   \tcout << \"获取一辆宝马\" << _name << endl; \n  }\n};\n\nclass Audi: public Car{\npublic:\n  BMW(string name) : Car(name){}\n  void show(){\n   \tcout << \"获取一辆奥迪\" << _name << endl; \n  }\n};\n\nenum CarType{\n  BMW, AUDI\n};\nclass SimpleFactory{\npublic:\n  Car* createCar(CarType ct){\n    switch(ct){\n      case BMW:\n        return new Bmw(\"X1\");\n        break;\n      case AUDI:\n        return new Audi(\"A6\");\n        break;\n        \n      default:\n        cerr << \"para error\" << endl;\n      \tbreak;\n    }\n    return nullptr;\n  }\n};\nint main(){\n\t//Car *p1 = new Bmw(\"X1\");\n  // Car *p2 = new Audi(\"A6\");\n  SimpleFactory *factory = new SimpleFactory();\n  Car *p1 = factory->createCar(BMW);\n  Car *p2 = factory->createCar(AUDI);\n  return 0;\n}\n```\n\n违反了对修改封闭，对扩展开放\n\n## 工厂方法 Factory Method\n\n在简单工厂上部加了一个抽象类\n\n```c++\nclass Factory\n{\npublic:\n  virtual Car* createCar(string name) = 0;\n}\n\nclass BMWFactory() : public Factory{\npublic:\n \tCar* createCar(string name){\n    return new Bmw(name);\n  }\n}\n\nclass AudiFactory(): public Factory{\npublic:\n  Car* createCar(string name){\n    return new Audi(name);\n  }\n}\n\nclass OtherFactory(): public Factory{\n  //对修改封闭， 对扩展开放了， 扩展 增加子类就可以\n}\n```\n\n\n\n## 抽象工厂 Abstract Factory\n\n考虑产品 一类产品 一系列有关联的产品， 汽车 灯 座椅 车架 \n\n```c++\nclass Light{\npublic:\n  virtual void show() = 0;\n};\n\nclass BmwLight: public Light{\npublic:\n  void show(){\n\tcout << \"BMW Light\" << endl;}\n};\n\nclass AudiLight: public Light{\n  void show(){\n    cout << \"Audi Light\" << endl;\n  }\n};\n\n// 工厂方法 ->抽象工厂（对一组有关联关系的产品簇提供产品对象的统一创建）\n// 把有关联的工厂方法 联合组成抽象工厂 提供多个产品的创建接口  也就是宝马的工厂不仅生产车架 也有车灯 座椅\n// 缺点 抽象工厂的各个方法都必须实现，否则子类就还是抽象类\nclass AbstractFactory{\n  public:\n  virtual Car* createCar(string name) = 0; \n  virtual Light* createCarLight() = 0;\n}\n```\n\n\n\n简单工厂 ： 把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象\n\n优点 客户不用自己创建对象，不用了解对象创建的详细过程 \n\n缺点 提供创建对象实例的接口函数不闭合 不能对修改关闭 对扩展开放\n\n工厂方法：Factory 基类 提供一个纯虚函数（创建产品 ）定义派生类 （具体产品的工厂 ）负责创建对应的产品\n\n优点 可以做到不同的产品，在不同的工厂创建，对修改关闭，扩展开放\n\n缺点 实际上很多产品是有关联关系的， 属于一个产品簇，不应该放在不同的工厂进行创建，这样一不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护\n\n\n\n抽象工厂 把有关联关系的 属于一个产品簇的所有产品的创建的接口函数，放在一个抽象工厂里面\n\n派生类 （具体产品的工厂）应该负责创建该产品簇里面的所有产品\n\n# 观察者模式\n\n观察者 监听者模式（发布订阅模式） 行为型模式 \n\n主要关注的是对象的一对多的关系， 也就是多个对象都依赖一个对象，当该对象的状态发生变化时，其他对象都能接收到相应的通知\n\nEg： 一组数据 （数据对象） -> 通过一组数据 ->  曲线图（对象1） 柱状图（对象2） 圆饼图（对象3）\n\n当数据对象改变时，对象1， 对象2 ，对象3，<font color = 'blue'>应该及时收到相应的通知！</font>\n\nSubject(主题) observer1 observer2 observer3\n\n```c++\nclass Observer{\npublic:\n  virtual void handle(int msgid) = 0;\n};\n\nclass Observer1 : public Observer{\npublic:\n  void handle(int msgid){\n    switch(msgid){\n        case 1:\n        \tcout << \"observer1 recv 1 msg\" << endl;\n        \tbreak;\n      \tcase 2:\n        \tcout << \"observer1 recv 2 msg\" << endl;\n        \tbreak;\n      \tdefault:\n        \tcout << \"observer1 recv unknown msg!\" << endl;\n       \t \tbreak;\n    }\n  }\n};\nclass Observer2 : public Observer{\npublic:\n  void handle(int msgid){\n    switch(msgid){\n      \tcase 2:\n        \tcout << \"observer2 recv 2 msg\" << endl;\n        \tbreak;\n      \tdefault:\n        \tcout << \"observer1 recv unknown msg!\" << endl;\n       \t \tbreak;\n    }\n  }\n};\n\nclass Observer3 : public Observer{\npublic:\n  void handle(int msgid){\n    switch(msgid){\n      \tcase 1:\n        \tcout << \"observer3 recv 1 msg\" << endl;\n        \tbreak;\n      \tcase 3:\n        \tcout << \"observer3 recv 3 msg\" << endl;\n        \tbreak;\n      \tdefault:\n        \tcout << \"observer3 recv unknown msg!\" << endl;\n       \t \tbreak;\n    }\n  }\n};\n\nclass Subject{\npublic:\n  void addObserver(Observer* obser, int msgid){\n    //给主题 添加观察者\n    _subMap[msgid].push_back(obser); // msgid 原先有的话直接插入，没有的话会默认构造一个，然后再插入\n  }\n  void despatch(int msg){\n    //主题检测发生改变，通知相应的观察者对象处理事件\n    auto it = _subMap.find(msgid);\n    if(it != _subMap.end()){\n      for(Observer *pObser : it->second){\n        pObser->handle(msgid);\n      }\n    }\n  }\nprivate:\n  unordered_map<int, list<Observer*>> _subMap;\n};\n```\n\n\n\n# 适配器模式\n\n结构型 模式\n\n让不同的不兼容的接口可以在一起工作 为了避免重构代码 -> 适配器模式\n\n电脑接到投影仪 -> VGA HDMI DP TypeC\n\n类比 转接口\n\n\n\n```c++\nclass VGA{\npublic:\n  virtual void play() = 0;\n};\n\nclass TV01 : public VGA{\npublic:\n  void play(){\n    cout << \"通过VGA接口投影\" << endl;\n  }\n};\n\n\n//电脑只支持VGA接口\nclass Computer{\npublic:\n  void playVideo(VGA *pVGA){ //只支持VGA接口指针\n    pVGA->play();\n  }\n};\n\n//现在新进入了一批设备 支持HDMI\nclass HDMI{\npublic:\n  virtual void play() = 0;\n};\n\nclass TV02: public HDMI{\npublic:\n  void play(){\n    cout << \"通过HDMI接口投影\" << endl;\n  }\n};\n\n//方法1 ： 换一个HDMI的电脑-> 代码重构\n//方法2 ： 买一个转接头-> 添加 适配器\n\n//电脑只支持VGA 投影仪只支持HDMI 所以需要引入适配器\nclass VGAToHDMIAdapter : public VGA{\npublic:\n  VGAToHDMIAdapter(HDMI *p): pHdmi(p){}\n  void play(){ //该方法相当于就是转接头，做不同接口的信号转换的\n\t\t\tpHdmi->play();\n  }\nprivate:\n  HDMI *PHdmi;\n};\nint main(){\n  Computer c;\n  TV01 t;\n  c.playVideo(&t);\n  c.playViceo(new VGAToHDMIAdapter(new TV02()));\n  return 0;\n}\n\n\n```\n\n\n\n\n\n# 代理模式\n\n结构型模式 Proxy 通过代理类，来控制实际对象（委托类）的访问权限\n\n客户  \t助理Proxy \t老板（委托类）\n\n​\t\t客户和老板之间的权限控制\n\n<font color ='blue'>功能都是 委托类实现的， 代理类只是权限控制， 两者是组合关系</font>\n\n客户直接访问的是代理对象，由代理对象和委托类实现不同客户的功能权限控制\n\n```c++\nclass VideoSite{\npublic:\n  virtual void freeMovie() = 0;\t//免费电影\n  virtual void vipMovie() = 0; // VIP电影\n  virtual void ticketMoveie() = 0; // 用券观看的电影\n};\n\nclass\tMyVideoSite: public VideoSite{\n  virtual void freeMovie(){ //免费电影\n    cout << \"观看免费电影\" << endl;\n  }\n  virtual void vipMovie(){ // VIP电影\n    cout << \"观看VIP电影\" << endl;\n\t} \n  virtual void ticketMoveie(){ // 用券观看的电影\n    cout << \"观看券电影\" << endl;\n\t}\n};\n\n\nclass FreeVideoSiteProxy : public VideoSite{\npublic:\n  FreeVideoSiteProxy(){\n    pVideo = new MyVideoSite();\n  }\n  ~FreeVideoSiteProxy(){\n    delete pVideo;\n  }\n  virtual void freeMovie(){ //免费电影\n    pVideo->freeMovie(); // 通过代理对象的freeMovie， 来访问真正委托类对象的方法\n  }\t\n  virtual void vipMovie(){ // VIP电影\n    cout << \"无权限\" << endl;\n\t} \n  virtual void ticketMoveie(){ // 用券观看的电影\n    cout << \"无券\" << endl;\n\t}\nprivate:\n\tVideoSite *pVideo;\n};\n\nclass VIPVideoSiteProxy : public VideoSite{\npublic:\n  VIPVideoSiteProxy(){\n    pVideo = new MyVideoSite();\n  }\n  ~FreeVideoSiteProxy(){\n    delete pVideo;\n  }\n  virtual void freeMovie(){//免费电影\n    pVideo->freeMovie(); // 通过代理对象的freeMovie， 来访问真正委托类对象的方法\n  }\t\n  virtual void vipMovie()// VIP电影{\n    pVideo->vipMovie();// 通过代理对象的vipMovie， 来访问真正委托类对象的方法\n\t} \n  virtual void ticketMoveie(){ // 用券观看的电影\n    cout << \"无券\" << endl;\n\t}\nprivate:\n\tVideoSite *pVideo;\n};\n```\n\n\n\n# 装饰器模式\n\nDecorator 结构型模式\n\n\n\n***装饰器 主要是增加现有类的功能***， 但是增加现有类的功能还有一个方法 就是新增加一个子类 -> 导致类的数量非常多\n\n```c++\nclass Car{ //抽象基类\npublic:\n  virtual void show() = 0;\n};\n\n\n//三个实体汽车类\nclass BMW :public Car{\npublic:\n  void show(){\n    cout << \"BWM 汽车 基本配置\" << endl;\n  }\n};\n\nclass AUDI :public Car{\npublic:\n  void show(){\n    cout << \"Audi 汽车 基本配置\" << endl;\n  }\n};\n\nclass Benz:public Car{\npublic:\n  void show(){\n    cout << \"Benz 汽车 基本配置\" << endl;\n  }\n};\n\n\n\n//装饰器 1 定速巡航\nclass ConcreteDecorator01: public Car{\npublic:\n  ConcreteDecorator01(Car *p): pCar(p){}\n  void show(){\n    pCar->show();\n    cour << \"定速巡航\" << endl;\n  }\nprivate:\n  Car* pCar;\n};\n//自动刹车\nclass ConcreteDecorator02: public Car{\npublic:\n  ConcreteDecorator02(Car *p): pCar(p){}\n  void show(){\n    pCar->show();\n    cour << \"自动刹车\" << endl;\n  }\nprivate:\n  Car* pCar;\n};\n\n//车道偏离\nclass ConcreteDecorator03: public Car{\npublic:\n  ConcreteDecorator03(Car *p): pCar(p){}\n  void show(){\n    pCar->show();\n    cour <<\"车道偏离\" << endl;\n  }\nprivate:\n  Car* pCar;\n};\n```\n\n\n\n","slug":"设计模式","published":1,"date":"2024-04-12T13:02:32.862Z","updated":"2024-05-12T15:14:51.825Z","_id":"cluwq56wc00070cvk1oloeej8","comments":1,"layout":"post","photos":[],"content":"<p>设计模式</p>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>是一种 <font color='blue'>创建型模式</font></p>\n<p>常用到的有 <font color = 'gree'>日志模块 数据库模块</font> </p>\n<p>一个类创建对象，不管创建多少个对象，永远只能得到该类型一个对象的示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象</span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon SingleTon::instance; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  SingleTon* s1 = SingleTon::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">  SingleTon* s2 = SingleTon::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">  SingleTon* s3 = SingleTon::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这是饿汉式，静态成员变量在数据段，还没调用，就直接生成了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下是懒汉式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">    \tinstance  = <span class=\"keyword\">new</span> <span class=\"built_in\">SingleTon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl* instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象</span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon SingleTon::instance = <span class=\"literal\">nullptr</span>; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>饿汉式单例模式 ：还没开始使用单例 就已经创建单例了 <font color='blue'><em><strong>线程安全</strong></em></font> 缺点 启动过程可能时间较长初始化</p>\n<p>懒汉式单例模式 ：获取的时候才创建  不是线程安全的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程安全的 懒汉单例模式</span></span><br><span class=\"line\">std::mutex mtx;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入</span></span><br><span class=\"line\">  <span class=\"comment\">// 加锁 保证原子性</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"comment\">// lock_guard&lt;std::mutex&gt; guard(mutex); // 锁的粒度太大了，每次获取单例都要加锁，效率低</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">      <span class=\"function\">lock_guard&lt;std::mutex&gt; <span class=\"title\">guard</span><span class=\"params\">(mutex)</span></span>; <span class=\"comment\">// 放小粒度，放到里面</span></span><br><span class=\"line\">      <span class=\"comment\">// 1.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(instance == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">\t\t\t\tinstance  = <span class=\"keyword\">new</span> <span class=\"built_in\">SingleTon</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 2. instance  = new SingleTon();</span></span><br><span class=\"line\">      <span class=\"comment\">// 选1 还是 2 ？</span></span><br><span class=\"line\">      <span class=\"comment\">/* 缩小锁的粒度，就要锁 + 双重判断，否则 还是会发生竞态条件，比如选2</span></span><br><span class=\"line\"><span class=\"comment\">      \t 有 A B 两个线程进来了，A，获得锁了，继续new， B未获得锁，等待</span></span><br><span class=\"line\"><span class=\"comment\">      \t A 释放锁， B获得锁，由于没有 双重判断， 导致instance又被new了一遍</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl *<span class=\"keyword\">volatile</span> instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象 </span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon *<span class=\"keyword\">volatile</span> SingleTon::instance = <span class=\"literal\">nullptr</span>; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 volatile 关键字 作用是为了防止cpu执行的时候加快多线程效率直接复制 instance的值，从而导致错误，加上volatile 之后，一旦有线程修改了这个值，其他线程就立马可见了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//也是线程安全的懒汉单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"comment\">// g+++ -o run singleTon.cpp gdb run</span></span><br><span class=\"line\">    <span class=\"comment\">// 函数静态局部变量的初始化，在汇编指令上已经自动加上线程互斥指令了</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> SingleTon <span class=\"title\">instance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象</span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      <span class=\"comment\">//很多 构造代码，</span></span><br><span class=\"line\">      <span class=\"comment\">// 会不会有一个线程执行到一半 还没构造完成，然后有又有一个线程进来 构造？</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon SingleTon::instance; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"工厂\"><a href=\"#工厂\" class=\"headerlink\" title=\"工厂\"></a>工厂</h1><p>要工厂模式： 主要是封装了对象的创建</p>\n<h2 id=\"简单工厂-Simple-Factory\"><a href=\"#简单工厂-Simple-Factory\" class=\"headerlink\" title=\"简单工厂 Simple Factory\"></a>简单工厂 Simple Factory</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Car</span>(string name): _name(name)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  string _name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bmw</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Bmw</span>(string name) : <span class=\"built_in\">Car</span>(name)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \tcout &lt;&lt; <span class=\"string\">&quot;获取一辆宝马&quot;</span> &lt;&lt; _name &lt;&lt; endl; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Audi</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">BMW</span>(string name) : <span class=\"built_in\">Car</span>(name)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \tcout &lt;&lt; <span class=\"string\">&quot;获取一辆奥迪&quot;</span> &lt;&lt; _name &lt;&lt; endl; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">CarType</span>&#123;</span><br><span class=\"line\">  BMW, AUDI</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SimpleFactory</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">Car* <span class=\"title\">createCar</span><span class=\"params\">(CarType ct)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(ct)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> BMW:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Bmw</span>(<span class=\"string\">&quot;X1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> AUDI:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Audi</span>(<span class=\"string\">&quot;A6&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;para error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">      \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//Car *p1 = new Bmw(&quot;X1&quot;);</span></span><br><span class=\"line\">  <span class=\"comment\">// Car *p2 = new Audi(&quot;A6&quot;);</span></span><br><span class=\"line\">  SimpleFactory *factory = <span class=\"keyword\">new</span> <span class=\"built_in\">SimpleFactory</span>();</span><br><span class=\"line\">  Car *p1 = factory-&gt;<span class=\"built_in\">createCar</span>(BMW);</span><br><span class=\"line\">  Car *p2 = factory-&gt;<span class=\"built_in\">createCar</span>(AUDI);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>违反了对修改封闭，对扩展开放</p>\n<h2 id=\"工厂方法-Factory-Method\"><a href=\"#工厂方法-Factory-Method\" class=\"headerlink\" title=\"工厂方法 Factory Method\"></a>工厂方法 Factory Method</h2><p>在简单工厂上部加了一个抽象类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">BMWFactory</span><span class=\"params\">()</span> : public Factory&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> \t<span class=\"function\">Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Bmw</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">AudiFactory</span><span class=\"params\">()</span>: public Factory&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Audi</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">OtherFactory</span><span class=\"params\">()</span>: public Factory&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//对修改封闭， 对扩展开放了， 扩展 增加子类就可以</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"抽象工厂-Abstract-Factory\"><a href=\"#抽象工厂-Abstract-Factory\" class=\"headerlink\" title=\"抽象工厂 Abstract Factory\"></a>抽象工厂 Abstract Factory</h2><p>考虑产品 一类产品 一系列有关联的产品， 汽车 灯 座椅 车架 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Light</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BmwLight</span>: <span class=\"keyword\">public</span> Light&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;BMW Light&quot;</span> &lt;&lt; endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AudiLight</span>: <span class=\"keyword\">public</span> Light&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Audi Light&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂方法 -&gt;抽象工厂（对一组有关联关系的产品簇提供产品对象的统一创建）</span></span><br><span class=\"line\"><span class=\"comment\">// 把有关联的工厂方法 联合组成抽象工厂 提供多个产品的创建接口  也就是宝马的工厂不仅生产车架 也有车灯 座椅</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点 抽象工厂的各个方法都必须实现，否则子类就还是抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AbstractFactory</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span> </span>= <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> Light* <span class=\"title\">createCarLight</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>简单工厂 ： 把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象</p>\n<p>优点 客户不用自己创建对象，不用了解对象创建的详细过程 </p>\n<p>缺点 提供创建对象实例的接口函数不闭合 不能对修改关闭 对扩展开放</p>\n<p>工厂方法：Factory 基类 提供一个纯虚函数（创建产品 ）定义派生类 （具体产品的工厂 ）负责创建对应的产品</p>\n<p>优点 可以做到不同的产品，在不同的工厂创建，对修改关闭，扩展开放</p>\n<p>缺点 实际上很多产品是有关联关系的， 属于一个产品簇，不应该放在不同的工厂进行创建，这样一不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护</p>\n<p>抽象工厂 把有关联关系的 属于一个产品簇的所有产品的创建的接口函数，放在一个抽象工厂里面</p>\n<p>派生类 （具体产品的工厂）应该负责创建该产品簇里面的所有产品</p>\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>观察者 监听者模式（发布订阅模式） 行为型模式 </p>\n<p>主要关注的是对象的一对多的关系， 也就是多个对象都依赖一个对象，当该对象的状态发生变化时，其他对象都能接收到相应的通知</p>\n<p>Eg： 一组数据 （数据对象） -&gt; 通过一组数据 -&gt;  曲线图（对象1） 柱状图（对象2） 圆饼图（对象3）</p>\n<p>当数据对象改变时，对象1， 对象2 ，对象3，<font color = 'blue'>应该及时收到相应的通知！</font></p>\n<p>Subject(主题) observer1 observer2 observer3</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer1</span> : <span class=\"keyword\">public</span> Observer&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(msgid)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       \t \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer2</span> : <span class=\"keyword\">public</span> Observer&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(msgid)&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer2 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       \t \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer3</span> : <span class=\"keyword\">public</span> Observer&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(msgid)&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer3 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer3 recv 3 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer3 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       \t \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Subject</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer* obser, <span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//给主题 添加观察者</span></span><br><span class=\"line\">    _subMap[msgid].<span class=\"built_in\">push_back</span>(obser); <span class=\"comment\">// msgid 原先有的话直接插入，没有的话会默认构造一个，然后再插入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">despatch</span><span class=\"params\">(<span class=\"type\">int</span> msg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//主题检测发生改变，通知相应的观察者对象处理事件</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = _subMap.<span class=\"built_in\">find</span>(msgid);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it != _subMap.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Observer *pObser : it-&gt;second)&#123;</span><br><span class=\"line\">        pObser-&gt;<span class=\"built_in\">handle</span>(msgid);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  unordered_map&lt;<span class=\"type\">int</span>, list&lt;Observer*&gt;&gt; _subMap;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><p>结构型 模式</p>\n<p>让不同的不兼容的接口可以在一起工作 为了避免重构代码 -&gt; 适配器模式</p>\n<p>电脑接到投影仪 -&gt; VGA HDMI DP TypeC</p>\n<p>类比 转接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGA</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TV01</span> : <span class=\"keyword\">public</span> VGA&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;通过VGA接口投影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//电脑只支持VGA接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Computer</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">playVideo</span><span class=\"params\">(VGA *pVGA)</span></span>&#123; <span class=\"comment\">//只支持VGA接口指针</span></span><br><span class=\"line\">    pVGA-&gt;<span class=\"built_in\">play</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在新进入了一批设备 支持HDMI</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HDMI</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TV02</span>: <span class=\"keyword\">public</span> HDMI&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;通过HDMI接口投影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法1 ： 换一个HDMI的电脑-&gt; 代码重构</span></span><br><span class=\"line\"><span class=\"comment\">//方法2 ： 买一个转接头-&gt; 添加 适配器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//电脑只支持VGA 投影仪只支持HDMI 所以需要引入适配器</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGAToHDMIAdapter</span> : <span class=\"keyword\">public</span> VGA&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">VGAToHDMIAdapter</span>(HDMI *p): <span class=\"built_in\">pHdmi</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//该方法相当于就是转接头，做不同接口的信号转换的</span></span><br><span class=\"line\">\t\t\tpHdmi-&gt;<span class=\"built_in\">play</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  HDMI *PHdmi;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Computer c;</span><br><span class=\"line\">  TV01 t;</span><br><span class=\"line\">  c.<span class=\"built_in\">playVideo</span>(&amp;t);</span><br><span class=\"line\">  c.<span class=\"built_in\">playViceo</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">VGAToHDMIAdapter</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">TV02</span>()));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>结构型模式 Proxy 通过代理类，来控制实际对象（委托类）的访问权限</p>\n<p>客户  \t助理Proxy \t老板（委托类）</p>\n<p>​\t\t客户和老板之间的权限控制</p>\n<p><font color ='blue'>功能都是 委托类实现的， 代理类只是权限控制， 两者是组合关系</font></p>\n<p>客户直接访问的是代理对象，由代理对象和委托类实现不同客户的功能权限控制</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VideoSite</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;\t<span class=\"comment\">//免费电影</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// VIP电影</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span>\t<span class=\"title class_\">MyVideoSite</span>: <span class=\"keyword\">public</span> VideoSite&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//免费电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;观看免费电影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// VIP电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;观看VIP电影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;观看券电影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FreeVideoSiteProxy</span> : <span class=\"keyword\">public</span> VideoSite&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">FreeVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    pVideo = <span class=\"keyword\">new</span> <span class=\"built_in\">MyVideoSite</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~<span class=\"built_in\">FreeVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pVideo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//免费电影</span></span><br><span class=\"line\">    pVideo-&gt;<span class=\"built_in\">freeMovie</span>(); <span class=\"comment\">// 通过代理对象的freeMovie， 来访问真正委托类对象的方法</span></span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// VIP电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;无权限&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;无券&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVideoSite *pVideo;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VIPVideoSiteProxy</span> : <span class=\"keyword\">public</span> VideoSite&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">VIPVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    pVideo = <span class=\"keyword\">new</span> <span class=\"built_in\">MyVideoSite</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~<span class=\"built_in\">FreeVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pVideo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//免费电影</span></span><br><span class=\"line\">    pVideo-&gt;<span class=\"built_in\">freeMovie</span>(); <span class=\"comment\">// 通过代理对象的freeMovie， 来访问真正委托类对象的方法</span></span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span><span class=\"comment\">// VIP电影&#123;</span></span></span><br><span class=\"line\"><span class=\"function\">    pVideo-&gt;<span class=\"title\">vipMovie</span><span class=\"params\">()</span></span>;<span class=\"comment\">// 通过代理对象的vipMovie， 来访问真正委托类对象的方法</span></span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;无券&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVideoSite *pVideo;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h1><p>Decorator 结构型模式</p>\n<p><em><strong>装饰器 主要是增加现有类的功能</strong></em>， 但是增加现有类的功能还有一个方法 就是新增加一个子类 -&gt; 导致类的数量非常多</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span>&#123; <span class=\"comment\">//抽象基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//三个实体汽车类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BMW</span> :<span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;BWM 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AUDI</span> :<span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Audi 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Benz</span>:<span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Benz 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//装饰器 1 定速巡航</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteDecorator01</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">ConcreteDecorator01</span>(Car *p): <span class=\"built_in\">pCar</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pCar-&gt;<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cour &lt;&lt; <span class=\"string\">&quot;定速巡航&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Car* pCar;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//自动刹车</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteDecorator02</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">ConcreteDecorator02</span>(Car *p): <span class=\"built_in\">pCar</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pCar-&gt;<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cour &lt;&lt; <span class=\"string\">&quot;自动刹车&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Car* pCar;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//车道偏离</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteDecorator03</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">ConcreteDecorator03</span>(Car *p): <span class=\"built_in\">pCar</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pCar-&gt;<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cour &lt;&lt;<span class=\"string\">&quot;车道偏离&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Car* pCar;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n","cover":false,"excerpt":"","more":"<p>设计模式</p>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>是一种 <font color='blue'>创建型模式</font></p>\n<p>常用到的有 <font color = 'gree'>日志模块 数据库模块</font> </p>\n<p>一个类创建对象，不管创建多少个对象，永远只能得到该类型一个对象的示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象</span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon SingleTon::instance; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  SingleTon* s1 = SingleTon::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">  SingleTon* s2 = SingleTon::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">  SingleTon* s3 = SingleTon::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这是饿汉式，静态成员变量在数据段，还没调用，就直接生成了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下是懒汉式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入）</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">    \tinstance  = <span class=\"keyword\">new</span> <span class=\"built_in\">SingleTon</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl* instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象</span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon SingleTon::instance = <span class=\"literal\">nullptr</span>; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>饿汉式单例模式 ：还没开始使用单例 就已经创建单例了 <font color='blue'><em><strong>线程安全</strong></em></font> 缺点 启动过程可能时间较长初始化</p>\n<p>懒汉式单例模式 ：获取的时候才创建  不是线程安全的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程安全的 懒汉单例模式</span></span><br><span class=\"line\">std::mutex mtx;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// 是不是可重入 是不是线程安全（如果在多线程环境下，不会发生竞态条件，就是可重入</span></span><br><span class=\"line\">  <span class=\"comment\">// 加锁 保证原子性</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"comment\">// lock_guard&lt;std::mutex&gt; guard(mutex); // 锁的粒度太大了，每次获取单例都要加锁，效率低</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">      <span class=\"function\">lock_guard&lt;std::mutex&gt; <span class=\"title\">guard</span><span class=\"params\">(mutex)</span></span>; <span class=\"comment\">// 放小粒度，放到里面</span></span><br><span class=\"line\">      <span class=\"comment\">// 1.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(instance == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">\t\t\t\tinstance  = <span class=\"keyword\">new</span> <span class=\"built_in\">SingleTon</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 2. instance  = new SingleTon();</span></span><br><span class=\"line\">      <span class=\"comment\">// 选1 还是 2 ？</span></span><br><span class=\"line\">      <span class=\"comment\">/* 缩小锁的粒度，就要锁 + 双重判断，否则 还是会发生竞态条件，比如选2</span></span><br><span class=\"line\"><span class=\"comment\">      \t 有 A B 两个线程进来了，A，获得锁了，继续new， B未获得锁，等待</span></span><br><span class=\"line\"><span class=\"comment\">      \t A 释放锁， B获得锁，由于没有 双重判断， 导致instance又被new了一遍</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl *<span class=\"keyword\">volatile</span> instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象 </span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon *<span class=\"keyword\">volatile</span> SingleTon::instance = <span class=\"literal\">nullptr</span>; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 volatile 关键字 作用是为了防止cpu执行的时候加快多线程效率直接复制 instance的值，从而导致错误，加上volatile 之后，一旦有线程修改了这个值，其他线程就立马可见了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//也是线程安全的懒汉单例模式</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">static</span> SingleTon* <span class=\"title\">getInstace</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//3. 获取类的唯一实例对象的接口方法</span></span><br><span class=\"line\">    <span class=\"comment\">// g+++ -o run singleTon.cpp gdb run</span></span><br><span class=\"line\">    <span class=\"comment\">// 函数静态局部变量的初始化，在汇编指令上已经自动加上线程互斥指令了</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> SingleTon <span class=\"title\">instance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  \t<span class=\"type\">static</span> SinleTonl instance;<span class=\"comment\">// 2. 定义唯一的类的实例对象</span></span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>()&#123; <span class=\"comment\">// 1 .构造函数私有化</span></span><br><span class=\"line\">      <span class=\"comment\">//很多 构造代码，</span></span><br><span class=\"line\">      <span class=\"comment\">// 会不会有一个线程执行到一半 还没构造完成，然后有又有一个线程进来 构造？</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">  \tSingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Single&amp;) = <span class=\"keyword\">delete</span>; <span class=\"comment\">//限制构造方式 只能是默认的私有构造</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SingleTon SingleTon::instance; <span class=\"comment\">//静态成员变量 类内声明 类外初始化</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"工厂\"><a href=\"#工厂\" class=\"headerlink\" title=\"工厂\"></a>工厂</h1><p>要工厂模式： 主要是封装了对象的创建</p>\n<h2 id=\"简单工厂-Simple-Factory\"><a href=\"#简单工厂-Simple-Factory\" class=\"headerlink\" title=\"简单工厂 Simple Factory\"></a>简单工厂 Simple Factory</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Car</span>(string name): _name(name)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  string _name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bmw</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">Bmw</span>(string name) : <span class=\"built_in\">Car</span>(name)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \tcout &lt;&lt; <span class=\"string\">&quot;获取一辆宝马&quot;</span> &lt;&lt; _name &lt;&lt; endl; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Audi</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">BMW</span>(string name) : <span class=\"built_in\">Car</span>(name)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   \tcout &lt;&lt; <span class=\"string\">&quot;获取一辆奥迪&quot;</span> &lt;&lt; _name &lt;&lt; endl; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">CarType</span>&#123;</span><br><span class=\"line\">  BMW, AUDI</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SimpleFactory</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">Car* <span class=\"title\">createCar</span><span class=\"params\">(CarType ct)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(ct)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> BMW:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Bmw</span>(<span class=\"string\">&quot;X1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> AUDI:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Audi</span>(<span class=\"string\">&quot;A6&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;para error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">      \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//Car *p1 = new Bmw(&quot;X1&quot;);</span></span><br><span class=\"line\">  <span class=\"comment\">// Car *p2 = new Audi(&quot;A6&quot;);</span></span><br><span class=\"line\">  SimpleFactory *factory = <span class=\"keyword\">new</span> <span class=\"built_in\">SimpleFactory</span>();</span><br><span class=\"line\">  Car *p1 = factory-&gt;<span class=\"built_in\">createCar</span>(BMW);</span><br><span class=\"line\">  Car *p2 = factory-&gt;<span class=\"built_in\">createCar</span>(AUDI);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>违反了对修改封闭，对扩展开放</p>\n<h2 id=\"工厂方法-Factory-Method\"><a href=\"#工厂方法-Factory-Method\" class=\"headerlink\" title=\"工厂方法 Factory Method\"></a>工厂方法 Factory Method</h2><p>在简单工厂上部加了一个抽象类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">BMWFactory</span><span class=\"params\">()</span> : public Factory&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"> \t<span class=\"function\">Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Bmw</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">AudiFactory</span><span class=\"params\">()</span>: public Factory&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\">Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Audi</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">OtherFactory</span><span class=\"params\">()</span>: public Factory&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//对修改封闭， 对扩展开放了， 扩展 增加子类就可以</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"抽象工厂-Abstract-Factory\"><a href=\"#抽象工厂-Abstract-Factory\" class=\"headerlink\" title=\"抽象工厂 Abstract Factory\"></a>抽象工厂 Abstract Factory</h2><p>考虑产品 一类产品 一系列有关联的产品， 汽车 灯 座椅 车架 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Light</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BmwLight</span>: <span class=\"keyword\">public</span> Light&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;BMW Light&quot;</span> &lt;&lt; endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AudiLight</span>: <span class=\"keyword\">public</span> Light&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Audi Light&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂方法 -&gt;抽象工厂（对一组有关联关系的产品簇提供产品对象的统一创建）</span></span><br><span class=\"line\"><span class=\"comment\">// 把有关联的工厂方法 联合组成抽象工厂 提供多个产品的创建接口  也就是宝马的工厂不仅生产车架 也有车灯 座椅</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点 抽象工厂的各个方法都必须实现，否则子类就还是抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AbstractFactory</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> Car* <span class=\"title\">createCar</span><span class=\"params\">(string name)</span> </span>= <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> Light* <span class=\"title\">createCarLight</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>简单工厂 ： 把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象</p>\n<p>优点 客户不用自己创建对象，不用了解对象创建的详细过程 </p>\n<p>缺点 提供创建对象实例的接口函数不闭合 不能对修改关闭 对扩展开放</p>\n<p>工厂方法：Factory 基类 提供一个纯虚函数（创建产品 ）定义派生类 （具体产品的工厂 ）负责创建对应的产品</p>\n<p>优点 可以做到不同的产品，在不同的工厂创建，对修改关闭，扩展开放</p>\n<p>缺点 实际上很多产品是有关联关系的， 属于一个产品簇，不应该放在不同的工厂进行创建，这样一不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护</p>\n<p>抽象工厂 把有关联关系的 属于一个产品簇的所有产品的创建的接口函数，放在一个抽象工厂里面</p>\n<p>派生类 （具体产品的工厂）应该负责创建该产品簇里面的所有产品</p>\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>观察者 监听者模式（发布订阅模式） 行为型模式 </p>\n<p>主要关注的是对象的一对多的关系， 也就是多个对象都依赖一个对象，当该对象的状态发生变化时，其他对象都能接收到相应的通知</p>\n<p>Eg： 一组数据 （数据对象） -&gt; 通过一组数据 -&gt;  曲线图（对象1） 柱状图（对象2） 圆饼图（对象3）</p>\n<p>当数据对象改变时，对象1， 对象2 ，对象3，<font color = 'blue'>应该及时收到相应的通知！</font></p>\n<p>Subject(主题) observer1 observer2 observer3</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer1</span> : <span class=\"keyword\">public</span> Observer&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(msgid)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       \t \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer2</span> : <span class=\"keyword\">public</span> Observer&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(msgid)&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer2 recv 2 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer1 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       \t \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer3</span> : <span class=\"keyword\">public</span> Observer&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(msgid)&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer3 recv 1 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer3 recv 3 msg&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">        \tcout &lt;&lt; <span class=\"string\">&quot;observer3 recv unknown msg!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">       \t \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Subject</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer* obser, <span class=\"type\">int</span> msgid)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//给主题 添加观察者</span></span><br><span class=\"line\">    _subMap[msgid].<span class=\"built_in\">push_back</span>(obser); <span class=\"comment\">// msgid 原先有的话直接插入，没有的话会默认构造一个，然后再插入</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">despatch</span><span class=\"params\">(<span class=\"type\">int</span> msg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//主题检测发生改变，通知相应的观察者对象处理事件</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = _subMap.<span class=\"built_in\">find</span>(msgid);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it != _subMap.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Observer *pObser : it-&gt;second)&#123;</span><br><span class=\"line\">        pObser-&gt;<span class=\"built_in\">handle</span>(msgid);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  unordered_map&lt;<span class=\"type\">int</span>, list&lt;Observer*&gt;&gt; _subMap;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><p>结构型 模式</p>\n<p>让不同的不兼容的接口可以在一起工作 为了避免重构代码 -&gt; 适配器模式</p>\n<p>电脑接到投影仪 -&gt; VGA HDMI DP TypeC</p>\n<p>类比 转接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGA</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TV01</span> : <span class=\"keyword\">public</span> VGA&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;通过VGA接口投影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//电脑只支持VGA接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Computer</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">playVideo</span><span class=\"params\">(VGA *pVGA)</span></span>&#123; <span class=\"comment\">//只支持VGA接口指针</span></span><br><span class=\"line\">    pVGA-&gt;<span class=\"built_in\">play</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在新进入了一批设备 支持HDMI</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HDMI</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TV02</span>: <span class=\"keyword\">public</span> HDMI&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;通过HDMI接口投影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法1 ： 换一个HDMI的电脑-&gt; 代码重构</span></span><br><span class=\"line\"><span class=\"comment\">//方法2 ： 买一个转接头-&gt; 添加 适配器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//电脑只支持VGA 投影仪只支持HDMI 所以需要引入适配器</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VGAToHDMIAdapter</span> : <span class=\"keyword\">public</span> VGA&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">VGAToHDMIAdapter</span>(HDMI *p): <span class=\"built_in\">pHdmi</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//该方法相当于就是转接头，做不同接口的信号转换的</span></span><br><span class=\"line\">\t\t\tpHdmi-&gt;<span class=\"built_in\">play</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  HDMI *PHdmi;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  Computer c;</span><br><span class=\"line\">  TV01 t;</span><br><span class=\"line\">  c.<span class=\"built_in\">playVideo</span>(&amp;t);</span><br><span class=\"line\">  c.<span class=\"built_in\">playViceo</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">VGAToHDMIAdapter</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">TV02</span>()));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>结构型模式 Proxy 通过代理类，来控制实际对象（委托类）的访问权限</p>\n<p>客户  \t助理Proxy \t老板（委托类）</p>\n<p>​\t\t客户和老板之间的权限控制</p>\n<p><font color ='blue'>功能都是 委托类实现的， 代理类只是权限控制， 两者是组合关系</font></p>\n<p>客户直接访问的是代理对象，由代理对象和委托类实现不同客户的功能权限控制</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VideoSite</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;\t<span class=\"comment\">//免费电影</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// VIP电影</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span>\t<span class=\"title class_\">MyVideoSite</span>: <span class=\"keyword\">public</span> VideoSite&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//免费电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;观看免费电影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// VIP电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;观看VIP电影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;观看券电影&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FreeVideoSiteProxy</span> : <span class=\"keyword\">public</span> VideoSite&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">FreeVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    pVideo = <span class=\"keyword\">new</span> <span class=\"built_in\">MyVideoSite</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~<span class=\"built_in\">FreeVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pVideo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//免费电影</span></span><br><span class=\"line\">    pVideo-&gt;<span class=\"built_in\">freeMovie</span>(); <span class=\"comment\">// 通过代理对象的freeMovie， 来访问真正委托类对象的方法</span></span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// VIP电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;无权限&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;无券&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVideoSite *pVideo;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VIPVideoSiteProxy</span> : <span class=\"keyword\">public</span> VideoSite&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">VIPVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    pVideo = <span class=\"keyword\">new</span> <span class=\"built_in\">MyVideoSite</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~<span class=\"built_in\">FreeVideoSiteProxy</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pVideo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">freeMovie</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//免费电影</span></span><br><span class=\"line\">    pVideo-&gt;<span class=\"built_in\">freeMovie</span>(); <span class=\"comment\">// 通过代理对象的freeMovie， 来访问真正委托类对象的方法</span></span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">vipMovie</span><span class=\"params\">()</span><span class=\"comment\">// VIP电影&#123;</span></span></span><br><span class=\"line\"><span class=\"function\">    pVideo-&gt;<span class=\"title\">vipMovie</span><span class=\"params\">()</span></span>;<span class=\"comment\">// 通过代理对象的vipMovie， 来访问真正委托类对象的方法</span></span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ticketMoveie</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 用券观看的电影</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;无券&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tVideoSite *pVideo;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h1><p>Decorator 结构型模式</p>\n<p><em><strong>装饰器 主要是增加现有类的功能</strong></em>， 但是增加现有类的功能还有一个方法 就是新增加一个子类 -&gt; 导致类的数量非常多</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span>&#123; <span class=\"comment\">//抽象基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//三个实体汽车类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BMW</span> :<span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;BWM 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AUDI</span> :<span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Audi 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Benz</span>:<span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Benz 汽车 基本配置&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//装饰器 1 定速巡航</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteDecorator01</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">ConcreteDecorator01</span>(Car *p): <span class=\"built_in\">pCar</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pCar-&gt;<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cour &lt;&lt; <span class=\"string\">&quot;定速巡航&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Car* pCar;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//自动刹车</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteDecorator02</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">ConcreteDecorator02</span>(Car *p): <span class=\"built_in\">pCar</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pCar-&gt;<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cour &lt;&lt; <span class=\"string\">&quot;自动刹车&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Car* pCar;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//车道偏离</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteDecorator03</span>: <span class=\"keyword\">public</span> Car&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">ConcreteDecorator03</span>(Car *p): <span class=\"built_in\">pCar</span>(p)&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pCar-&gt;<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cour &lt;&lt;<span class=\"string\">&quot;车道偏离&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Car* pCar;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"CAS algorithm","_content":"CAS（比较与交换，Compare and swap)\n\n\n\n## 有锁算法\n\n独占锁，假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。\n\n缺点：\n\n- 产生竞争时，线程被阻塞等待，无法做到线程实时响应\n- dead lock\n- live lock\n- 优先级反转\n- 使用不当，造成性能下降\n\n\n\n### 乐观锁与悲观锁\n\n我们知道`CAS`操作并不会锁住共享变量，也就是一种**非阻塞**的同步机制，`CAS`就是乐观锁的实现。\n\n1. 乐观锁 **乐观锁**总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，**所以在每次操作数据的时候都不会给数据加锁**，即在线程对数据进行操作的时候，**别的线程不会阻塞**仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。\n2. 悲观锁 **悲观锁**总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，**所以在每次操作数据的时候都会给数据加锁**，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久\n\n\n\n## CAS算法 \n\nCAS的语义是“我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际是多少？”\n\n\n\n它是原子的操作\n\n \n\nCAS是项<font color = 'blue'>***乐观锁***</font>技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。\n\n\n\n## CAS引发的问题\n\n### ABA问题\n\n1、线程1 期望值为A，想更新为B\n\n2、线程2 期望值为A，想更新为B\n\n\n\n线程1 先执行， 但是线程2因为某种原因阻塞了，线程1将变量改成了B\n\n这个时候线程3来了，他把变量从B 改回了 A，\n\n线程2恢复执行，结果发现值就是A，于是 线程2 将 A改成了B，虽然线程2完成了他的操作，但是线程2并不知道发生了<font color='blue'>A->B->A </font> 的情况\n\n\n\n解决方法，给变量加上版本标识，每次更新的时候版本标识+1；\n\n<font color='blue'>A->B->A </font>  ------> <font color='blue'>A1->B2->A3 </font> \n\n\n\n#### ABA的危害\n\n取钱，由于机器不好使，多点了几次取款操作，后台thread1， thead2工作，都是100 - 50，thread1工作成果 （100-》50） ，thread阻塞，但是正好有人汇款给你（50+50=100） ，操作成功，余额变成100，这时候thread2 恢复执行，发现余额是100，继续执行100-50，于是本来余额应该是100， 结果却是50，钱没了！！！\n\n\n\n\n\n### CAS自选带来的开销\n\n多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。\n\n解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。\n\n\n\n### 只能保证一个共享变量的原子操作\n\n`CAS`的原子操作只能针对一个共享变量。\n\n**解决方法**： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行`CAS`操作。","source":"_posts/CAS算法.md","raw":"---\ntitle: CAS algorithm\n---\nCAS（比较与交换，Compare and swap)\n\n\n\n## 有锁算法\n\n独占锁，假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。\n\n缺点：\n\n- 产生竞争时，线程被阻塞等待，无法做到线程实时响应\n- dead lock\n- live lock\n- 优先级反转\n- 使用不当，造成性能下降\n\n\n\n### 乐观锁与悲观锁\n\n我们知道`CAS`操作并不会锁住共享变量，也就是一种**非阻塞**的同步机制，`CAS`就是乐观锁的实现。\n\n1. 乐观锁 **乐观锁**总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，**所以在每次操作数据的时候都不会给数据加锁**，即在线程对数据进行操作的时候，**别的线程不会阻塞**仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。\n2. 悲观锁 **悲观锁**总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，**所以在每次操作数据的时候都会给数据加锁**，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久\n\n\n\n## CAS算法 \n\nCAS的语义是“我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际是多少？”\n\n\n\n它是原子的操作\n\n \n\nCAS是项<font color = 'blue'>***乐观锁***</font>技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。\n\n\n\n## CAS引发的问题\n\n### ABA问题\n\n1、线程1 期望值为A，想更新为B\n\n2、线程2 期望值为A，想更新为B\n\n\n\n线程1 先执行， 但是线程2因为某种原因阻塞了，线程1将变量改成了B\n\n这个时候线程3来了，他把变量从B 改回了 A，\n\n线程2恢复执行，结果发现值就是A，于是 线程2 将 A改成了B，虽然线程2完成了他的操作，但是线程2并不知道发生了<font color='blue'>A->B->A </font> 的情况\n\n\n\n解决方法，给变量加上版本标识，每次更新的时候版本标识+1；\n\n<font color='blue'>A->B->A </font>  ------> <font color='blue'>A1->B2->A3 </font> \n\n\n\n#### ABA的危害\n\n取钱，由于机器不好使，多点了几次取款操作，后台thread1， thead2工作，都是100 - 50，thread1工作成果 （100-》50） ，thread阻塞，但是正好有人汇款给你（50+50=100） ，操作成功，余额变成100，这时候thread2 恢复执行，发现余额是100，继续执行100-50，于是本来余额应该是100， 结果却是50，钱没了！！！\n\n\n\n\n\n### CAS自选带来的开销\n\n多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。\n\n解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。\n\n\n\n### 只能保证一个共享变量的原子操作\n\n`CAS`的原子操作只能针对一个共享变量。\n\n**解决方法**： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行`CAS`操作。","slug":"CAS算法","published":1,"date":"2024-05-23T09:02:03.908Z","updated":"2024-05-23T09:02:25.902Z","comments":1,"layout":"post","photos":[],"_id":"clwj0ys880000wyvk0esiaud3","content":"<p>CAS（比较与交换，Compare and swap)</p>\n<h2 id=\"有锁算法\"><a href=\"#有锁算法\" class=\"headerlink\" title=\"有锁算法\"></a>有锁算法</h2><p>独占锁，假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。</p>\n<p>缺点：</p>\n<ul>\n<li>产生竞争时，线程被阻塞等待，无法做到线程实时响应</li>\n<li>dead lock</li>\n<li>live lock</li>\n<li>优先级反转</li>\n<li>使用不当，造成性能下降</li>\n</ul>\n<h3 id=\"乐观锁与悲观锁\"><a href=\"#乐观锁与悲观锁\" class=\"headerlink\" title=\"乐观锁与悲观锁\"></a>乐观锁与悲观锁</h3><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p>\n<ol>\n<li>乐观锁 <strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li>\n<li>悲观锁 <strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久</li>\n</ol>\n<h2 id=\"CAS算法\"><a href=\"#CAS算法\" class=\"headerlink\" title=\"CAS算法\"></a>CAS算法</h2><p>CAS的语义是“我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际是多少？”</p>\n<p>它是原子的操作</p>\n<p>CAS是项<font color = 'blue'><em><strong>乐观锁</strong></em></font>技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>\n<h2 id=\"CAS引发的问题\"><a href=\"#CAS引发的问题\" class=\"headerlink\" title=\"CAS引发的问题\"></a>CAS引发的问题</h2><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>1、线程1 期望值为A，想更新为B</p>\n<p>2、线程2 期望值为A，想更新为B</p>\n<p>线程1 先执行， 但是线程2因为某种原因阻塞了，线程1将变量改成了B</p>\n<p>这个时候线程3来了，他把变量从B 改回了 A，</p>\n<p>线程2恢复执行，结果发现值就是A，于是 线程2 将 A改成了B，虽然线程2完成了他的操作，但是线程2并不知道发生了<font color='blue'>A-&gt;B-&gt;A </font> 的情况</p>\n<p>解决方法，给变量加上版本标识，每次更新的时候版本标识+1；</p>\n<p><font color='blue'>A-&gt;B-&gt;A </font>  ——&gt; <font color='blue'>A1-&gt;B2-&gt;A3 </font> </p>\n<h4 id=\"ABA的危害\"><a href=\"#ABA的危害\" class=\"headerlink\" title=\"ABA的危害\"></a>ABA的危害</h4><p>取钱，由于机器不好使，多点了几次取款操作，后台thread1， thead2工作，都是100 - 50，thread1工作成果 （100-》50） ，thread阻塞，但是正好有人汇款给你（50+50&#x3D;100） ，操作成功，余额变成100，这时候thread2 恢复执行，发现余额是100，继续执行100-50，于是本来余额应该是100， 结果却是50，钱没了！！！</p>\n<h3 id=\"CAS自选带来的开销\"><a href=\"#CAS自选带来的开销\" class=\"headerlink\" title=\"CAS自选带来的开销\"></a>CAS自选带来的开销</h3><p>多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p>\n<p>解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。</p>\n<h3 id=\"只能保证一个共享变量的原子操作\"><a href=\"#只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"只能保证一个共享变量的原子操作\"></a>只能保证一个共享变量的原子操作</h3><p><code>CAS</code>的原子操作只能针对一个共享变量。</p>\n<p><strong>解决方法</strong>： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p>\n","cover":false,"excerpt":"","more":"<p>CAS（比较与交换，Compare and swap)</p>\n<h2 id=\"有锁算法\"><a href=\"#有锁算法\" class=\"headerlink\" title=\"有锁算法\"></a>有锁算法</h2><p>独占锁，假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。</p>\n<p>缺点：</p>\n<ul>\n<li>产生竞争时，线程被阻塞等待，无法做到线程实时响应</li>\n<li>dead lock</li>\n<li>live lock</li>\n<li>优先级反转</li>\n<li>使用不当，造成性能下降</li>\n</ul>\n<h3 id=\"乐观锁与悲观锁\"><a href=\"#乐观锁与悲观锁\" class=\"headerlink\" title=\"乐观锁与悲观锁\"></a>乐观锁与悲观锁</h3><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p>\n<ol>\n<li>乐观锁 <strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li>\n<li>悲观锁 <strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久</li>\n</ol>\n<h2 id=\"CAS算法\"><a href=\"#CAS算法\" class=\"headerlink\" title=\"CAS算法\"></a>CAS算法</h2><p>CAS的语义是“我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际是多少？”</p>\n<p>它是原子的操作</p>\n<p>CAS是项<font color = 'blue'><em><strong>乐观锁</strong></em></font>技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>\n<h2 id=\"CAS引发的问题\"><a href=\"#CAS引发的问题\" class=\"headerlink\" title=\"CAS引发的问题\"></a>CAS引发的问题</h2><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>1、线程1 期望值为A，想更新为B</p>\n<p>2、线程2 期望值为A，想更新为B</p>\n<p>线程1 先执行， 但是线程2因为某种原因阻塞了，线程1将变量改成了B</p>\n<p>这个时候线程3来了，他把变量从B 改回了 A，</p>\n<p>线程2恢复执行，结果发现值就是A，于是 线程2 将 A改成了B，虽然线程2完成了他的操作，但是线程2并不知道发生了<font color='blue'>A-&gt;B-&gt;A </font> 的情况</p>\n<p>解决方法，给变量加上版本标识，每次更新的时候版本标识+1；</p>\n<p><font color='blue'>A-&gt;B-&gt;A </font>  ——&gt; <font color='blue'>A1-&gt;B2-&gt;A3 </font> </p>\n<h4 id=\"ABA的危害\"><a href=\"#ABA的危害\" class=\"headerlink\" title=\"ABA的危害\"></a>ABA的危害</h4><p>取钱，由于机器不好使，多点了几次取款操作，后台thread1， thead2工作，都是100 - 50，thread1工作成果 （100-》50） ，thread阻塞，但是正好有人汇款给你（50+50&#x3D;100） ，操作成功，余额变成100，这时候thread2 恢复执行，发现余额是100，继续执行100-50，于是本来余额应该是100， 结果却是50，钱没了！！！</p>\n<h3 id=\"CAS自选带来的开销\"><a href=\"#CAS自选带来的开销\" class=\"headerlink\" title=\"CAS自选带来的开销\"></a>CAS自选带来的开销</h3><p>多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p>\n<p>解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。</p>\n<h3 id=\"只能保证一个共享变量的原子操作\"><a href=\"#只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"只能保证一个共享变量的原子操作\"></a>只能保证一个共享变量的原子操作</h3><p><code>CAS</code>的原子操作只能针对一个共享变量。</p>\n<p><strong>解决方法</strong>： 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p>\n"},{"title":"重写muduo","_content":"\nmuduo网络库的重写\n\n# 目的\n\n1、理解阻塞、非阻塞、同步、异步\n\n2、理解Unix/Linux上的五种IO模型\n\n3、epoll的原理以及优势\n\n4、深刻理解Reactor模型5、从开源C++网络库，学习优秀的代码设计\n\n6、掌握基于事件驱动和事件回调的epoll+线程池面向对象编程\n\n7、通过深入理解muduo源码，加深对于相关项目的深刻理解\n\n8、改造muduo，不依赖boost，用C++11重构\n\n\n\n# 知识储备\n\n1、TCP协议和UDP协议\n\n2、TCP编程和UDP编程步骤\n\n3、IO复用接口编程select、poll、epoll编程\n\n4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持\n\n\n\n\n\n# 阻塞、非阻塞、同步、异步\n\n典型的一次IO的两个阶段 数据准备( 从设备缓冲区复制到 内核缓冲区 ）数据读写（从内核空间复制到用户空间）\n\n数据准备： 根据系统IO操作的就绪状态\n\n- 阻塞  <font color='blue'>调用IO方法线程进入阻塞状态</font>\n- 非阻塞 <font color='gree'>不会改变线程的状态通过返回值判断</font>\n\nssize_t recv(int socked,void *buf, size_t len, int flags)\n\nint size = recv(sockfd,buf,1024,0)\n\nsocketed 默认工作在阻塞模式， recv如果没有数据可以读 ，就会阻塞当前线程\n\n非阻塞 recv 直接返回 通过返回值判断是否准备成功\n\n​\tsize = -1 表示错误 有两种情况 1、系统错误 2、非阻塞返回\n\n所以要继续判断\n\n​\t**size = -1 && errno = EAGAIN 非阻塞返回**\n\n​\tsize = 0 网络对端关闭了连接\n\n​\tsize > 0  接收到的数据字节数\n\n数据读写：根据应用程序和内核的交互方式\n\n- 同步 <font color = 'blue'>应用程序</font>使用recv 自己把数据从 从内核空间搬移到用户空间 **recv 同步IO接口** （阻塞或者非阻塞由sockfd决定）\n- 异步 <font color='green'>操作系统</font>负责 从内核空间搬到用户空间\n  - sockfd 监听的端口\n  - buf 用户程序存放数据的buf指针\n  - sigio信号 通知数据读写完成\n  - 当操作系统使用  sigio 信号  <font color='red'>***通知***</font>  的时候表示 数据已经准备好了  （信号、回调\n  - 效率高但是编程复杂\n\n​\tLinux异步IO接口 aio_read aio_write **特殊API** \n\n​\t同步IO select poll epoll\n\n\n\n**陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步**\n\n**IO。**\n\n\n\n并发的同步和异步\n\n 同步 ： **A等 B做完了 得到返回值 A 再继续执行**  \n\n异步 ：A告诉B 感兴趣的事件以及通知方式，A操作继续执行自己的业务逻辑，等B监听到了响应的事件发生，B  <font color='red'>**通知**</font>  A，A再处理，\n\n\n\nNode.js 基于异步非阻塞模式下的高性能服务器\n\n\n\n\n\n# Unix/Linux的五种IO模型\n\n#### 阻塞blocking 同步\n\n| 应用进程read | 系统调用----> | 内核                   |\n| ------------ | ------------- | ---------------------- |\n| 阻塞...      |               | 内核准备数据           |\n| 阻塞...      |               | 拷贝数据到用户进程空间 |\n| 应用处理数据 | <----返回     | 拷贝成功               |\n\n进程阻塞于read\n\n\n\n#### 非阻塞non-blocking 同步\n\n| 应用进程read | 系统调用----> | 内核                   |\n| ------------ | ------------- | ---------------------- |\n| read         | <----- EAGAIN | 准备数据               |\n| Read         | <----- EAGAIN |                        |\n| Read         | <----- EAGAIN |                        |\n|              |               | 拷贝数据到用户进程空间 |\n| 处理数据     | <----- 返回   | 拷贝完成               |\n\n进程调用read， 判断EAGAIN 反复调用 \n\n\n\n#### IO复用 IO multiplexing\n\n在一个线程调用IO复用函数，可以监视一系列fd 是同步的IO接口\n\n|      | select         | poll           | epoll                               |\n| ---- | -------------- | -------------- | ----------------------------------- |\n|      | 数组 长度限制  | 链表无长度限制 | 红黑树                              |\n|      | 需要复制到内核 | 需要复制到内核 | 就是建立在内核内 无需复制           |\n|      |                |                | 连接数量多 但是只有少部分是活跃连接 |\n\n\n\n#### 信号驱动signal-driven\n\n上述三种在第一种阶段要么阻塞， 要么不阻塞但是需要轮询，但是信号启动时第一步不需要轮询，但是第二步是同步的，也就是数据从内核空间搬移到用户空间的话需要花费用户程序自己的时间去做\n\n \n\n内核在第一个阶段是异步，在第二个阶段是同步，区别于非阻塞IO 是他提供消息通知机制，不需要用户进程不断轮询检查，减少了API的调用次数，提高效率\n\n\n\n#### 异步asynchronous\n\n全都异步，第一步 第二步都是操作系统内核完成，效率高，但是编程复杂，出问题不好排查\n\n典型的异步非阻塞状态，Node.js采用的网络IO模型。\n\n## 好的网络服务器设计\n\n<font color='blue'>one loop per thread is usually a good model </font>\n\n这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。\n\nevent loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IOmultiplexing 一起使用，原因有两点：\n\n- 没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费CPU资源了。\n\n- IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO read()/write()/accept()/connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。\n\n所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其\n\n中任何一个都没有办法很好的实现功能。\n\n>  epoll + fork不如epoll + pthread？\n\n强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的**服务器惊群**现象，功能十分强大\n\n## reactor模型\n\n> The reactor design pattern is an event handling pattern for handling service requests\n>\n> delivered concurrently to a service handler by one or more inputs. The service handler\n>\n> then demultiplexes the incoming requests and dispatches them synchronously to the\n>\n> associated request handlers.\n\n**重要组件**：**Event事件、Reactor反应堆、Demultiplex事件分发器、Evanthandler事件处理器**\n\n\n\n# epoll\n\n## select的缺点：\n\n1、单个进程能够监视的**文件描述符的数量存在最大限制**，通常是1024，当然可以更改数量，但由于\n\nselect采用**轮询的方式扫描**文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有\n\n这样的定义：#define __FD_SETSIZE 1024\n\n2、**内核 / 用户空间内存拷贝**问题，select需要复制大量的句柄数据结构，产生巨大的开销\n\n3、select返回的是含有整个句柄的数组，**应用程序需要遍历整个数组**才能发现哪些句柄发生了事件\n\n4、select的触发方式是**水平触发**，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程\n\n\n\n## Poll\n\n相比select模型，**poll使用链表**保存文件描述符，因此没有了监视文件数量的限制，但其他**三个缺点依然存在。**\n\n以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况\n\n下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，\n\n从内核/用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的\n\n服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。\n\n## epoll\n\nepoll把原先的select/poll调用分成以下3个部分：\n\n1）调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）\n\n2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字\n\n3）调用epoll_wait收集发生的事件的fd资源\n\n如此一来，要实现上面说的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这\n\n个epoll对象中添加或者删除事件。同时，epoll_wait的效率也非常高，因为东西都放在内核空间，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。\n\n\n\n\n\n## LT模式\n\n内核数据还没读完，就会一直上报数据\n\n\n\n## ET模式\n\n内核数据只上报一次\n\n\n\n### **muduo采用的是LT**\n\n- 不会丢失数据或者消息\n  - 应用没有读取完数据，内核是会不断上报的\n\n- 低延迟处理\n  - 每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息\n\n- 跨平台处理\n  - 像select一样可以跨平台使用\n\n\n\n## muduo网络库的核心模块\n\nChannel\n\n\n\n\n## 总结         \n![overview](../imgs/muduo.png)\n\n","source":"_posts/muduo.md","raw":"---\ntitle: 重写muduo\n---\n\nmuduo网络库的重写\n\n# 目的\n\n1、理解阻塞、非阻塞、同步、异步\n\n2、理解Unix/Linux上的五种IO模型\n\n3、epoll的原理以及优势\n\n4、深刻理解Reactor模型5、从开源C++网络库，学习优秀的代码设计\n\n6、掌握基于事件驱动和事件回调的epoll+线程池面向对象编程\n\n7、通过深入理解muduo源码，加深对于相关项目的深刻理解\n\n8、改造muduo，不依赖boost，用C++11重构\n\n\n\n# 知识储备\n\n1、TCP协议和UDP协议\n\n2、TCP编程和UDP编程步骤\n\n3、IO复用接口编程select、poll、epoll编程\n\n4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持\n\n\n\n\n\n# 阻塞、非阻塞、同步、异步\n\n典型的一次IO的两个阶段 数据准备( 从设备缓冲区复制到 内核缓冲区 ）数据读写（从内核空间复制到用户空间）\n\n数据准备： 根据系统IO操作的就绪状态\n\n- 阻塞  <font color='blue'>调用IO方法线程进入阻塞状态</font>\n- 非阻塞 <font color='gree'>不会改变线程的状态通过返回值判断</font>\n\nssize_t recv(int socked,void *buf, size_t len, int flags)\n\nint size = recv(sockfd,buf,1024,0)\n\nsocketed 默认工作在阻塞模式， recv如果没有数据可以读 ，就会阻塞当前线程\n\n非阻塞 recv 直接返回 通过返回值判断是否准备成功\n\n​\tsize = -1 表示错误 有两种情况 1、系统错误 2、非阻塞返回\n\n所以要继续判断\n\n​\t**size = -1 && errno = EAGAIN 非阻塞返回**\n\n​\tsize = 0 网络对端关闭了连接\n\n​\tsize > 0  接收到的数据字节数\n\n数据读写：根据应用程序和内核的交互方式\n\n- 同步 <font color = 'blue'>应用程序</font>使用recv 自己把数据从 从内核空间搬移到用户空间 **recv 同步IO接口** （阻塞或者非阻塞由sockfd决定）\n- 异步 <font color='green'>操作系统</font>负责 从内核空间搬到用户空间\n  - sockfd 监听的端口\n  - buf 用户程序存放数据的buf指针\n  - sigio信号 通知数据读写完成\n  - 当操作系统使用  sigio 信号  <font color='red'>***通知***</font>  的时候表示 数据已经准备好了  （信号、回调\n  - 效率高但是编程复杂\n\n​\tLinux异步IO接口 aio_read aio_write **特殊API** \n\n​\t同步IO select poll epoll\n\n\n\n**陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步**\n\n**IO。**\n\n\n\n并发的同步和异步\n\n 同步 ： **A等 B做完了 得到返回值 A 再继续执行**  \n\n异步 ：A告诉B 感兴趣的事件以及通知方式，A操作继续执行自己的业务逻辑，等B监听到了响应的事件发生，B  <font color='red'>**通知**</font>  A，A再处理，\n\n\n\nNode.js 基于异步非阻塞模式下的高性能服务器\n\n\n\n\n\n# Unix/Linux的五种IO模型\n\n#### 阻塞blocking 同步\n\n| 应用进程read | 系统调用----> | 内核                   |\n| ------------ | ------------- | ---------------------- |\n| 阻塞...      |               | 内核准备数据           |\n| 阻塞...      |               | 拷贝数据到用户进程空间 |\n| 应用处理数据 | <----返回     | 拷贝成功               |\n\n进程阻塞于read\n\n\n\n#### 非阻塞non-blocking 同步\n\n| 应用进程read | 系统调用----> | 内核                   |\n| ------------ | ------------- | ---------------------- |\n| read         | <----- EAGAIN | 准备数据               |\n| Read         | <----- EAGAIN |                        |\n| Read         | <----- EAGAIN |                        |\n|              |               | 拷贝数据到用户进程空间 |\n| 处理数据     | <----- 返回   | 拷贝完成               |\n\n进程调用read， 判断EAGAIN 反复调用 \n\n\n\n#### IO复用 IO multiplexing\n\n在一个线程调用IO复用函数，可以监视一系列fd 是同步的IO接口\n\n|      | select         | poll           | epoll                               |\n| ---- | -------------- | -------------- | ----------------------------------- |\n|      | 数组 长度限制  | 链表无长度限制 | 红黑树                              |\n|      | 需要复制到内核 | 需要复制到内核 | 就是建立在内核内 无需复制           |\n|      |                |                | 连接数量多 但是只有少部分是活跃连接 |\n\n\n\n#### 信号驱动signal-driven\n\n上述三种在第一种阶段要么阻塞， 要么不阻塞但是需要轮询，但是信号启动时第一步不需要轮询，但是第二步是同步的，也就是数据从内核空间搬移到用户空间的话需要花费用户程序自己的时间去做\n\n \n\n内核在第一个阶段是异步，在第二个阶段是同步，区别于非阻塞IO 是他提供消息通知机制，不需要用户进程不断轮询检查，减少了API的调用次数，提高效率\n\n\n\n#### 异步asynchronous\n\n全都异步，第一步 第二步都是操作系统内核完成，效率高，但是编程复杂，出问题不好排查\n\n典型的异步非阻塞状态，Node.js采用的网络IO模型。\n\n## 好的网络服务器设计\n\n<font color='blue'>one loop per thread is usually a good model </font>\n\n这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。\n\nevent loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IOmultiplexing 一起使用，原因有两点：\n\n- 没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费CPU资源了。\n\n- IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO read()/write()/accept()/connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。\n\n所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其\n\n中任何一个都没有办法很好的实现功能。\n\n>  epoll + fork不如epoll + pthread？\n\n强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的**服务器惊群**现象，功能十分强大\n\n## reactor模型\n\n> The reactor design pattern is an event handling pattern for handling service requests\n>\n> delivered concurrently to a service handler by one or more inputs. The service handler\n>\n> then demultiplexes the incoming requests and dispatches them synchronously to the\n>\n> associated request handlers.\n\n**重要组件**：**Event事件、Reactor反应堆、Demultiplex事件分发器、Evanthandler事件处理器**\n\n\n\n# epoll\n\n## select的缺点：\n\n1、单个进程能够监视的**文件描述符的数量存在最大限制**，通常是1024，当然可以更改数量，但由于\n\nselect采用**轮询的方式扫描**文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有\n\n这样的定义：#define __FD_SETSIZE 1024\n\n2、**内核 / 用户空间内存拷贝**问题，select需要复制大量的句柄数据结构，产生巨大的开销\n\n3、select返回的是含有整个句柄的数组，**应用程序需要遍历整个数组**才能发现哪些句柄发生了事件\n\n4、select的触发方式是**水平触发**，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程\n\n\n\n## Poll\n\n相比select模型，**poll使用链表**保存文件描述符，因此没有了监视文件数量的限制，但其他**三个缺点依然存在。**\n\n以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况\n\n下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，\n\n从内核/用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的\n\n服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。\n\n## epoll\n\nepoll把原先的select/poll调用分成以下3个部分：\n\n1）调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）\n\n2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字\n\n3）调用epoll_wait收集发生的事件的fd资源\n\n如此一来，要实现上面说的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这\n\n个epoll对象中添加或者删除事件。同时，epoll_wait的效率也非常高，因为东西都放在内核空间，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。\n\n\n\n\n\n## LT模式\n\n内核数据还没读完，就会一直上报数据\n\n\n\n## ET模式\n\n内核数据只上报一次\n\n\n\n### **muduo采用的是LT**\n\n- 不会丢失数据或者消息\n  - 应用没有读取完数据，内核是会不断上报的\n\n- 低延迟处理\n  - 每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息\n\n- 跨平台处理\n  - 像select一样可以跨平台使用\n\n\n\n## muduo网络库的核心模块\n\nChannel\n\n\n\n\n## 总结         \n![overview](../imgs/muduo.png)\n\n","slug":"muduo","published":1,"date":"2024-06-09T15:07:13.502Z","updated":"2024-06-09T15:15:27.590Z","_id":"clx7oi1ts000067vk5dfvd7eo","comments":1,"layout":"post","photos":[],"content":"<p>muduo网络库的重写</p>\n<h1 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1><p>1、理解阻塞、非阻塞、同步、异步</p>\n<p>2、理解Unix&#x2F;Linux上的五种IO模型</p>\n<p>3、epoll的原理以及优势</p>\n<p>4、深刻理解Reactor模型5、从开源C++网络库，学习优秀的代码设计</p>\n<p>6、掌握基于事件驱动和事件回调的epoll+线程池面向对象编程</p>\n<p>7、通过深入理解muduo源码，加深对于相关项目的深刻理解</p>\n<p>8、改造muduo，不依赖boost，用C++11重构</p>\n<h1 id=\"知识储备\"><a href=\"#知识储备\" class=\"headerlink\" title=\"知识储备\"></a>知识储备</h1><p>1、TCP协议和UDP协议</p>\n<p>2、TCP编程和UDP编程步骤</p>\n<p>3、IO复用接口编程select、poll、epoll编程</p>\n<p>4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持</p>\n<h1 id=\"阻塞、非阻塞、同步、异步\"><a href=\"#阻塞、非阻塞、同步、异步\" class=\"headerlink\" title=\"阻塞、非阻塞、同步、异步\"></a>阻塞、非阻塞、同步、异步</h1><p>典型的一次IO的两个阶段 数据准备( 从设备缓冲区复制到 内核缓冲区 ）数据读写（从内核空间复制到用户空间）</p>\n<p>数据准备： 根据系统IO操作的就绪状态</p>\n<ul>\n<li>阻塞  <font color='blue'>调用IO方法线程进入阻塞状态</font></li>\n<li>非阻塞 <font color='gree'>不会改变线程的状态通过返回值判断</font></li>\n</ul>\n<p>ssize_t recv(int socked,void *buf, size_t len, int flags)</p>\n<p>int size &#x3D; recv(sockfd,buf,1024,0)</p>\n<p>socketed 默认工作在阻塞模式， recv如果没有数据可以读 ，就会阻塞当前线程</p>\n<p>非阻塞 recv 直接返回 通过返回值判断是否准备成功</p>\n<p>​\tsize &#x3D; -1 表示错误 有两种情况 1、系统错误 2、非阻塞返回</p>\n<p>所以要继续判断</p>\n<p>​\t<strong>size &#x3D; -1 &amp;&amp; errno &#x3D; EAGAIN 非阻塞返回</strong></p>\n<p>​\tsize &#x3D; 0 网络对端关闭了连接</p>\n<p>​\tsize &gt; 0  接收到的数据字节数</p>\n<p>数据读写：根据应用程序和内核的交互方式</p>\n<ul>\n<li>同步 <font color = 'blue'>应用程序</font>使用recv 自己把数据从 从内核空间搬移到用户空间 <strong>recv 同步IO接口</strong> （阻塞或者非阻塞由sockfd决定）</li>\n<li>异步 <font color='green'>操作系统</font>负责 从内核空间搬到用户空间<ul>\n<li>sockfd 监听的端口</li>\n<li>buf 用户程序存放数据的buf指针</li>\n<li>sigio信号 通知数据读写完成</li>\n<li>当操作系统使用  sigio 信号  <font color='red'><em><strong>通知</strong></em></font>  的时候表示 数据已经准备好了  （信号、回调</li>\n<li>效率高但是编程复杂</li>\n</ul>\n</li>\n</ul>\n<p>​\tLinux异步IO接口 aio_read aio_write <strong>特殊API</strong> </p>\n<p>​\t同步IO select poll epoll</p>\n<p><strong>陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步</strong></p>\n<p><strong>IO。</strong></p>\n<p>并发的同步和异步</p>\n<p> 同步 ： <strong>A等 B做完了 得到返回值 A 再继续执行</strong>  </p>\n<p>异步 ：A告诉B 感兴趣的事件以及通知方式，A操作继续执行自己的业务逻辑，等B监听到了响应的事件发生，B  <font color='red'><strong>通知</strong></font>  A，A再处理，</p>\n<p>Node.js 基于异步非阻塞模式下的高性能服务器</p>\n<h1 id=\"Unix-Linux的五种IO模型\"><a href=\"#Unix-Linux的五种IO模型\" class=\"headerlink\" title=\"Unix&#x2F;Linux的五种IO模型\"></a>Unix&#x2F;Linux的五种IO模型</h1><h4 id=\"阻塞blocking-同步\"><a href=\"#阻塞blocking-同步\" class=\"headerlink\" title=\"阻塞blocking 同步\"></a>阻塞blocking 同步</h4><table>\n<thead>\n<tr>\n<th>应用进程read</th>\n<th>系统调用—-&gt;</th>\n<th>内核</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>阻塞…</td>\n<td></td>\n<td>内核准备数据</td>\n</tr>\n<tr>\n<td>阻塞…</td>\n<td></td>\n<td>拷贝数据到用户进程空间</td>\n</tr>\n<tr>\n<td>应用处理数据</td>\n<td>&lt;—-返回</td>\n<td>拷贝成功</td>\n</tr>\n</tbody></table>\n<p>进程阻塞于read</p>\n<h4 id=\"非阻塞non-blocking-同步\"><a href=\"#非阻塞non-blocking-同步\" class=\"headerlink\" title=\"非阻塞non-blocking 同步\"></a>非阻塞non-blocking 同步</h4><table>\n<thead>\n<tr>\n<th>应用进程read</th>\n<th>系统调用—-&gt;</th>\n<th>内核</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>read</td>\n<td>&lt;—– EAGAIN</td>\n<td>准备数据</td>\n</tr>\n<tr>\n<td>Read</td>\n<td>&lt;—– EAGAIN</td>\n<td></td>\n</tr>\n<tr>\n<td>Read</td>\n<td>&lt;—– EAGAIN</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>拷贝数据到用户进程空间</td>\n</tr>\n<tr>\n<td>处理数据</td>\n<td>&lt;—– 返回</td>\n<td>拷贝完成</td>\n</tr>\n</tbody></table>\n<p>进程调用read， 判断EAGAIN 反复调用 </p>\n<h4 id=\"IO复用-IO-multiplexing\"><a href=\"#IO复用-IO-multiplexing\" class=\"headerlink\" title=\"IO复用 IO multiplexing\"></a>IO复用 IO multiplexing</h4><p>在一个线程调用IO复用函数，可以监视一系列fd 是同步的IO接口</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>select</th>\n<th>poll</th>\n<th>epoll</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>数组 长度限制</td>\n<td>链表无长度限制</td>\n<td>红黑树</td>\n</tr>\n<tr>\n<td></td>\n<td>需要复制到内核</td>\n<td>需要复制到内核</td>\n<td>就是建立在内核内 无需复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>连接数量多 但是只有少部分是活跃连接</td>\n</tr>\n</tbody></table>\n<h4 id=\"信号驱动signal-driven\"><a href=\"#信号驱动signal-driven\" class=\"headerlink\" title=\"信号驱动signal-driven\"></a>信号驱动signal-driven</h4><p>上述三种在第一种阶段要么阻塞， 要么不阻塞但是需要轮询，但是信号启动时第一步不需要轮询，但是第二步是同步的，也就是数据从内核空间搬移到用户空间的话需要花费用户程序自己的时间去做</p>\n<p>内核在第一个阶段是异步，在第二个阶段是同步，区别于非阻塞IO 是他提供消息通知机制，不需要用户进程不断轮询检查，减少了API的调用次数，提高效率</p>\n<h4 id=\"异步asynchronous\"><a href=\"#异步asynchronous\" class=\"headerlink\" title=\"异步asynchronous\"></a>异步asynchronous</h4><p>全都异步，第一步 第二步都是操作系统内核完成，效率高，但是编程复杂，出问题不好排查</p>\n<p>典型的异步非阻塞状态，Node.js采用的网络IO模型。</p>\n<h2 id=\"好的网络服务器设计\"><a href=\"#好的网络服务器设计\" class=\"headerlink\" title=\"好的网络服务器设计\"></a>好的网络服务器设计</h2><p><font color='blue'>one loop per thread is usually a good model </font></p>\n<p>这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p>\n<p>event loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IOmultiplexing 一起使用，原因有两点：</p>\n<ul>\n<li><p>没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费CPU资源了。</p>\n</li>\n<li><p>IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO read()&#x2F;write()&#x2F;accept()&#x2F;connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。</p>\n</li>\n</ul>\n<p>所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其</p>\n<p>中任何一个都没有办法很好的实现功能。</p>\n<blockquote>\n<p> epoll + fork不如epoll + pthread？</p>\n</blockquote>\n<p>强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的<strong>服务器惊群</strong>现象，功能十分强大</p>\n<h2 id=\"reactor模型\"><a href=\"#reactor模型\" class=\"headerlink\" title=\"reactor模型\"></a>reactor模型</h2><blockquote>\n<p>The reactor design pattern is an event handling pattern for handling service requests</p>\n<p>delivered concurrently to a service handler by one or more inputs. The service handler</p>\n<p>then demultiplexes the incoming requests and dispatches them synchronously to the</p>\n<p>associated request handlers.</p>\n</blockquote>\n<p><strong>重要组件</strong>：<strong>Event事件、Reactor反应堆、Demultiplex事件分发器、Evanthandler事件处理器</strong></p>\n<h1 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h1><h2 id=\"select的缺点：\"><a href=\"#select的缺点：\" class=\"headerlink\" title=\"select的缺点：\"></a>select的缺点：</h2><p>1、单个进程能够监视的<strong>文件描述符的数量存在最大限制</strong>，通常是1024，当然可以更改数量，但由于</p>\n<p>select采用<strong>轮询的方式扫描</strong>文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有</p>\n<p>这样的定义：#define __FD_SETSIZE 1024</p>\n<p>2、<strong>内核 &#x2F; 用户空间内存拷贝</strong>问题，select需要复制大量的句柄数据结构，产生巨大的开销</p>\n<p>3、select返回的是含有整个句柄的数组，<strong>应用程序需要遍历整个数组</strong>才能发现哪些句柄发生了事件</p>\n<p>4、select的触发方式是<strong>水平触发</strong>，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程</p>\n<h2 id=\"Poll\"><a href=\"#Poll\" class=\"headerlink\" title=\"Poll\"></a>Poll</h2><p>相比select模型，<strong>poll使用链表</strong>保存文件描述符，因此没有了监视文件数量的限制，但其他<strong>三个缺点依然存在。</strong></p>\n<p>以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况</p>\n<p>下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，</p>\n<p>从内核&#x2F;用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的</p>\n<p>服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。</p>\n<h2 id=\"epoll-1\"><a href=\"#epoll-1\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><p>epoll把原先的select&#x2F;poll调用分成以下3个部分：</p>\n<p>1）调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）</p>\n<p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p>\n<p>3）调用epoll_wait收集发生的事件的fd资源</p>\n<p>如此一来，要实现上面说的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这</p>\n<p>个epoll对象中添加或者删除事件。同时，epoll_wait的效率也非常高，因为东西都放在内核空间，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p>\n<h2 id=\"LT模式\"><a href=\"#LT模式\" class=\"headerlink\" title=\"LT模式\"></a>LT模式</h2><p>内核数据还没读完，就会一直上报数据</p>\n<h2 id=\"ET模式\"><a href=\"#ET模式\" class=\"headerlink\" title=\"ET模式\"></a>ET模式</h2><p>内核数据只上报一次</p>\n<h3 id=\"muduo采用的是LT\"><a href=\"#muduo采用的是LT\" class=\"headerlink\" title=\"muduo采用的是LT\"></a><strong>muduo采用的是LT</strong></h3><ul>\n<li><p>不会丢失数据或者消息</p>\n<ul>\n<li>应用没有读取完数据，内核是会不断上报的</li>\n</ul>\n</li>\n<li><p>低延迟处理</p>\n<ul>\n<li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li>\n</ul>\n</li>\n<li><p>跨平台处理</p>\n<ul>\n<li>像select一样可以跨平台使用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"muduo网络库的核心模块\"><a href=\"#muduo网络库的核心模块\" class=\"headerlink\" title=\"muduo网络库的核心模块\"></a>muduo网络库的核心模块</h2><p>Channel</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../imgs/muduo.png\" alt=\"overview\"></p>\n","cover":false,"excerpt":"","more":"<p>muduo网络库的重写</p>\n<h1 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1><p>1、理解阻塞、非阻塞、同步、异步</p>\n<p>2、理解Unix&#x2F;Linux上的五种IO模型</p>\n<p>3、epoll的原理以及优势</p>\n<p>4、深刻理解Reactor模型5、从开源C++网络库，学习优秀的代码设计</p>\n<p>6、掌握基于事件驱动和事件回调的epoll+线程池面向对象编程</p>\n<p>7、通过深入理解muduo源码，加深对于相关项目的深刻理解</p>\n<p>8、改造muduo，不依赖boost，用C++11重构</p>\n<h1 id=\"知识储备\"><a href=\"#知识储备\" class=\"headerlink\" title=\"知识储备\"></a>知识储备</h1><p>1、TCP协议和UDP协议</p>\n<p>2、TCP编程和UDP编程步骤</p>\n<p>3、IO复用接口编程select、poll、epoll编程</p>\n<p>4、Linux的多线程编程pthread、进程和线程模型 C++20标准加入了协程的支持</p>\n<h1 id=\"阻塞、非阻塞、同步、异步\"><a href=\"#阻塞、非阻塞、同步、异步\" class=\"headerlink\" title=\"阻塞、非阻塞、同步、异步\"></a>阻塞、非阻塞、同步、异步</h1><p>典型的一次IO的两个阶段 数据准备( 从设备缓冲区复制到 内核缓冲区 ）数据读写（从内核空间复制到用户空间）</p>\n<p>数据准备： 根据系统IO操作的就绪状态</p>\n<ul>\n<li>阻塞  <font color='blue'>调用IO方法线程进入阻塞状态</font></li>\n<li>非阻塞 <font color='gree'>不会改变线程的状态通过返回值判断</font></li>\n</ul>\n<p>ssize_t recv(int socked,void *buf, size_t len, int flags)</p>\n<p>int size &#x3D; recv(sockfd,buf,1024,0)</p>\n<p>socketed 默认工作在阻塞模式， recv如果没有数据可以读 ，就会阻塞当前线程</p>\n<p>非阻塞 recv 直接返回 通过返回值判断是否准备成功</p>\n<p>​\tsize &#x3D; -1 表示错误 有两种情况 1、系统错误 2、非阻塞返回</p>\n<p>所以要继续判断</p>\n<p>​\t<strong>size &#x3D; -1 &amp;&amp; errno &#x3D; EAGAIN 非阻塞返回</strong></p>\n<p>​\tsize &#x3D; 0 网络对端关闭了连接</p>\n<p>​\tsize &gt; 0  接收到的数据字节数</p>\n<p>数据读写：根据应用程序和内核的交互方式</p>\n<ul>\n<li>同步 <font color = 'blue'>应用程序</font>使用recv 自己把数据从 从内核空间搬移到用户空间 <strong>recv 同步IO接口</strong> （阻塞或者非阻塞由sockfd决定）</li>\n<li>异步 <font color='green'>操作系统</font>负责 从内核空间搬到用户空间<ul>\n<li>sockfd 监听的端口</li>\n<li>buf 用户程序存放数据的buf指针</li>\n<li>sigio信号 通知数据读写完成</li>\n<li>当操作系统使用  sigio 信号  <font color='red'><em><strong>通知</strong></em></font>  的时候表示 数据已经准备好了  （信号、回调</li>\n<li>效率高但是编程复杂</li>\n</ul>\n</li>\n</ul>\n<p>​\tLinux异步IO接口 aio_read aio_write <strong>特殊API</strong> </p>\n<p>​\t同步IO select poll epoll</p>\n<p><strong>陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步</strong></p>\n<p><strong>IO。</strong></p>\n<p>并发的同步和异步</p>\n<p> 同步 ： <strong>A等 B做完了 得到返回值 A 再继续执行</strong>  </p>\n<p>异步 ：A告诉B 感兴趣的事件以及通知方式，A操作继续执行自己的业务逻辑，等B监听到了响应的事件发生，B  <font color='red'><strong>通知</strong></font>  A，A再处理，</p>\n<p>Node.js 基于异步非阻塞模式下的高性能服务器</p>\n<h1 id=\"Unix-Linux的五种IO模型\"><a href=\"#Unix-Linux的五种IO模型\" class=\"headerlink\" title=\"Unix&#x2F;Linux的五种IO模型\"></a>Unix&#x2F;Linux的五种IO模型</h1><h4 id=\"阻塞blocking-同步\"><a href=\"#阻塞blocking-同步\" class=\"headerlink\" title=\"阻塞blocking 同步\"></a>阻塞blocking 同步</h4><table>\n<thead>\n<tr>\n<th>应用进程read</th>\n<th>系统调用—-&gt;</th>\n<th>内核</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>阻塞…</td>\n<td></td>\n<td>内核准备数据</td>\n</tr>\n<tr>\n<td>阻塞…</td>\n<td></td>\n<td>拷贝数据到用户进程空间</td>\n</tr>\n<tr>\n<td>应用处理数据</td>\n<td>&lt;—-返回</td>\n<td>拷贝成功</td>\n</tr>\n</tbody></table>\n<p>进程阻塞于read</p>\n<h4 id=\"非阻塞non-blocking-同步\"><a href=\"#非阻塞non-blocking-同步\" class=\"headerlink\" title=\"非阻塞non-blocking 同步\"></a>非阻塞non-blocking 同步</h4><table>\n<thead>\n<tr>\n<th>应用进程read</th>\n<th>系统调用—-&gt;</th>\n<th>内核</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>read</td>\n<td>&lt;—– EAGAIN</td>\n<td>准备数据</td>\n</tr>\n<tr>\n<td>Read</td>\n<td>&lt;—– EAGAIN</td>\n<td></td>\n</tr>\n<tr>\n<td>Read</td>\n<td>&lt;—– EAGAIN</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>拷贝数据到用户进程空间</td>\n</tr>\n<tr>\n<td>处理数据</td>\n<td>&lt;—– 返回</td>\n<td>拷贝完成</td>\n</tr>\n</tbody></table>\n<p>进程调用read， 判断EAGAIN 反复调用 </p>\n<h4 id=\"IO复用-IO-multiplexing\"><a href=\"#IO复用-IO-multiplexing\" class=\"headerlink\" title=\"IO复用 IO multiplexing\"></a>IO复用 IO multiplexing</h4><p>在一个线程调用IO复用函数，可以监视一系列fd 是同步的IO接口</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>select</th>\n<th>poll</th>\n<th>epoll</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>数组 长度限制</td>\n<td>链表无长度限制</td>\n<td>红黑树</td>\n</tr>\n<tr>\n<td></td>\n<td>需要复制到内核</td>\n<td>需要复制到内核</td>\n<td>就是建立在内核内 无需复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>连接数量多 但是只有少部分是活跃连接</td>\n</tr>\n</tbody></table>\n<h4 id=\"信号驱动signal-driven\"><a href=\"#信号驱动signal-driven\" class=\"headerlink\" title=\"信号驱动signal-driven\"></a>信号驱动signal-driven</h4><p>上述三种在第一种阶段要么阻塞， 要么不阻塞但是需要轮询，但是信号启动时第一步不需要轮询，但是第二步是同步的，也就是数据从内核空间搬移到用户空间的话需要花费用户程序自己的时间去做</p>\n<p>内核在第一个阶段是异步，在第二个阶段是同步，区别于非阻塞IO 是他提供消息通知机制，不需要用户进程不断轮询检查，减少了API的调用次数，提高效率</p>\n<h4 id=\"异步asynchronous\"><a href=\"#异步asynchronous\" class=\"headerlink\" title=\"异步asynchronous\"></a>异步asynchronous</h4><p>全都异步，第一步 第二步都是操作系统内核完成，效率高，但是编程复杂，出问题不好排查</p>\n<p>典型的异步非阻塞状态，Node.js采用的网络IO模型。</p>\n<h2 id=\"好的网络服务器设计\"><a href=\"#好的网络服务器设计\" class=\"headerlink\" title=\"好的网络服务器设计\"></a>好的网络服务器设计</h2><p><font color='blue'>one loop per thread is usually a good model </font></p>\n<p>这样多线程服务端编程的问题就转换为如何设计一个高效且易于使用的event loop，然后每个线程run一个event loop就行了（当然线程间的同步、互斥少不了，还有其它的耗时事件需要起另外的线程来做）。</p>\n<p>event loop 是 non-blocking 网络编程的核心，在现实生活中，non-blocking 几乎总是和 IOmultiplexing 一起使用，原因有两点：</p>\n<ul>\n<li><p>没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费CPU资源了。</p>\n</li>\n<li><p>IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO read()&#x2F;write()&#x2F;accept()&#x2F;connect() 都有可能阻塞当前线程，这样线程就没办法处理其他 socket上的 IO 事件了。</p>\n</li>\n</ul>\n<p>所以，当我们提到 non-blocking 的时候，实际上指的是 non-blocking + IO-multiplexing，单用其</p>\n<p>中任何一个都没有办法很好的实现功能。</p>\n<blockquote>\n<p> epoll + fork不如epoll + pthread？</p>\n</blockquote>\n<p>强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的<strong>服务器惊群</strong>现象，功能十分强大</p>\n<h2 id=\"reactor模型\"><a href=\"#reactor模型\" class=\"headerlink\" title=\"reactor模型\"></a>reactor模型</h2><blockquote>\n<p>The reactor design pattern is an event handling pattern for handling service requests</p>\n<p>delivered concurrently to a service handler by one or more inputs. The service handler</p>\n<p>then demultiplexes the incoming requests and dispatches them synchronously to the</p>\n<p>associated request handlers.</p>\n</blockquote>\n<p><strong>重要组件</strong>：<strong>Event事件、Reactor反应堆、Demultiplex事件分发器、Evanthandler事件处理器</strong></p>\n<h1 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h1><h2 id=\"select的缺点：\"><a href=\"#select的缺点：\" class=\"headerlink\" title=\"select的缺点：\"></a>select的缺点：</h2><p>1、单个进程能够监视的<strong>文件描述符的数量存在最大限制</strong>，通常是1024，当然可以更改数量，但由于</p>\n<p>select采用<strong>轮询的方式扫描</strong>文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有</p>\n<p>这样的定义：#define __FD_SETSIZE 1024</p>\n<p>2、<strong>内核 &#x2F; 用户空间内存拷贝</strong>问题，select需要复制大量的句柄数据结构，产生巨大的开销</p>\n<p>3、select返回的是含有整个句柄的数组，<strong>应用程序需要遍历整个数组</strong>才能发现哪些句柄发生了事件</p>\n<p>4、select的触发方式是<strong>水平触发</strong>，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程</p>\n<h2 id=\"Poll\"><a href=\"#Poll\" class=\"headerlink\" title=\"Poll\"></a>Poll</h2><p>相比select模型，<strong>poll使用链表</strong>保存文件描述符，因此没有了监视文件数量的限制，但其他<strong>三个缺点依然存在。</strong></p>\n<p>以select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况</p>\n<p>下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，</p>\n<p>从内核&#x2F;用户空间大量的句柄结构内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的</p>\n<p>服务器程序，要达到100万级别的并发访问，是一个很难完成的任务。</p>\n<h2 id=\"epoll-1\"><a href=\"#epoll-1\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><p>epoll把原先的select&#x2F;poll调用分成以下3个部分：</p>\n<p>1）调用epoll_create()建立一个epoll对象（在epoll文件系统中为这个句柄对象分配资源）</p>\n<p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p>\n<p>3）调用epoll_wait收集发生的事件的fd资源</p>\n<p>如此一来，要实现上面说的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这</p>\n<p>个epoll对象中添加或者删除事件。同时，epoll_wait的效率也非常高，因为东西都放在内核空间，因为调用epoll_wait时，并没有向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p>\n<h2 id=\"LT模式\"><a href=\"#LT模式\" class=\"headerlink\" title=\"LT模式\"></a>LT模式</h2><p>内核数据还没读完，就会一直上报数据</p>\n<h2 id=\"ET模式\"><a href=\"#ET模式\" class=\"headerlink\" title=\"ET模式\"></a>ET模式</h2><p>内核数据只上报一次</p>\n<h3 id=\"muduo采用的是LT\"><a href=\"#muduo采用的是LT\" class=\"headerlink\" title=\"muduo采用的是LT\"></a><strong>muduo采用的是LT</strong></h3><ul>\n<li><p>不会丢失数据或者消息</p>\n<ul>\n<li>应用没有读取完数据，内核是会不断上报的</li>\n</ul>\n</li>\n<li><p>低延迟处理</p>\n<ul>\n<li>每次读数据只需要一次系统调用；照顾了多个连接的公平性，不会因为某个连接上的数据量过大而影响其他连接处理消息</li>\n</ul>\n</li>\n<li><p>跨平台处理</p>\n<ul>\n<li>像select一样可以跨平台使用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"muduo网络库的核心模块\"><a href=\"#muduo网络库的核心模块\" class=\"headerlink\" title=\"muduo网络库的核心模块\"></a>muduo网络库的核心模块</h2><p>Channel</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../imgs/muduo.png\" alt=\"overview\"></p>\n"},{"title":"remain","_content":"","source":"_posts/remain.md","raw":"---\ntitle: remain\n---","slug":"remain","published":1,"date":"2024-04-12T12:49:53.367Z","updated":"2024-06-09T15:15:00.377Z","comments":1,"layout":"post","photos":[],"_id":"clx7orpvx0000ngvk9snkg6yv","content":"","cover":false,"excerpt":"","more":""},{"title":"智能指针","_content":"\n\n\n### 为什么要使用智能指针？\n\n智能指针 帮助管理动态分配的内存的，可以帮助我们自动释放new出来的内存，从而避免内存泄露\n\n> 如果分配的动态内存都交给有生命周期的对象来处理，那么在对象过期的时候，让它的析构函数删除指向的内存，这似乎是一个好的方案？\n>\n> 智能指针就是通过这样的方法来解决指针自动释放的问题 \n\n\n\nC++ 98 提供了 auto_ptr\n\nC++11提供了unique_ptr, shared_ptr和weak_ptr\n\n### auto_ptr\n\n```c++\n#include <memory>\nauto_ptr<类型> 变量名字（new 类型）\n  \nauto_ptr<myclass> ar(new myclass)\n```\n\n\n\n智能指针 可以像正常指针一样使用\n\n```c++\nauto_ptr<myclass> ptr(new myclass());\n\nptr->func();\n(*ptr).func(); //都是合法的\n```\n\n\n\n#### 三个常用函数\n\n##### get()\n\n获取智能指针托管的指针地址\n\n但是一般不会使用也没必要去使用\n\n##### release()\n\n取消智能指针对动态内存的托管\n\n##### reset()\n\n重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉\n\n```c++\nptr().reset() //释放掉智能指针托管的指针内存，并将其置为null\nptr().reset(new myclass()) //释放掉智能指针托管的指针内存, 并更新其托管的指针\n```\n\n\n\n#### 使用建议\n\n- 不要将auto_ptr 定义为全局变量或者指针\n- 除非自己知道后果，不要吧auto_ptr智能指针赋值给同类型的另外一个智能指针\n\n\n\n#### 存在的问题\n\nc++11之后 auto_ptr已经被抛弃 使用unique_ptr代替\n\n\n\n原因\n\n- 复制或者赋值都会改变资源的所有权\n\n  ```c++\n  // auto_ptr 被C++11抛弃的主要原因\n  auto_ptr<string> p1(new string(\"I'm Li Ming!\"));\n  auto_ptr<string> p2(new string(\"I'm age 22.\"));\n  \n  cout << \"p1：\" << p1.get() << endl;\n  cout << \"p2：\" << p2.get() << endl;\n  \n  // p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，\n  // 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。\n  p1 = p2;\t\n  cout << \"p1 = p2 赋值后：\" << endl;\n  cout << \"p1：\" << p1.get() << endl;\n  cout << \"p2：\" << p2.get() << endl;\n  \n  ```\n\n  \n\n- 在STL中使用autp_ptr存在重大风险，因为容器内的元素必须支持可复制和可赋值\n\n  ```c++\n  vector<auto_ptr<string>> vec;\n  auto_ptr<string> p3(new string(\"I'm P3\"));\n  auto_ptr<string> p4(new string(\"I'm P4\"));\n  \n  // 必须使用std::move修饰成右值，才可以进行插入容器中\n  vec.push_back(std::move(p3));\n  vec.push_back(std::move(p4));\n  \n  cout << \"vec.at(0)：\" <<  *vec.at(0) << endl;\n  cout << \"vec[1]：\" <<  *vec[1] << endl;\n  \n  \n  // 风险来了：\n  vec[0] = vec[1];\t// 如果进行赋值，问题又回到了上面一个问题中。\n  cout << \"vec.at(0)：\" << *vec.at(0) << endl;\n  cout << \"vec[1]：\" << *vec[1] << endl; //此处会发生数组越界或者说访问空指针 ，为什么？\n  \n  ```\n\n- 不支持对象数组的操作\n\n  ```c++\n  auto_ptr<int[]> array(new int[5]);\t// 不能这样定义\n  ```\n\n  \n\n### Unique_ptr\n\n由于前述提到的auto_ptr的三个特性，c++11的unique_ptr被提出\n\n#### unique_ptr的特性\n\n- 两个指针不能指向同一个资源<font color = 'blue'>unique </font>\n- 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值\n- 保存指向某个对象的指针，当它本身离开作用域时会自动释放资源\n- 在容器中保存指针是安全的\n\n1. 无法左值复制赋值操作 ， 但是允许临时右值赋值和构造\n\n   因为两个指针不能指向同一个 资源，所以 <font color ='blue'> 左值赋值复制不被允许</font>\n\n   ```c++\n   unique_ptr<string> p1(new string(\"11111\"));\n   unique_ptr<string> p2(new string(\"22222\"));\n   \n   p1 = p2 ; // 禁止\n   unique_ptr<string> p3(p2); //禁止\n   \n   unique_ptr<string> p3(std::move(p1));\n   p1 = std::move(p2); //这两种就都可以，也是也auto_ptr赋值效果一样，所有权转移\n   \n   \n   ```\n\n   \n\n2. 在STL容器中使用unique_ptr, 不允许直接赋值\n\n```c++\nvector<unique_ptr<string>> vec;\nunique_ptr<string> p3(new string(\"111\"));\nunique_ptr<string> p4(new string(\"222\"));\n\nvec.push_back(std::move(p3));\nvec.push_back(std::move(p4));\n\nvec[0] = vec[1] ;// 不允许直接赋值 ，同样也是指针的原因\nvec[0] = std::move(vec[1]);  \n```\n\n\n\n3. 支持对象数组的内存管理\n\n```c++\nunique_ptr<int[]> array(new int[5]); 可以这样定义\n```\n\n\n\n### shared_ptr\n\n为了解决auto_ptr 和unique_ptr的排他性导致的问题---> shared_ptr\n\n如果需要多个指针变量共享怎么办？\n\n\n\n> 如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或者拷贝的时候，引用计数+1，当智能指针析构的时候，计数-1，如果计数为0，代表已经没有指针指向这块内存，那么管理的这个内存就会被释放，这就是 shared_ptr 采用的策略\n\n\n\n#### use_count()\n\n获取shared_ptr的引用计数\n\n\n\n#### 初始化\n\n1. 构造函数\n\n   ```c++\n   shared_ptr<int> sp1(new int(5));\n   shared_ptr<int> sp2(up1);\n   ```\n\n   \n\n2. make_shared()\n\n   ```c++\n   shared_ptr<int> sp3 = make_shared<int>(2);\n   shared_ptr<string> sp4 = make_shared<string>(\"111\");\n   shared_ptr<Myclass> sp5 = make_shared<Myclass>(...);\n   ```\n\n3. 主动释放对象\n\n   ```c++\n   sp1 = nullptr; //引用计数-1，计数归0 内存释放\n   sp1 = NULL;\n   ```\n\n4. 重置\n\n   ```c++\n   sp1.reset(); //重置为空指针，计数-1\n   sp1.reset(sp2); //重置为sp2，sp1计数-1，sp2计数+1，\n   sp1.reset(sp2,d) //重置为sp2，并且使用d 作为删除器\n   ```\n\n5. 交换\n\n   ```c++\n   std::swap(up1, up2); //交换 管理对象，但是原有的引用计数不变\n   up1.swap(up2);\n   ```\n\n\n\n\n\n#### 循环引用\n\n当A引用了B，B又引用了A，这两个对象就会因为循环引用导致引用计数始终不为0，从而导致无法释放资源\n\n\n\n### Weak_ptr\n\nweak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, \n\n<font color='blue'>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</font> 同时weak_ptr 没有重载*和->，\n\n但可以<font color='red'>使用 lock 提升 </font>从而获得一个可用的 shared_ptr 对象。\n\n也就是 weak_ptr 并不能直接使用，他只是保存了一个指针对象，需要使用的时候，需要使用<font color = 'blue'>lock()提升</font>\n\n#### 使用\n\n```c++\nweak_ptr wp1;\nweak_ptr wp2(sp1);\nweak_ptr wp3 = wp2;\n\nwp2.use_count(); // 获取引用计数\n```\n\n\n\n上面那种循环引用的问题就可以可以使用weak_ptr来解决，在类中使用弱指针来接管共享指针，在需要使用的时候就转换成共享指针去使用\n\n#### Expired 函数\n\n使用expired函数判断weak_ptr() 指针的合法性\n\n```c++\n// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true\nif(!wp.expired()){\n  // 有效，还有托管的指针\n}\nelse{\n  // 过期了，没有托管的指针\n}\n```\n\n\n\n\n\n### 智能指针使用的注意事项\n\n- 不要把一个原生指针给多个智能指针管理\n\n  ```c++\n  int *x = new int(10);\n  unique_ptr<int> up1(x);\n  unique_ptr<int> up2(x);\n  \n  //后续释放的时候会发生二次释放堆区内存，报错\n  //或者以下形式：\n  up1.reset(x);\n  up2.reset(x);\n  ```\n\n- 记得使用ptr.release()的返回值\n\n在调用u.release()时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就会泄漏\n\n- 禁止使用delete 智能智能get函数返回的指针\n\n如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放\n\n- 禁止用任何类型智能指针get 函数返回的指针去初始化另外一个智能指针！\n\n  ```c++\n  shared_ptr< int > sp1(new int(10));\n  // 一个典型的错误用法 shared_ptr< int > sp4(sp1.get());\n  // 同样也会造成重复释放\n  // 推荐使用这个 shared_ptr< int > sp4(sp1);\n  ```\n\n  ","source":"_posts/智能指针.md","raw":"---\ntitle: 智能指针\n---\n\n\n\n### 为什么要使用智能指针？\n\n智能指针 帮助管理动态分配的内存的，可以帮助我们自动释放new出来的内存，从而避免内存泄露\n\n> 如果分配的动态内存都交给有生命周期的对象来处理，那么在对象过期的时候，让它的析构函数删除指向的内存，这似乎是一个好的方案？\n>\n> 智能指针就是通过这样的方法来解决指针自动释放的问题 \n\n\n\nC++ 98 提供了 auto_ptr\n\nC++11提供了unique_ptr, shared_ptr和weak_ptr\n\n### auto_ptr\n\n```c++\n#include <memory>\nauto_ptr<类型> 变量名字（new 类型）\n  \nauto_ptr<myclass> ar(new myclass)\n```\n\n\n\n智能指针 可以像正常指针一样使用\n\n```c++\nauto_ptr<myclass> ptr(new myclass());\n\nptr->func();\n(*ptr).func(); //都是合法的\n```\n\n\n\n#### 三个常用函数\n\n##### get()\n\n获取智能指针托管的指针地址\n\n但是一般不会使用也没必要去使用\n\n##### release()\n\n取消智能指针对动态内存的托管\n\n##### reset()\n\n重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉\n\n```c++\nptr().reset() //释放掉智能指针托管的指针内存，并将其置为null\nptr().reset(new myclass()) //释放掉智能指针托管的指针内存, 并更新其托管的指针\n```\n\n\n\n#### 使用建议\n\n- 不要将auto_ptr 定义为全局变量或者指针\n- 除非自己知道后果，不要吧auto_ptr智能指针赋值给同类型的另外一个智能指针\n\n\n\n#### 存在的问题\n\nc++11之后 auto_ptr已经被抛弃 使用unique_ptr代替\n\n\n\n原因\n\n- 复制或者赋值都会改变资源的所有权\n\n  ```c++\n  // auto_ptr 被C++11抛弃的主要原因\n  auto_ptr<string> p1(new string(\"I'm Li Ming!\"));\n  auto_ptr<string> p2(new string(\"I'm age 22.\"));\n  \n  cout << \"p1：\" << p1.get() << endl;\n  cout << \"p2：\" << p2.get() << endl;\n  \n  // p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，\n  // 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。\n  p1 = p2;\t\n  cout << \"p1 = p2 赋值后：\" << endl;\n  cout << \"p1：\" << p1.get() << endl;\n  cout << \"p2：\" << p2.get() << endl;\n  \n  ```\n\n  \n\n- 在STL中使用autp_ptr存在重大风险，因为容器内的元素必须支持可复制和可赋值\n\n  ```c++\n  vector<auto_ptr<string>> vec;\n  auto_ptr<string> p3(new string(\"I'm P3\"));\n  auto_ptr<string> p4(new string(\"I'm P4\"));\n  \n  // 必须使用std::move修饰成右值，才可以进行插入容器中\n  vec.push_back(std::move(p3));\n  vec.push_back(std::move(p4));\n  \n  cout << \"vec.at(0)：\" <<  *vec.at(0) << endl;\n  cout << \"vec[1]：\" <<  *vec[1] << endl;\n  \n  \n  // 风险来了：\n  vec[0] = vec[1];\t// 如果进行赋值，问题又回到了上面一个问题中。\n  cout << \"vec.at(0)：\" << *vec.at(0) << endl;\n  cout << \"vec[1]：\" << *vec[1] << endl; //此处会发生数组越界或者说访问空指针 ，为什么？\n  \n  ```\n\n- 不支持对象数组的操作\n\n  ```c++\n  auto_ptr<int[]> array(new int[5]);\t// 不能这样定义\n  ```\n\n  \n\n### Unique_ptr\n\n由于前述提到的auto_ptr的三个特性，c++11的unique_ptr被提出\n\n#### unique_ptr的特性\n\n- 两个指针不能指向同一个资源<font color = 'blue'>unique </font>\n- 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值\n- 保存指向某个对象的指针，当它本身离开作用域时会自动释放资源\n- 在容器中保存指针是安全的\n\n1. 无法左值复制赋值操作 ， 但是允许临时右值赋值和构造\n\n   因为两个指针不能指向同一个 资源，所以 <font color ='blue'> 左值赋值复制不被允许</font>\n\n   ```c++\n   unique_ptr<string> p1(new string(\"11111\"));\n   unique_ptr<string> p2(new string(\"22222\"));\n   \n   p1 = p2 ; // 禁止\n   unique_ptr<string> p3(p2); //禁止\n   \n   unique_ptr<string> p3(std::move(p1));\n   p1 = std::move(p2); //这两种就都可以，也是也auto_ptr赋值效果一样，所有权转移\n   \n   \n   ```\n\n   \n\n2. 在STL容器中使用unique_ptr, 不允许直接赋值\n\n```c++\nvector<unique_ptr<string>> vec;\nunique_ptr<string> p3(new string(\"111\"));\nunique_ptr<string> p4(new string(\"222\"));\n\nvec.push_back(std::move(p3));\nvec.push_back(std::move(p4));\n\nvec[0] = vec[1] ;// 不允许直接赋值 ，同样也是指针的原因\nvec[0] = std::move(vec[1]);  \n```\n\n\n\n3. 支持对象数组的内存管理\n\n```c++\nunique_ptr<int[]> array(new int[5]); 可以这样定义\n```\n\n\n\n### shared_ptr\n\n为了解决auto_ptr 和unique_ptr的排他性导致的问题---> shared_ptr\n\n如果需要多个指针变量共享怎么办？\n\n\n\n> 如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或者拷贝的时候，引用计数+1，当智能指针析构的时候，计数-1，如果计数为0，代表已经没有指针指向这块内存，那么管理的这个内存就会被释放，这就是 shared_ptr 采用的策略\n\n\n\n#### use_count()\n\n获取shared_ptr的引用计数\n\n\n\n#### 初始化\n\n1. 构造函数\n\n   ```c++\n   shared_ptr<int> sp1(new int(5));\n   shared_ptr<int> sp2(up1);\n   ```\n\n   \n\n2. make_shared()\n\n   ```c++\n   shared_ptr<int> sp3 = make_shared<int>(2);\n   shared_ptr<string> sp4 = make_shared<string>(\"111\");\n   shared_ptr<Myclass> sp5 = make_shared<Myclass>(...);\n   ```\n\n3. 主动释放对象\n\n   ```c++\n   sp1 = nullptr; //引用计数-1，计数归0 内存释放\n   sp1 = NULL;\n   ```\n\n4. 重置\n\n   ```c++\n   sp1.reset(); //重置为空指针，计数-1\n   sp1.reset(sp2); //重置为sp2，sp1计数-1，sp2计数+1，\n   sp1.reset(sp2,d) //重置为sp2，并且使用d 作为删除器\n   ```\n\n5. 交换\n\n   ```c++\n   std::swap(up1, up2); //交换 管理对象，但是原有的引用计数不变\n   up1.swap(up2);\n   ```\n\n\n\n\n\n#### 循环引用\n\n当A引用了B，B又引用了A，这两个对象就会因为循环引用导致引用计数始终不为0，从而导致无法释放资源\n\n\n\n### Weak_ptr\n\nweak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, \n\n<font color='blue'>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</font> 同时weak_ptr 没有重载*和->，\n\n但可以<font color='red'>使用 lock 提升 </font>从而获得一个可用的 shared_ptr 对象。\n\n也就是 weak_ptr 并不能直接使用，他只是保存了一个指针对象，需要使用的时候，需要使用<font color = 'blue'>lock()提升</font>\n\n#### 使用\n\n```c++\nweak_ptr wp1;\nweak_ptr wp2(sp1);\nweak_ptr wp3 = wp2;\n\nwp2.use_count(); // 获取引用计数\n```\n\n\n\n上面那种循环引用的问题就可以可以使用weak_ptr来解决，在类中使用弱指针来接管共享指针，在需要使用的时候就转换成共享指针去使用\n\n#### Expired 函数\n\n使用expired函数判断weak_ptr() 指针的合法性\n\n```c++\n// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true\nif(!wp.expired()){\n  // 有效，还有托管的指针\n}\nelse{\n  // 过期了，没有托管的指针\n}\n```\n\n\n\n\n\n### 智能指针使用的注意事项\n\n- 不要把一个原生指针给多个智能指针管理\n\n  ```c++\n  int *x = new int(10);\n  unique_ptr<int> up1(x);\n  unique_ptr<int> up2(x);\n  \n  //后续释放的时候会发生二次释放堆区内存，报错\n  //或者以下形式：\n  up1.reset(x);\n  up2.reset(x);\n  ```\n\n- 记得使用ptr.release()的返回值\n\n在调用u.release()时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就会泄漏\n\n- 禁止使用delete 智能智能get函数返回的指针\n\n如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放\n\n- 禁止用任何类型智能指针get 函数返回的指针去初始化另外一个智能指针！\n\n  ```c++\n  shared_ptr< int > sp1(new int(10));\n  // 一个典型的错误用法 shared_ptr< int > sp4(sp1.get());\n  // 同样也会造成重复释放\n  // 推荐使用这个 shared_ptr< int > sp4(sp1);\n  ```\n\n  ","slug":"智能指针","published":1,"date":"2024-06-25T08:28:53.367Z","updated":"2024-06-25T08:31:26.287Z","_id":"clxu5b7o500000o0ycs5ha9o4","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"为什么要使用智能指针？\"><a href=\"#为什么要使用智能指针？\" class=\"headerlink\" title=\"为什么要使用智能指针？\"></a>为什么要使用智能指针？</h3><p>智能指针 帮助管理动态分配的内存的，可以帮助我们自动释放new出来的内存，从而避免内存泄露</p>\n<blockquote>\n<p>如果分配的动态内存都交给有生命周期的对象来处理，那么在对象过期的时候，让它的析构函数删除指向的内存，这似乎是一个好的方案？</p>\n<p>智能指针就是通过这样的方法来解决指针自动释放的问题 </p>\n</blockquote>\n<p>C++ 98 提供了 auto_ptr</p>\n<p>C++11提供了unique_ptr, shared_ptr和weak_ptr</p>\n<h3 id=\"auto-ptr\"><a href=\"#auto-ptr\" class=\"headerlink\" title=\"auto_ptr\"></a>auto_ptr</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\">auto_ptr&lt;类型&gt; 变量名字（<span class=\"keyword\">new</span> 类型）</span><br><span class=\"line\">  </span><br><span class=\"line\">auto_ptr&lt;myclass&gt; <span class=\"built_in\">ar</span>(<span class=\"keyword\">new</span> myclass)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>智能指针 可以像正常指针一样使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">auto_ptr&lt;myclass&gt; <span class=\"title\">ptr</span><span class=\"params\">(<span class=\"keyword\">new</span> myclass())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ptr-&gt;<span class=\"built_in\">func</span>();</span><br><span class=\"line\">(*ptr).<span class=\"built_in\">func</span>(); <span class=\"comment\">//都是合法的</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"三个常用函数\"><a href=\"#三个常用函数\" class=\"headerlink\" title=\"三个常用函数\"></a>三个常用函数</h4><h5 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h5><p>获取智能指针托管的指针地址</p>\n<p>但是一般不会使用也没必要去使用</p>\n<h5 id=\"release\"><a href=\"#release\" class=\"headerlink\" title=\"release()\"></a>release()</h5><p>取消智能指针对动态内存的托管</p>\n<h5 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset()\"></a>reset()</h5><p>重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ptr</span>().<span class=\"built_in\">reset</span>() <span class=\"comment\">//释放掉智能指针托管的指针内存，并将其置为null</span></span><br><span class=\"line\"><span class=\"built_in\">ptr</span>().<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">myclass</span>()) <span class=\"comment\">//释放掉智能指针托管的指针内存, 并更新其托管的指针</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h4><ul>\n<li>不要将auto_ptr 定义为全局变量或者指针</li>\n<li>除非自己知道后果，不要吧auto_ptr智能指针赋值给同类型的另外一个智能指针</li>\n</ul>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><p>c++11之后 auto_ptr已经被抛弃 使用unique_ptr代替</p>\n<p>原因</p>\n<ul>\n<li><p>复制或者赋值都会改变资源的所有权</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// auto_ptr 被C++11抛弃的主要原因</span></span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p1：&quot;</span> &lt;&lt; p1.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p2：&quot;</span> &lt;&lt; p2.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，</span></span><br><span class=\"line\"><span class=\"comment\">// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。</span></span><br><span class=\"line\">p1 = p2;\t</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p1：&quot;</span> &lt;&lt; p1.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p2：&quot;</span> &lt;&lt; p2.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>在STL中使用autp_ptr存在重大风险，因为容器内的元素必须支持可复制和可赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;auto_ptr&lt;string&gt;&gt; vec;</span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m P3&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p4</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m P4&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 必须使用std::move修饰成右值，才可以进行插入容器中</span></span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p3));</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p4));</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec.at(0)：&quot;</span> &lt;&lt;  *vec.<span class=\"built_in\">at</span>(<span class=\"number\">0</span>) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec[1]：&quot;</span> &lt;&lt;  *vec[<span class=\"number\">1</span>] &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 风险来了：</span></span><br><span class=\"line\">vec[<span class=\"number\">0</span>] = vec[<span class=\"number\">1</span>];\t<span class=\"comment\">// 如果进行赋值，问题又回到了上面一个问题中。</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class=\"built_in\">at</span>(<span class=\"number\">0</span>) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class=\"number\">1</span>] &lt;&lt; endl; <span class=\"comment\">//此处会发生数组越界或者说访问空指针 ，为什么？</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不支持对象数组的操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">auto_ptr&lt;<span class=\"type\">int</span>[]&gt; <span class=\"title\">array</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">5</span>])</span></span>;\t<span class=\"comment\">// 不能这样定义</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Unique-ptr\"><a href=\"#Unique-ptr\" class=\"headerlink\" title=\"Unique_ptr\"></a>Unique_ptr</h3><p>由于前述提到的auto_ptr的三个特性，c++11的unique_ptr被提出</p>\n<h4 id=\"unique-ptr的特性\"><a href=\"#unique-ptr的特性\" class=\"headerlink\" title=\"unique_ptr的特性\"></a>unique_ptr的特性</h4><ul>\n<li>两个指针不能指向同一个资源<font color = 'blue'>unique </font></li>\n<li>无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值</li>\n<li>保存指向某个对象的指针，当它本身离开作用域时会自动释放资源</li>\n<li>在容器中保存指针是安全的</li>\n</ul>\n<ol>\n<li><p>无法左值复制赋值操作 ， 但是允许临时右值赋值和构造</p>\n<p>因为两个指针不能指向同一个 资源，所以 <font color ='blue'> 左值赋值复制不被允许</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;11111&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;22222&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">p1 = p2 ; <span class=\"comment\">// 禁止</span></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(p2)</span></span>; <span class=\"comment\">//禁止</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(std::move(p1))</span></span>;</span><br><span class=\"line\">p1 = std::<span class=\"built_in\">move</span>(p2); <span class=\"comment\">//这两种就都可以，也是也auto_ptr赋值效果一样，所有权转移</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>在STL容器中使用unique_ptr, 不允许直接赋值</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;unique_ptr&lt;string&gt;&gt; vec;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;111&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p4</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;222&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p3));</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p4));</span><br><span class=\"line\"></span><br><span class=\"line\">vec[<span class=\"number\">0</span>] = vec[<span class=\"number\">1</span>] ;<span class=\"comment\">// 不允许直接赋值 ，同样也是指针的原因</span></span><br><span class=\"line\">vec[<span class=\"number\">0</span>] = std::<span class=\"built_in\">move</span>(vec[<span class=\"number\">1</span>]);  </span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>支持对象数组的内存管理</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>[]&gt; <span class=\"title\">array</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">5</span>])</span></span>; 可以这样定义</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"shared-ptr\"><a href=\"#shared-ptr\" class=\"headerlink\" title=\"shared_ptr\"></a>shared_ptr</h3><p>为了解决auto_ptr 和unique_ptr的排他性导致的问题—&gt; shared_ptr</p>\n<p>如果需要多个指针变量共享怎么办？</p>\n<blockquote>\n<p>如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或者拷贝的时候，引用计数+1，当智能指针析构的时候，计数-1，如果计数为0，代表已经没有指针指向这块内存，那么管理的这个内存就会被释放，这就是 shared_ptr 采用的策略</p>\n</blockquote>\n<h4 id=\"use-count\"><a href=\"#use-count\" class=\"headerlink\" title=\"use_count()\"></a>use_count()</h4><p>获取shared_ptr的引用计数</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><ol>\n<li><p>构造函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sp1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">5</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sp2</span><span class=\"params\">(up1)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>make_shared()</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"type\">int</span>&gt; sp3 = <span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">shared_ptr&lt;string&gt; sp4 = <span class=\"built_in\">make_shared</span>&lt;string&gt;(<span class=\"string\">&quot;111&quot;</span>);</span><br><span class=\"line\">shared_ptr&lt;Myclass&gt; sp5 = <span class=\"built_in\">make_shared</span>&lt;Myclass&gt;(...);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>主动释放对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1 = <span class=\"literal\">nullptr</span>; <span class=\"comment\">//引用计数-1，计数归0 内存释放</span></span><br><span class=\"line\">sp1 = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1.<span class=\"built_in\">reset</span>(); <span class=\"comment\">//重置为空指针，计数-1</span></span><br><span class=\"line\">sp1.<span class=\"built_in\">reset</span>(sp2); <span class=\"comment\">//重置为sp2，sp1计数-1，sp2计数+1，</span></span><br><span class=\"line\">sp1.<span class=\"built_in\">reset</span>(sp2,d) <span class=\"comment\">//重置为sp2，并且使用d 作为删除器</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>交换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">swap</span>(up1, up2); <span class=\"comment\">//交换 管理对象，但是原有的引用计数不变</span></span><br><span class=\"line\">up1.<span class=\"built_in\">swap</span>(up2);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>当A引用了B，B又引用了A，这两个对象就会因为循环引用导致引用计数始终不为0，从而导致无法释放资源</p>\n<h3 id=\"Weak-ptr\"><a href=\"#Weak-ptr\" class=\"headerlink\" title=\"Weak_ptr\"></a>Weak_ptr</h3><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, </p>\n<p><font color='blue'>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</font> 同时weak_ptr 没有重载*和-&gt;，</p>\n<p>但可以<font color='red'>使用 lock 提升 </font>从而获得一个可用的 shared_ptr 对象。</p>\n<p>也就是 weak_ptr 并不能直接使用，他只是保存了一个指针对象，需要使用的时候，需要使用<font color = 'blue'>lock()提升</font></p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr wp1;</span><br><span class=\"line\"><span class=\"function\">weak_ptr <span class=\"title\">wp2</span><span class=\"params\">(sp1)</span></span>;</span><br><span class=\"line\">weak_ptr wp3 = wp2;</span><br><span class=\"line\"></span><br><span class=\"line\">wp2.<span class=\"built_in\">use_count</span>(); <span class=\"comment\">// 获取引用计数</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>上面那种循环引用的问题就可以可以使用weak_ptr来解决，在类中使用弱指针来接管共享指针，在需要使用的时候就转换成共享指针去使用</p>\n<h4 id=\"Expired-函数\"><a href=\"#Expired-函数\" class=\"headerlink\" title=\"Expired 函数\"></a>Expired 函数</h4><p>使用expired函数判断weak_ptr() 指针的合法性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!wp.<span class=\"built_in\">expired</span>())&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 有效，还有托管的指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 过期了，没有托管的指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"智能指针使用的注意事项\"><a href=\"#智能指针使用的注意事项\" class=\"headerlink\" title=\"智能指针使用的注意事项\"></a>智能指针使用的注意事项</h3><ul>\n<li><p>不要把一个原生指针给多个智能指针管理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *x = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">up1</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">up2</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后续释放的时候会发生二次释放堆区内存，报错</span></span><br><span class=\"line\"><span class=\"comment\">//或者以下形式：</span></span><br><span class=\"line\">up1.<span class=\"built_in\">reset</span>(x);</span><br><span class=\"line\">up2.<span class=\"built_in\">reset</span>(x);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>记得使用ptr.release()的返回值</p>\n</li>\n</ul>\n<p>在调用u.release()时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就会泄漏</p>\n<ul>\n<li>禁止使用delete 智能智能get函数返回的指针</li>\n</ul>\n<p>如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放</p>\n<ul>\n<li><p>禁止用任何类型智能指针get 函数返回的指针去初始化另外一个智能指针！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt; <span class=\"type\">int</span> &gt; <span class=\"title\">sp1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 一个典型的错误用法 shared_ptr&lt; int &gt; sp4(sp1.get());</span></span><br><span class=\"line\"><span class=\"comment\">// 同样也会造成重复释放</span></span><br><span class=\"line\"><span class=\"comment\">// 推荐使用这个 shared_ptr&lt; int &gt; sp4(sp1);</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","cover":false,"excerpt":"","more":"<h3 id=\"为什么要使用智能指针？\"><a href=\"#为什么要使用智能指针？\" class=\"headerlink\" title=\"为什么要使用智能指针？\"></a>为什么要使用智能指针？</h3><p>智能指针 帮助管理动态分配的内存的，可以帮助我们自动释放new出来的内存，从而避免内存泄露</p>\n<blockquote>\n<p>如果分配的动态内存都交给有生命周期的对象来处理，那么在对象过期的时候，让它的析构函数删除指向的内存，这似乎是一个好的方案？</p>\n<p>智能指针就是通过这样的方法来解决指针自动释放的问题 </p>\n</blockquote>\n<p>C++ 98 提供了 auto_ptr</p>\n<p>C++11提供了unique_ptr, shared_ptr和weak_ptr</p>\n<h3 id=\"auto-ptr\"><a href=\"#auto-ptr\" class=\"headerlink\" title=\"auto_ptr\"></a>auto_ptr</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\">auto_ptr&lt;类型&gt; 变量名字（<span class=\"keyword\">new</span> 类型）</span><br><span class=\"line\">  </span><br><span class=\"line\">auto_ptr&lt;myclass&gt; <span class=\"built_in\">ar</span>(<span class=\"keyword\">new</span> myclass)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>智能指针 可以像正常指针一样使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">auto_ptr&lt;myclass&gt; <span class=\"title\">ptr</span><span class=\"params\">(<span class=\"keyword\">new</span> myclass())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ptr-&gt;<span class=\"built_in\">func</span>();</span><br><span class=\"line\">(*ptr).<span class=\"built_in\">func</span>(); <span class=\"comment\">//都是合法的</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"三个常用函数\"><a href=\"#三个常用函数\" class=\"headerlink\" title=\"三个常用函数\"></a>三个常用函数</h4><h5 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h5><p>获取智能指针托管的指针地址</p>\n<p>但是一般不会使用也没必要去使用</p>\n<h5 id=\"release\"><a href=\"#release\" class=\"headerlink\" title=\"release()\"></a>release()</h5><p>取消智能指针对动态内存的托管</p>\n<h5 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset()\"></a>reset()</h5><p>重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ptr</span>().<span class=\"built_in\">reset</span>() <span class=\"comment\">//释放掉智能指针托管的指针内存，并将其置为null</span></span><br><span class=\"line\"><span class=\"built_in\">ptr</span>().<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">myclass</span>()) <span class=\"comment\">//释放掉智能指针托管的指针内存, 并更新其托管的指针</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h4><ul>\n<li>不要将auto_ptr 定义为全局变量或者指针</li>\n<li>除非自己知道后果，不要吧auto_ptr智能指针赋值给同类型的另外一个智能指针</li>\n</ul>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><p>c++11之后 auto_ptr已经被抛弃 使用unique_ptr代替</p>\n<p>原因</p>\n<ul>\n<li><p>复制或者赋值都会改变资源的所有权</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// auto_ptr 被C++11抛弃的主要原因</span></span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p1：&quot;</span> &lt;&lt; p1.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p2：&quot;</span> &lt;&lt; p2.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，</span></span><br><span class=\"line\"><span class=\"comment\">// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。</span></span><br><span class=\"line\">p1 = p2;\t</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p1：&quot;</span> &lt;&lt; p1.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;p2：&quot;</span> &lt;&lt; p2.<span class=\"built_in\">get</span>() &lt;&lt; endl;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>在STL中使用autp_ptr存在重大风险，因为容器内的元素必须支持可复制和可赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;auto_ptr&lt;string&gt;&gt; vec;</span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m P3&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">auto_ptr&lt;string&gt; <span class=\"title\">p4</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;I&#x27;m P4&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 必须使用std::move修饰成右值，才可以进行插入容器中</span></span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p3));</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p4));</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec.at(0)：&quot;</span> &lt;&lt;  *vec.<span class=\"built_in\">at</span>(<span class=\"number\">0</span>) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec[1]：&quot;</span> &lt;&lt;  *vec[<span class=\"number\">1</span>] &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 风险来了：</span></span><br><span class=\"line\">vec[<span class=\"number\">0</span>] = vec[<span class=\"number\">1</span>];\t<span class=\"comment\">// 如果进行赋值，问题又回到了上面一个问题中。</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class=\"built_in\">at</span>(<span class=\"number\">0</span>) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class=\"number\">1</span>] &lt;&lt; endl; <span class=\"comment\">//此处会发生数组越界或者说访问空指针 ，为什么？</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不支持对象数组的操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">auto_ptr&lt;<span class=\"type\">int</span>[]&gt; <span class=\"title\">array</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">5</span>])</span></span>;\t<span class=\"comment\">// 不能这样定义</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Unique-ptr\"><a href=\"#Unique-ptr\" class=\"headerlink\" title=\"Unique_ptr\"></a>Unique_ptr</h3><p>由于前述提到的auto_ptr的三个特性，c++11的unique_ptr被提出</p>\n<h4 id=\"unique-ptr的特性\"><a href=\"#unique-ptr的特性\" class=\"headerlink\" title=\"unique_ptr的特性\"></a>unique_ptr的特性</h4><ul>\n<li>两个指针不能指向同一个资源<font color = 'blue'>unique </font></li>\n<li>无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值</li>\n<li>保存指向某个对象的指针，当它本身离开作用域时会自动释放资源</li>\n<li>在容器中保存指针是安全的</li>\n</ul>\n<ol>\n<li><p>无法左值复制赋值操作 ， 但是允许临时右值赋值和构造</p>\n<p>因为两个指针不能指向同一个 资源，所以 <font color ='blue'> 左值赋值复制不被允许</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;11111&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;22222&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">p1 = p2 ; <span class=\"comment\">// 禁止</span></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(p2)</span></span>; <span class=\"comment\">//禁止</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(std::move(p1))</span></span>;</span><br><span class=\"line\">p1 = std::<span class=\"built_in\">move</span>(p2); <span class=\"comment\">//这两种就都可以，也是也auto_ptr赋值效果一样，所有权转移</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>在STL容器中使用unique_ptr, 不允许直接赋值</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;unique_ptr&lt;string&gt;&gt; vec;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p3</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;111&quot;</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;string&gt; <span class=\"title\">p4</span><span class=\"params\">(<span class=\"keyword\">new</span> string(<span class=\"string\">&quot;222&quot;</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p3));</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">move</span>(p4));</span><br><span class=\"line\"></span><br><span class=\"line\">vec[<span class=\"number\">0</span>] = vec[<span class=\"number\">1</span>] ;<span class=\"comment\">// 不允许直接赋值 ，同样也是指针的原因</span></span><br><span class=\"line\">vec[<span class=\"number\">0</span>] = std::<span class=\"built_in\">move</span>(vec[<span class=\"number\">1</span>]);  </span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>支持对象数组的内存管理</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>[]&gt; <span class=\"title\">array</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">5</span>])</span></span>; 可以这样定义</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"shared-ptr\"><a href=\"#shared-ptr\" class=\"headerlink\" title=\"shared_ptr\"></a>shared_ptr</h3><p>为了解决auto_ptr 和unique_ptr的排他性导致的问题—&gt; shared_ptr</p>\n<p>如果需要多个指针变量共享怎么办？</p>\n<blockquote>\n<p>如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或者拷贝的时候，引用计数+1，当智能指针析构的时候，计数-1，如果计数为0，代表已经没有指针指向这块内存，那么管理的这个内存就会被释放，这就是 shared_ptr 采用的策略</p>\n</blockquote>\n<h4 id=\"use-count\"><a href=\"#use-count\" class=\"headerlink\" title=\"use_count()\"></a>use_count()</h4><p>获取shared_ptr的引用计数</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><ol>\n<li><p>构造函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sp1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">5</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">shared_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sp2</span><span class=\"params\">(up1)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>make_shared()</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;<span class=\"type\">int</span>&gt; sp3 = <span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\">shared_ptr&lt;string&gt; sp4 = <span class=\"built_in\">make_shared</span>&lt;string&gt;(<span class=\"string\">&quot;111&quot;</span>);</span><br><span class=\"line\">shared_ptr&lt;Myclass&gt; sp5 = <span class=\"built_in\">make_shared</span>&lt;Myclass&gt;(...);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>主动释放对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1 = <span class=\"literal\">nullptr</span>; <span class=\"comment\">//引用计数-1，计数归0 内存释放</span></span><br><span class=\"line\">sp1 = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1.<span class=\"built_in\">reset</span>(); <span class=\"comment\">//重置为空指针，计数-1</span></span><br><span class=\"line\">sp1.<span class=\"built_in\">reset</span>(sp2); <span class=\"comment\">//重置为sp2，sp1计数-1，sp2计数+1，</span></span><br><span class=\"line\">sp1.<span class=\"built_in\">reset</span>(sp2,d) <span class=\"comment\">//重置为sp2，并且使用d 作为删除器</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>交换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">swap</span>(up1, up2); <span class=\"comment\">//交换 管理对象，但是原有的引用计数不变</span></span><br><span class=\"line\">up1.<span class=\"built_in\">swap</span>(up2);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h4><p>当A引用了B，B又引用了A，这两个对象就会因为循环引用导致引用计数始终不为0，从而导致无法释放资源</p>\n<h3 id=\"Weak-ptr\"><a href=\"#Weak-ptr\" class=\"headerlink\" title=\"Weak_ptr\"></a>Weak_ptr</h3><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, </p>\n<p><font color='blue'>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</font> 同时weak_ptr 没有重载*和-&gt;，</p>\n<p>但可以<font color='red'>使用 lock 提升 </font>从而获得一个可用的 shared_ptr 对象。</p>\n<p>也就是 weak_ptr 并不能直接使用，他只是保存了一个指针对象，需要使用的时候，需要使用<font color = 'blue'>lock()提升</font></p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr wp1;</span><br><span class=\"line\"><span class=\"function\">weak_ptr <span class=\"title\">wp2</span><span class=\"params\">(sp1)</span></span>;</span><br><span class=\"line\">weak_ptr wp3 = wp2;</span><br><span class=\"line\"></span><br><span class=\"line\">wp2.<span class=\"built_in\">use_count</span>(); <span class=\"comment\">// 获取引用计数</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>上面那种循环引用的问题就可以可以使用weak_ptr来解决，在类中使用弱指针来接管共享指针，在需要使用的时候就转换成共享指针去使用</p>\n<h4 id=\"Expired-函数\"><a href=\"#Expired-函数\" class=\"headerlink\" title=\"Expired 函数\"></a>Expired 函数</h4><p>使用expired函数判断weak_ptr() 指针的合法性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!wp.<span class=\"built_in\">expired</span>())&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 有效，还有托管的指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 过期了，没有托管的指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"智能指针使用的注意事项\"><a href=\"#智能指针使用的注意事项\" class=\"headerlink\" title=\"智能指针使用的注意事项\"></a>智能指针使用的注意事项</h3><ul>\n<li><p>不要把一个原生指针给多个智能指针管理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *x = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">up1</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">up2</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后续释放的时候会发生二次释放堆区内存，报错</span></span><br><span class=\"line\"><span class=\"comment\">//或者以下形式：</span></span><br><span class=\"line\">up1.<span class=\"built_in\">reset</span>(x);</span><br><span class=\"line\">up2.<span class=\"built_in\">reset</span>(x);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>记得使用ptr.release()的返回值</p>\n</li>\n</ul>\n<p>在调用u.release()时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就会泄漏</p>\n<ul>\n<li>禁止使用delete 智能智能get函数返回的指针</li>\n</ul>\n<p>如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放</p>\n<ul>\n<li><p>禁止用任何类型智能指针get 函数返回的指针去初始化另外一个智能指针！</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">shared_ptr&lt; <span class=\"type\">int</span> &gt; <span class=\"title\">sp1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 一个典型的错误用法 shared_ptr&lt; int &gt; sp4(sp1.get());</span></span><br><span class=\"line\"><span class=\"comment\">// 同样也会造成重复释放</span></span><br><span class=\"line\"><span class=\"comment\">// 推荐使用这个 shared_ptr&lt; int &gt; sp4(sp1);</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"KMP 专题","_content":"\n### 什么是KMP\n\n说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。\n\n因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP\n\n### KMP有什么用\n\nKMP主要应用在字符串匹配上。\n\nKMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**\n\n\n\n\n\n### 什么是前缀表\n\n用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配\n\n那么前缀表：记录下标 i 之前（包括i）的字符串中，有多大长度的相同前缀后缀\n\n> 比如模式串 aabaaf ，f的位置的最长前缀后缀就是2\n\n前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力，\n\n#### 最长相等前后缀\n\n字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。\n\n**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。\n\n\n\n所以例子 **a a b a a f**的 前缀表是\n\n​\t\t**0 1 0 1 2 0**\n\n\n\n#### 前缀表与next数组\n\n**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**\n\n\n\n\n\n### 如何构造next数组\n\n使用函数遍历一遍模式串从而得到next数组\n\n这是统一 -1 的next数组\n\n**i指向后缀末尾位置**\n\n**j指向前缀末尾位置**\n\n```c++\nvoid getNext(int* next, const string& s){\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i < s.size(); i++) { // 注意i从1开始\n        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了\n            j = next[j]; // 向前回退\n        }\n        if (s[i] == s[j + 1]) { // 找到相同的前后缀\n            j++;\n        }\n        next[i] = j; // 将j（前缀的长度）赋给next[i]\n    }\n}\n```\n\nnext[i]表示i(包括i)之前最长相等的前后缀长度（其实就是j）\n\n\n\n使用next数组，用模式串匹配文本串的代码\n\n```c++\n//先调用 getNext函数获取前缀表\n// j 是 当前已经得到 匹配的地方在模版串的 位置下标\n// -1 表示还没得到匹配\nint j = -1; // 因为next数组里记录的起始位置为-1\nfor (int i = 0; i < s.size(); i++) { // 注意i就从0开始，因这里的s是文本串\n    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配 \n        j = next[j]; // j 寻找之前匹配的位置\n    }\n    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动\n        j++; // i的增加在for循环里\n    }\n    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t\n        return (i - t.size() + 1);\n    }\n}\n```\n\n\n\n### 时间复杂度分析\n\n使用next数组对文本串和模式串进行匹配的时候，文本串是从前往后遍历的，遍历到最后就可以得到结果\n\n所以时间复杂度为 遍历一次 文本串和模式串的时间 为 <font color = 'blue'>o(m+n);</font>\n\n如果是暴力匹配 则是 <font color = 'red'>o(m * n);</font>\n\n","source":"_posts/KMP.md","raw":"---\ntitle: KMP 专题\n---\n\n### 什么是KMP\n\n说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。\n\n因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP\n\n### KMP有什么用\n\nKMP主要应用在字符串匹配上。\n\nKMP的主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**\n\n\n\n\n\n### 什么是前缀表\n\n用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配\n\n那么前缀表：记录下标 i 之前（包括i）的字符串中，有多大长度的相同前缀后缀\n\n> 比如模式串 aabaaf ，f的位置的最长前缀后缀就是2\n\n前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力，\n\n#### 最长相等前后缀\n\n字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。\n\n**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。\n\n\n\n所以例子 **a a b a a f**的 前缀表是\n\n​\t\t**0 1 0 1 2 0**\n\n\n\n#### 前缀表与next数组\n\n**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**\n\n\n\n\n\n### 如何构造next数组\n\n使用函数遍历一遍模式串从而得到next数组\n\n这是统一 -1 的next数组\n\n**i指向后缀末尾位置**\n\n**j指向前缀末尾位置**\n\n```c++\nvoid getNext(int* next, const string& s){\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i < s.size(); i++) { // 注意i从1开始\n        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了\n            j = next[j]; // 向前回退\n        }\n        if (s[i] == s[j + 1]) { // 找到相同的前后缀\n            j++;\n        }\n        next[i] = j; // 将j（前缀的长度）赋给next[i]\n    }\n}\n```\n\nnext[i]表示i(包括i)之前最长相等的前后缀长度（其实就是j）\n\n\n\n使用next数组，用模式串匹配文本串的代码\n\n```c++\n//先调用 getNext函数获取前缀表\n// j 是 当前已经得到 匹配的地方在模版串的 位置下标\n// -1 表示还没得到匹配\nint j = -1; // 因为next数组里记录的起始位置为-1\nfor (int i = 0; i < s.size(); i++) { // 注意i就从0开始，因这里的s是文本串\n    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配 \n        j = next[j]; // j 寻找之前匹配的位置\n    }\n    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动\n        j++; // i的增加在for循环里\n    }\n    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t\n        return (i - t.size() + 1);\n    }\n}\n```\n\n\n\n### 时间复杂度分析\n\n使用next数组对文本串和模式串进行匹配的时候，文本串是从前往后遍历的，遍历到最后就可以得到结果\n\n所以时间复杂度为 遍历一次 文本串和模式串的时间 为 <font color = 'blue'>o(m+n);</font>\n\n如果是暴力匹配 则是 <font color = 'red'>o(m * n);</font>\n\n","slug":"KMP","published":1,"date":"2024-07-03T09:01:42.382Z","updated":"2024-07-03T09:02:02.262Z","comments":1,"layout":"post","photos":[],"_id":"cly5m01o90000y70y10qgfjh9","content":"<h3 id=\"什么是KMP\"><a href=\"#什么是KMP\" class=\"headerlink\" title=\"什么是KMP\"></a>什么是KMP</h3><p>说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。</p>\n<p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p>\n<h3 id=\"KMP有什么用\"><a href=\"#KMP有什么用\" class=\"headerlink\" title=\"KMP有什么用\"></a>KMP有什么用</h3><p>KMP主要应用在字符串匹配上。</p>\n<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>\n<h3 id=\"什么是前缀表\"><a href=\"#什么是前缀表\" class=\"headerlink\" title=\"什么是前缀表\"></a>什么是前缀表</h3><p>用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配</p>\n<p>那么前缀表：记录下标 i 之前（包括i）的字符串中，有多大长度的相同前缀后缀</p>\n<blockquote>\n<p>比如模式串 aabaaf ，f的位置的最长前缀后缀就是2</p>\n</blockquote>\n<p>前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力，</p>\n<h4 id=\"最长相等前后缀\"><a href=\"#最长相等前后缀\" class=\"headerlink\" title=\"最长相等前后缀\"></a>最长相等前后缀</h4><p>字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p>\n<p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>\n<p>所以例子 <strong>a a b a a f</strong>的 前缀表是</p>\n<p>​\t\t<strong>0 1 0 1 2 0</strong></p>\n<h4 id=\"前缀表与next数组\"><a href=\"#前缀表与next数组\" class=\"headerlink\" title=\"前缀表与next数组\"></a>前缀表与next数组</h4><p><strong>这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p>\n<h3 id=\"如何构造next数组\"><a href=\"#如何构造next数组\" class=\"headerlink\" title=\"如何构造next数组\"></a>如何构造next数组</h3><p>使用函数遍历一遍模式串从而得到next数组</p>\n<p>这是统一 -1 的next数组</p>\n<p><strong>i指向后缀末尾位置</strong></p>\n<p><strong>j指向前缀末尾位置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getNext</span><span class=\"params\">(<span class=\"type\">int</span>* next, <span class=\"type\">const</span> string&amp; s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 注意i从1开始</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; s[i] != s[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 前后缀不相同了</span></span><br><span class=\"line\">            j = next[j]; <span class=\"comment\">// 向前回退</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == s[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 找到相同的前后缀</span></span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next[i] = j; <span class=\"comment\">// 将j（前缀的长度）赋给next[i]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>next[i]表示i(包括i)之前最长相等的前后缀长度（其实就是j）</p>\n<p>使用next数组，用模式串匹配文本串的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先调用 getNext函数获取前缀表</span></span><br><span class=\"line\"><span class=\"comment\">// j 是 当前已经得到 匹配的地方在模版串的 位置下标</span></span><br><span class=\"line\"><span class=\"comment\">// -1 表示还没得到匹配</span></span><br><span class=\"line\"><span class=\"type\">int</span> j = <span class=\"number\">-1</span>; <span class=\"comment\">// 因为next数组里记录的起始位置为-1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 注意i就从0开始，因这里的s是文本串</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; s[i] != t[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 不匹配 </span></span><br><span class=\"line\">        j = next[j]; <span class=\"comment\">// j 寻找之前匹配的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] == t[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 匹配，j和i同时向后移动</span></span><br><span class=\"line\">        j++; <span class=\"comment\">// i的增加在for循环里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == (t.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>) ) &#123; <span class=\"comment\">// 文本串s里出现了模式串t</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (i - t.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h3><p>使用next数组对文本串和模式串进行匹配的时候，文本串是从前往后遍历的，遍历到最后就可以得到结果</p>\n<p>所以时间复杂度为 遍历一次 文本串和模式串的时间 为 <font color = 'blue'>o(m+n);</font></p>\n<p>如果是暴力匹配 则是 <font color = 'red'>o(m * n);</font></p>\n","cover":false,"excerpt":"","more":"<h3 id=\"什么是KMP\"><a href=\"#什么是KMP\" class=\"headerlink\" title=\"什么是KMP\"></a>什么是KMP</h3><p>说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。</p>\n<p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p>\n<h3 id=\"KMP有什么用\"><a href=\"#KMP有什么用\" class=\"headerlink\" title=\"KMP有什么用\"></a>KMP有什么用</h3><p>KMP主要应用在字符串匹配上。</p>\n<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>\n<h3 id=\"什么是前缀表\"><a href=\"#什么是前缀表\" class=\"headerlink\" title=\"什么是前缀表\"></a>什么是前缀表</h3><p>用来回退的，它记录了模式串与文本串不匹配的时候，模式串应该从哪里开始重新匹配</p>\n<p>那么前缀表：记录下标 i 之前（包括i）的字符串中，有多大长度的相同前缀后缀</p>\n<blockquote>\n<p>比如模式串 aabaaf ，f的位置的最长前缀后缀就是2</p>\n</blockquote>\n<p>前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力，</p>\n<h4 id=\"最长相等前后缀\"><a href=\"#最长相等前后缀\" class=\"headerlink\" title=\"最长相等前后缀\"></a>最长相等前后缀</h4><p>字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p>\n<p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>\n<p>所以例子 <strong>a a b a a f</strong>的 前缀表是</p>\n<p>​\t\t<strong>0 1 0 1 2 0</strong></p>\n<h4 id=\"前缀表与next数组\"><a href=\"#前缀表与next数组\" class=\"headerlink\" title=\"前缀表与next数组\"></a>前缀表与next数组</h4><p><strong>这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p>\n<h3 id=\"如何构造next数组\"><a href=\"#如何构造next数组\" class=\"headerlink\" title=\"如何构造next数组\"></a>如何构造next数组</h3><p>使用函数遍历一遍模式串从而得到next数组</p>\n<p>这是统一 -1 的next数组</p>\n<p><strong>i指向后缀末尾位置</strong></p>\n<p><strong>j指向前缀末尾位置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getNext</span><span class=\"params\">(<span class=\"type\">int</span>* next, <span class=\"type\">const</span> string&amp; s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 注意i从1开始</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; s[i] != s[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 前后缀不相同了</span></span><br><span class=\"line\">            j = next[j]; <span class=\"comment\">// 向前回退</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == s[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 找到相同的前后缀</span></span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next[i] = j; <span class=\"comment\">// 将j（前缀的长度）赋给next[i]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>next[i]表示i(包括i)之前最长相等的前后缀长度（其实就是j）</p>\n<p>使用next数组，用模式串匹配文本串的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先调用 getNext函数获取前缀表</span></span><br><span class=\"line\"><span class=\"comment\">// j 是 当前已经得到 匹配的地方在模版串的 位置下标</span></span><br><span class=\"line\"><span class=\"comment\">// -1 表示还没得到匹配</span></span><br><span class=\"line\"><span class=\"type\">int</span> j = <span class=\"number\">-1</span>; <span class=\"comment\">// 因为next数组里记录的起始位置为-1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123; <span class=\"comment\">// 注意i就从0开始，因这里的s是文本串</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; s[i] != t[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 不匹配 </span></span><br><span class=\"line\">        j = next[j]; <span class=\"comment\">// j 寻找之前匹配的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] == t[j + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 匹配，j和i同时向后移动</span></span><br><span class=\"line\">        j++; <span class=\"comment\">// i的增加在for循环里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == (t.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>) ) &#123; <span class=\"comment\">// 文本串s里出现了模式串t</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (i - t.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h3><p>使用next数组对文本串和模式串进行匹配的时候，文本串是从前往后遍历的，遍历到最后就可以得到结果</p>\n<p>所以时间复杂度为 遍历一次 文本串和模式串的时间 为 <font color = 'blue'>o(m+n);</font></p>\n<p>如果是暴力匹配 则是 <font color = 'red'>o(m * n);</font></p>\n"},{"title":"dp","_content":"动态规划\n\n## 区间dp\n\n常用于字符串，戳气球...\n\n一般是三维 `dp[i][j][k]` 表示区间 [i,j] 内状态k 的方案数/... \n\n但是有可能超时 \n\n所以结合 线段树， 树状数组 ，二分等等\n\n\n\n## 数位dp\n\n与数字有关\n\n>  例题 2801 统计范围内的步进数字数目\n>\n>  给定两个正整数low和high 计算 闭区间[low, high]之间的步进数字数目\n>\n>  步进数字: 相邻数位之间差的绝对值 是 1 ，\n>\n>  对 1e9 + 7 取模然后返回\n>\n>  1 <= low, high <= 10^100\n\n \n\n模版\n\nf(i, pre, is_limit, is_num); 表示构造第i位及其之后数位的合法方案数量，\n\ni , pre 根据题目要求决定是否需要，后两个必须\n\npre 前一位数位是什么？\n\nis_limit 是否收到了最大数字n的限制，比如 123， 第一位取了1 ，第二位就收到了限制 ，0～2 \n\nis_num 前面是否有数字，如果前面没有数字，这一位也可以跳过，没有数字，可以是>= 1的数字，也可以跳过， 如果前面有数字，这一位就取决于is_limit\n\n\n递归入口\n\nf(0, 0, true, false);\n\n从s[0]开始枚举 ，\n\npre初始化成什么都可以，填第一个数的时候忽略了pre\n\n一开始要受到n的约束\n\n一开始没有填数字\n\n```c++\nconst int MOD = 1e9 + 7;\nint calc(string &s){\n  int m = s.size(), memo[m][10];\n  memset(memo ,-1, sizeof(memo));\n  function<int (int, int, bool, bool)> f = [&](int i, int pre, bool is_limit, bool is_num) -> int {\n    if(i == m) return is_num;// 长度满足，is_num为true表示前面的数据是合法非空的\n    if(!is_limit && is_num && memo[i][pre] != -1) return memo[i][pre];\n    int res = 0;\n    if(!is_num){ //前面没有有效数字，这一位也跳过有多少种？\n    \tres = f(i+1, pre, false, false);\n    }\n    //这一位不跳过了\n    int up = is_limit ? s[i] - '0' : 9;\n    for(int d = 1 - is_num; d<=up;d++){\n      if(!is_num || abs(d - pre) == 1){\n        res += f(i+1, d, d == up, true) % mod;\n      }\n    }\n    if(!is_limit && is_num) memo[i][pre] = res;\n    return res;\n  };\n  return f(0,0,true,false);\n}\n```\n\ncalc(high) - calc(slow-1) 就是答案，但是slow - 1不好减\n\n=》 calc(high) - calc(low) + valid(low);\n\nValid(low) 判断 low是否是步进数字，返回 1， 或者 0 \n\n```c++\nint result(string low, string high){\n  return (calc(high) - calc(low) + MOD + valid(low)) % MOD; // + MOD防止算出负数\n}\n```\n\n\n\n### 补充\n\n- (a+b)%M = (a % m + b % m)%m\n\n- (a*b)%M = ((a%M) * (b%M)) % M\n\n- 这里的f(i, pre, is_limit, is_num) 明明状态是4个，按道理记忆化递归的memo的维度也应该和函数的维度一样，为何memo只有 i和 pre两个维度？\n\n  因为 实际上这里做了简化，is_limit， is_num 有四种状态\n\n  |              | is_limit:false | is_limit:true |\n  | ------------ | -------------- | ------------- |\n  | is_num:false | A              | C             |\n  | is_num:True  | B              | D             |\n\n  A 与 C都是前面没有数字，受到限制与否不起作用，前面没有数字，则这种情况只会遍历一次，比如第一位不填，第二位也不填，后面再怎么递归也不会重新进入这种情况\n\n  B 代表前面有数字有不受到限制的情况，这实际上就是memo记录的东西\n\n  D 代表前面有数字的情况下，这一位也受到了限制，那么这种情况实际上也只会经过一次，没必要记忆，比如2344557， 第一位填2，第二位填3， 后面无论怎么递归都不会再次递归到第一位填2 ，第二位为3 的情况\n\n  也就是保存ACD这三种情况没必要，后面不会复用，只有保存B才有用，所以此刻的memo记录的就是memo[i] [pre] <mark style=\"background-color yellow\"> 不受到约束的情况下第i位开始递归 前一位数字为pre的结果有多少种</mark>\n\n  <font color='blue'>(1,3,false,false) 表示i = 0填3 ，从i=1往后随便填的方案数量</font>\n\n  \n\n## 记忆化搜索\n\ndp是顺推导，自底向上\n\n记忆化搜索是 自顶向下 递归 +  数组记忆","source":"_posts/dp.md","raw":"---\ntitle : dp\n---\n动态规划\n\n## 区间dp\n\n常用于字符串，戳气球...\n\n一般是三维 `dp[i][j][k]` 表示区间 [i,j] 内状态k 的方案数/... \n\n但是有可能超时 \n\n所以结合 线段树， 树状数组 ，二分等等\n\n\n\n## 数位dp\n\n与数字有关\n\n>  例题 2801 统计范围内的步进数字数目\n>\n>  给定两个正整数low和high 计算 闭区间[low, high]之间的步进数字数目\n>\n>  步进数字: 相邻数位之间差的绝对值 是 1 ，\n>\n>  对 1e9 + 7 取模然后返回\n>\n>  1 <= low, high <= 10^100\n\n \n\n模版\n\nf(i, pre, is_limit, is_num); 表示构造第i位及其之后数位的合法方案数量，\n\ni , pre 根据题目要求决定是否需要，后两个必须\n\npre 前一位数位是什么？\n\nis_limit 是否收到了最大数字n的限制，比如 123， 第一位取了1 ，第二位就收到了限制 ，0～2 \n\nis_num 前面是否有数字，如果前面没有数字，这一位也可以跳过，没有数字，可以是>= 1的数字，也可以跳过， 如果前面有数字，这一位就取决于is_limit\n\n\n递归入口\n\nf(0, 0, true, false);\n\n从s[0]开始枚举 ，\n\npre初始化成什么都可以，填第一个数的时候忽略了pre\n\n一开始要受到n的约束\n\n一开始没有填数字\n\n```c++\nconst int MOD = 1e9 + 7;\nint calc(string &s){\n  int m = s.size(), memo[m][10];\n  memset(memo ,-1, sizeof(memo));\n  function<int (int, int, bool, bool)> f = [&](int i, int pre, bool is_limit, bool is_num) -> int {\n    if(i == m) return is_num;// 长度满足，is_num为true表示前面的数据是合法非空的\n    if(!is_limit && is_num && memo[i][pre] != -1) return memo[i][pre];\n    int res = 0;\n    if(!is_num){ //前面没有有效数字，这一位也跳过有多少种？\n    \tres = f(i+1, pre, false, false);\n    }\n    //这一位不跳过了\n    int up = is_limit ? s[i] - '0' : 9;\n    for(int d = 1 - is_num; d<=up;d++){\n      if(!is_num || abs(d - pre) == 1){\n        res += f(i+1, d, d == up, true) % mod;\n      }\n    }\n    if(!is_limit && is_num) memo[i][pre] = res;\n    return res;\n  };\n  return f(0,0,true,false);\n}\n```\n\ncalc(high) - calc(slow-1) 就是答案，但是slow - 1不好减\n\n=》 calc(high) - calc(low) + valid(low);\n\nValid(low) 判断 low是否是步进数字，返回 1， 或者 0 \n\n```c++\nint result(string low, string high){\n  return (calc(high) - calc(low) + MOD + valid(low)) % MOD; // + MOD防止算出负数\n}\n```\n\n\n\n### 补充\n\n- (a+b)%M = (a % m + b % m)%m\n\n- (a*b)%M = ((a%M) * (b%M)) % M\n\n- 这里的f(i, pre, is_limit, is_num) 明明状态是4个，按道理记忆化递归的memo的维度也应该和函数的维度一样，为何memo只有 i和 pre两个维度？\n\n  因为 实际上这里做了简化，is_limit， is_num 有四种状态\n\n  |              | is_limit:false | is_limit:true |\n  | ------------ | -------------- | ------------- |\n  | is_num:false | A              | C             |\n  | is_num:True  | B              | D             |\n\n  A 与 C都是前面没有数字，受到限制与否不起作用，前面没有数字，则这种情况只会遍历一次，比如第一位不填，第二位也不填，后面再怎么递归也不会重新进入这种情况\n\n  B 代表前面有数字有不受到限制的情况，这实际上就是memo记录的东西\n\n  D 代表前面有数字的情况下，这一位也受到了限制，那么这种情况实际上也只会经过一次，没必要记忆，比如2344557， 第一位填2，第二位填3， 后面无论怎么递归都不会再次递归到第一位填2 ，第二位为3 的情况\n\n  也就是保存ACD这三种情况没必要，后面不会复用，只有保存B才有用，所以此刻的memo记录的就是memo[i] [pre] <mark style=\"background-color yellow\"> 不受到约束的情况下第i位开始递归 前一位数字为pre的结果有多少种</mark>\n\n  <font color='blue'>(1,3,false,false) 表示i = 0填3 ，从i=1往后随便填的方案数量</font>\n\n  \n\n## 记忆化搜索\n\ndp是顺推导，自底向上\n\n记忆化搜索是 自顶向下 递归 +  数组记忆","slug":"dp","published":1,"date":"2024-07-29T11:54:07.297Z","updated":"2024-07-29T11:54:39.863Z","comments":1,"layout":"post","photos":[],"_id":"clz6xmadk0000dd0y38seauw4","content":"<p>动态规划</p>\n<h2 id=\"区间dp\"><a href=\"#区间dp\" class=\"headerlink\" title=\"区间dp\"></a>区间dp</h2><p>常用于字符串，戳气球…</p>\n<p>一般是三维 <code>dp[i][j][k]</code> 表示区间 [i,j] 内状态k 的方案数&#x2F;… </p>\n<p>但是有可能超时 </p>\n<p>所以结合 线段树， 树状数组 ，二分等等</p>\n<h2 id=\"数位dp\"><a href=\"#数位dp\" class=\"headerlink\" title=\"数位dp\"></a>数位dp</h2><p>与数字有关</p>\n<blockquote>\n<p> 例题 2801 统计范围内的步进数字数目</p>\n<p> 给定两个正整数low和high 计算 闭区间[low, high]之间的步进数字数目</p>\n<p> 步进数字: 相邻数位之间差的绝对值 是 1 ，</p>\n<p> 对 1e9 + 7 取模然后返回</p>\n<p> 1 &lt;&#x3D; low, high &lt;&#x3D; 10^100</p>\n</blockquote>\n<p>模版</p>\n<p>f(i, pre, is_limit, is_num); 表示构造第i位及其之后数位的合法方案数量，</p>\n<p>i , pre 根据题目要求决定是否需要，后两个必须</p>\n<p>pre 前一位数位是什么？</p>\n<p>is_limit 是否收到了最大数字n的限制，比如 123， 第一位取了1 ，第二位就收到了限制 ，0～2 </p>\n<p>is_num 前面是否有数字，如果前面没有数字，这一位也可以跳过，没有数字，可以是&gt;&#x3D; 1的数字，也可以跳过， 如果前面有数字，这一位就取决于is_limit</p>\n<p>递归入口</p>\n<p>f(0, 0, true, false);</p>\n<p>从s[0]开始枚举 ，</p>\n<p>pre初始化成什么都可以，填第一个数的时候忽略了pre</p>\n<p>一开始要受到n的约束</p>\n<p>一开始没有填数字</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">calc</span><span class=\"params\">(string &amp;s)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> m = s.<span class=\"built_in\">size</span>(), memo[m][<span class=\"number\">10</span>];</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(memo ,<span class=\"number\">-1</span>, <span class=\"built_in\">sizeof</span>(memo));</span><br><span class=\"line\">  function&lt;<span class=\"type\">int</span> (<span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">bool</span>, <span class=\"type\">bool</span>)&gt; f = [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> pre, <span class=\"type\">bool</span> is_limit, <span class=\"type\">bool</span> is_num) -&gt; <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == m) <span class=\"keyword\">return</span> is_num;<span class=\"comment\">// 长度满足，is_num为true表示前面的数据是合法非空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!is_limit &amp;&amp; is_num &amp;&amp; memo[i][pre] != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> memo[i][pre];</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!is_num)&#123; <span class=\"comment\">//前面没有有效数字，这一位也跳过有多少种？</span></span><br><span class=\"line\">    \tres = <span class=\"built_in\">f</span>(i+<span class=\"number\">1</span>, pre, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这一位不跳过了</span></span><br><span class=\"line\">    <span class=\"type\">int</span> up = is_limit ? s[i] - <span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d = <span class=\"number\">1</span> - is_num; d&lt;=up;d++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!is_num || <span class=\"built_in\">abs</span>(d - pre) == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        res += <span class=\"built_in\">f</span>(i+<span class=\"number\">1</span>, d, d == up, <span class=\"literal\">true</span>) % mod;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!is_limit &amp;&amp; is_num) memo[i][pre] = res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">f</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"literal\">true</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>calc(high) - calc(slow-1) 就是答案，但是slow - 1不好减</p>\n<p>&#x3D;》 calc(high) - calc(low) + valid(low);</p>\n<p>Valid(low) 判断 low是否是步进数字，返回 1， 或者 0 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">result</span><span class=\"params\">(string low, string high)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">calc</span>(high) - <span class=\"built_in\">calc</span>(low) + MOD + <span class=\"built_in\">valid</span>(low)) % MOD; <span class=\"comment\">// + MOD防止算出负数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li><p>(a+b)%M &#x3D; (a % m + b % m)%m</p>\n</li>\n<li><p>(a*b)%M &#x3D; ((a%M) * (b%M)) % M</p>\n</li>\n<li><p>这里的f(i, pre, is_limit, is_num) 明明状态是4个，按道理记忆化递归的memo的维度也应该和函数的维度一样，为何memo只有 i和 pre两个维度？</p>\n<p>因为 实际上这里做了简化，is_limit， is_num 有四种状态</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>is_limit:false</th>\n<th>is_limit:true</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>is_num:false</td>\n<td>A</td>\n<td>C</td>\n</tr>\n<tr>\n<td>is_num:True</td>\n<td>B</td>\n<td>D</td>\n</tr>\n</tbody></table>\n<p>A 与 C都是前面没有数字，受到限制与否不起作用，前面没有数字，则这种情况只会遍历一次，比如第一位不填，第二位也不填，后面再怎么递归也不会重新进入这种情况</p>\n<p>B 代表前面有数字有不受到限制的情况，这实际上就是memo记录的东西</p>\n<p>D 代表前面有数字的情况下，这一位也受到了限制，那么这种情况实际上也只会经过一次，没必要记忆，比如2344557， 第一位填2，第二位填3， 后面无论怎么递归都不会再次递归到第一位填2 ，第二位为3 的情况</p>\n<p>也就是保存ACD这三种情况没必要，后面不会复用，只有保存B才有用，所以此刻的memo记录的就是memo[i] [pre] <mark style=\"background-color yellow\"> 不受到约束的情况下第i位开始递归 前一位数字为pre的结果有多少种</mark></p>\n<p><font color='blue'>(1,3,false,false) 表示i &#x3D; 0填3 ，从i&#x3D;1往后随便填的方案数量</font></p>\n</li>\n</ul>\n<h2 id=\"记忆化搜索\"><a href=\"#记忆化搜索\" class=\"headerlink\" title=\"记忆化搜索\"></a>记忆化搜索</h2><p>dp是顺推导，自底向上</p>\n<p>记忆化搜索是 自顶向下 递归 +  数组记忆</p>\n","cover":false,"excerpt":"","more":"<p>动态规划</p>\n<h2 id=\"区间dp\"><a href=\"#区间dp\" class=\"headerlink\" title=\"区间dp\"></a>区间dp</h2><p>常用于字符串，戳气球…</p>\n<p>一般是三维 <code>dp[i][j][k]</code> 表示区间 [i,j] 内状态k 的方案数&#x2F;… </p>\n<p>但是有可能超时 </p>\n<p>所以结合 线段树， 树状数组 ，二分等等</p>\n<h2 id=\"数位dp\"><a href=\"#数位dp\" class=\"headerlink\" title=\"数位dp\"></a>数位dp</h2><p>与数字有关</p>\n<blockquote>\n<p> 例题 2801 统计范围内的步进数字数目</p>\n<p> 给定两个正整数low和high 计算 闭区间[low, high]之间的步进数字数目</p>\n<p> 步进数字: 相邻数位之间差的绝对值 是 1 ，</p>\n<p> 对 1e9 + 7 取模然后返回</p>\n<p> 1 &lt;&#x3D; low, high &lt;&#x3D; 10^100</p>\n</blockquote>\n<p>模版</p>\n<p>f(i, pre, is_limit, is_num); 表示构造第i位及其之后数位的合法方案数量，</p>\n<p>i , pre 根据题目要求决定是否需要，后两个必须</p>\n<p>pre 前一位数位是什么？</p>\n<p>is_limit 是否收到了最大数字n的限制，比如 123， 第一位取了1 ，第二位就收到了限制 ，0～2 </p>\n<p>is_num 前面是否有数字，如果前面没有数字，这一位也可以跳过，没有数字，可以是&gt;&#x3D; 1的数字，也可以跳过， 如果前面有数字，这一位就取决于is_limit</p>\n<p>递归入口</p>\n<p>f(0, 0, true, false);</p>\n<p>从s[0]开始枚举 ，</p>\n<p>pre初始化成什么都可以，填第一个数的时候忽略了pre</p>\n<p>一开始要受到n的约束</p>\n<p>一开始没有填数字</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">calc</span><span class=\"params\">(string &amp;s)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> m = s.<span class=\"built_in\">size</span>(), memo[m][<span class=\"number\">10</span>];</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(memo ,<span class=\"number\">-1</span>, <span class=\"built_in\">sizeof</span>(memo));</span><br><span class=\"line\">  function&lt;<span class=\"type\">int</span> (<span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">bool</span>, <span class=\"type\">bool</span>)&gt; f = [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> pre, <span class=\"type\">bool</span> is_limit, <span class=\"type\">bool</span> is_num) -&gt; <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i == m) <span class=\"keyword\">return</span> is_num;<span class=\"comment\">// 长度满足，is_num为true表示前面的数据是合法非空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!is_limit &amp;&amp; is_num &amp;&amp; memo[i][pre] != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> memo[i][pre];</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!is_num)&#123; <span class=\"comment\">//前面没有有效数字，这一位也跳过有多少种？</span></span><br><span class=\"line\">    \tres = <span class=\"built_in\">f</span>(i+<span class=\"number\">1</span>, pre, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这一位不跳过了</span></span><br><span class=\"line\">    <span class=\"type\">int</span> up = is_limit ? s[i] - <span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d = <span class=\"number\">1</span> - is_num; d&lt;=up;d++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!is_num || <span class=\"built_in\">abs</span>(d - pre) == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        res += <span class=\"built_in\">f</span>(i+<span class=\"number\">1</span>, d, d == up, <span class=\"literal\">true</span>) % mod;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!is_limit &amp;&amp; is_num) memo[i][pre] = res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">f</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"literal\">true</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>calc(high) - calc(slow-1) 就是答案，但是slow - 1不好减</p>\n<p>&#x3D;》 calc(high) - calc(low) + valid(low);</p>\n<p>Valid(low) 判断 low是否是步进数字，返回 1， 或者 0 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">result</span><span class=\"params\">(string low, string high)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">calc</span>(high) - <span class=\"built_in\">calc</span>(low) + MOD + <span class=\"built_in\">valid</span>(low)) % MOD; <span class=\"comment\">// + MOD防止算出负数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li><p>(a+b)%M &#x3D; (a % m + b % m)%m</p>\n</li>\n<li><p>(a*b)%M &#x3D; ((a%M) * (b%M)) % M</p>\n</li>\n<li><p>这里的f(i, pre, is_limit, is_num) 明明状态是4个，按道理记忆化递归的memo的维度也应该和函数的维度一样，为何memo只有 i和 pre两个维度？</p>\n<p>因为 实际上这里做了简化，is_limit， is_num 有四种状态</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>is_limit:false</th>\n<th>is_limit:true</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>is_num:false</td>\n<td>A</td>\n<td>C</td>\n</tr>\n<tr>\n<td>is_num:True</td>\n<td>B</td>\n<td>D</td>\n</tr>\n</tbody></table>\n<p>A 与 C都是前面没有数字，受到限制与否不起作用，前面没有数字，则这种情况只会遍历一次，比如第一位不填，第二位也不填，后面再怎么递归也不会重新进入这种情况</p>\n<p>B 代表前面有数字有不受到限制的情况，这实际上就是memo记录的东西</p>\n<p>D 代表前面有数字的情况下，这一位也受到了限制，那么这种情况实际上也只会经过一次，没必要记忆，比如2344557， 第一位填2，第二位填3， 后面无论怎么递归都不会再次递归到第一位填2 ，第二位为3 的情况</p>\n<p>也就是保存ACD这三种情况没必要，后面不会复用，只有保存B才有用，所以此刻的memo记录的就是memo[i] [pre] <mark style=\"background-color yellow\"> 不受到约束的情况下第i位开始递归 前一位数字为pre的结果有多少种</mark></p>\n<p><font color='blue'>(1,3,false,false) 表示i &#x3D; 0填3 ，从i&#x3D;1往后随便填的方案数量</font></p>\n</li>\n</ul>\n<h2 id=\"记忆化搜索\"><a href=\"#记忆化搜索\" class=\"headerlink\" title=\"记忆化搜索\"></a>记忆化搜索</h2><p>dp是顺推导，自底向上</p>\n<p>记忆化搜索是 自顶向下 递归 +  数组记忆</p>\n"},{"title":"mhy8.3 笔试回顾","_content":"mhy8.3 笔试回顾\n\n## 选择题\n\n###  流水线的执行时间计算\n\n> 有8个磁盘块需要处理，现在有一个缓存大小和一个磁盘块一样，磁盘块搬移到缓存需要80ms， 缓存搬移到cpu需要40ms，cpu处理这个磁盘块的数据需要60ms，流水线架构需要多长时间完成？\n>\n> 如果换成双缓存，需要多长时间？\n\n![](https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/202408040053939.png)\n\n所以答案是 (80 + 40) * 8 + 60  = 1020 ms\n\n\n\n如果是双缓冲的话是多少呢？\n\n![](https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804005551.png) \n\n所以答案是 80 * 8 + 40 + 60 = 740 ms\n\n\n\n总结\n\n 把图画出来 分析清楚各个stage如何链接就可以了\n\n流水线的思想就是 一个过程如果可以被划分成实际的多个小过程，就可以使用流水线，使得每个模块都尽量不空转😈，进而提升吞吐率\n\n距离就是 洗衣服40min-烘干30min-折叠衣服20min\n\n如果有5桶衣服，洗第一桶衣服走完整个流程 也就是折叠完第一桶衣服之后才去 提第二桶衣服放到洗衣机里面洗 （问题在哪？ 在折叠衣服的时候， 洗衣机没有人用！浪费时间）\n\n还有笔者 小时候学校考的一道题， 大意是用一口锅烙饼，也是使用的流水线思想来提升效率；\n\n### 稳定的排序算法\n\n#### 什么是稳定？\n\n**稳定的排序算法**是一种在排序过程中<mark>不会改变具有相等键值的元素的相对顺序的算法。</mark>\n\n换句话说，如果在未排序的数据中有两个元素A和B，它们的值相等，并且在排序前A在B之前，那么在排序完成后A仍然会在B之前。\n\n\n\n#### 稳定具体有哪些？\n\n**冒泡排序（Bubble Sort）**：\n\n- 每次比较相邻的元素并交换它们，直到整个数组有序。\n- 稳定性：是稳定的，因为只有在前一个元素大于后一个元素时才会交换。\n\n**插入排序（Insertion Sort）**：\n\n- 从数组的第二个元素开始，依次将每个元素插入到已经排序的部分中。\n- 稳定性：是稳定的，因为只会将较大的元素向右移动，不会打乱相等元素的顺序。\n\n**归并排序（Merge Sort）**：\n\n- 递归地将数组分成两部分，然后合并时保持稳定性。\n- 稳定性：是稳定的，因为在合并过程中可以确保相等元素按原始顺序排列。\n\n**计数排序（Counting Sort）**：\n\n- 使用额外的计数数组来记录每个元素的出现次数，然后依次将元素放回原数组。\n- 稳定性：是稳定的，因为在放回元素时保持了它们的原始顺序。\n\n**基数排序（Radix Sort）**：\n\n- 逐位排序，通常从最低有效位到最高有效位，使用稳定的子排序算法（如计数排序）。\n- 稳定性：是稳定的，因为它依赖于稳定的子排序算法。\n\n\n\n#### 不稳定 \n\n**快速排序（Quick Sort）**：\n\n- 基于分治法，选择一个主元，然后对数组进行划分。\n- 不稳定性：分区过程中，可能会打乱相等元素的顺序。\n\n**堆排序（Heap Sort）**：\n\n- 基于堆数据结构，首先构建最大堆，然后不断提取最大元素。\n- 不稳定性：由于堆的重构过程，可能会打乱相等元素的顺序\n\n**希尔排序（shell sort）:**\n\n​\t 基于插入排序的 不稳定\n\n#### 寄！\n\n### 异常捕获\n\n```c++\nclass MyException {};\nclass derivedException : public MyException {};\n\nvoid func(){\n  throw deriveexception();\n}\n\nint main(){\n  try{\n    func();\n  }\n  catch(MyException &e){\n    cout << \"MyException\" << endl;\n  }\n  catch(derivedException &e){\n    cout << \"derivedException\" << endl;\n  }\n}\n```\n\n会输出什么信息？\n\n只会输出 `\"MyException\"`\n\n#### 为什么？ -  **异常处理的顺序**：\n\n在异常处理机制中，如果先捕获基类的异常，所有派生自它的异常也会被捕获，导致派生类的异常处理代码被跳过。因此，应该先捕获 `derivedException`，然后再捕获 `MyException`。\n\n#### 寄\n\n### TCP与UDP\n\n\n\n## 编程   \n\n### 模拟\n\n> 米小游有一个长度为 n 的数组，其中第 i 个元素为 ai。现在定义数组的价值是最大的相邻数字的乘积。例如数组为 [3,5,1,2] ，相邻元素的乘积分别是 3*5=15,5*1=5和1*2=2 ，则数组的价值是这些数字中的最大值，即 15。\n>\n> 现在米小游想要任选数组中的某两个相邻的元素进行交换（**你必须使用这次交换机会**），他想知道最大可以将数组的价值更改为多少\n\n从前往后遍历，两种情况\n\n```c++\nfor(int i = 0;i + 1 < nums.size() ;i++){\n   ans = max(ans, nums[i] * nums[i + 1]);\n}\n```\n\na b c\n\n对应于不换或者换相邻的两个 也就是计算 ab bc 的值，\n\n\n\n```c++\nfor(int i = 0;i + 2 < nums.size();i++){\n  ans = max(ans, nums[i] * nums[i + 2]);\n}\n```\n\n对应于 ac\n\n\n\n<mark>唯一需要注意的点就是，乘法可能结果很大，所以需要选用long long </mark>\n\n启示:\n\n<font color = 'blue'>对于C++的ACM模式而言，选用存储结果的数据类型可以直接使用long long，以后一定要注意返回的结果用什么类型的变量存储 </font>\n\n### dfs","source":"_posts/mhy_笔试.md","raw":"---\ntitle: mhy8.3 笔试回顾\ncategories:\n- 面试笔试记录\ntag:\n- 流水线\n- 排序\n- 异常处理\n- TCP UDP\n- 面试 && 笔试\n---\nmhy8.3 笔试回顾\n\n## 选择题\n\n###  流水线的执行时间计算\n\n> 有8个磁盘块需要处理，现在有一个缓存大小和一个磁盘块一样，磁盘块搬移到缓存需要80ms， 缓存搬移到cpu需要40ms，cpu处理这个磁盘块的数据需要60ms，流水线架构需要多长时间完成？\n>\n> 如果换成双缓存，需要多长时间？\n\n![](https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/202408040053939.png)\n\n所以答案是 (80 + 40) * 8 + 60  = 1020 ms\n\n\n\n如果是双缓冲的话是多少呢？\n\n![](https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804005551.png) \n\n所以答案是 80 * 8 + 40 + 60 = 740 ms\n\n\n\n总结\n\n 把图画出来 分析清楚各个stage如何链接就可以了\n\n流水线的思想就是 一个过程如果可以被划分成实际的多个小过程，就可以使用流水线，使得每个模块都尽量不空转😈，进而提升吞吐率\n\n距离就是 洗衣服40min-烘干30min-折叠衣服20min\n\n如果有5桶衣服，洗第一桶衣服走完整个流程 也就是折叠完第一桶衣服之后才去 提第二桶衣服放到洗衣机里面洗 （问题在哪？ 在折叠衣服的时候， 洗衣机没有人用！浪费时间）\n\n还有笔者 小时候学校考的一道题， 大意是用一口锅烙饼，也是使用的流水线思想来提升效率；\n\n### 稳定的排序算法\n\n#### 什么是稳定？\n\n**稳定的排序算法**是一种在排序过程中<mark>不会改变具有相等键值的元素的相对顺序的算法。</mark>\n\n换句话说，如果在未排序的数据中有两个元素A和B，它们的值相等，并且在排序前A在B之前，那么在排序完成后A仍然会在B之前。\n\n\n\n#### 稳定具体有哪些？\n\n**冒泡排序（Bubble Sort）**：\n\n- 每次比较相邻的元素并交换它们，直到整个数组有序。\n- 稳定性：是稳定的，因为只有在前一个元素大于后一个元素时才会交换。\n\n**插入排序（Insertion Sort）**：\n\n- 从数组的第二个元素开始，依次将每个元素插入到已经排序的部分中。\n- 稳定性：是稳定的，因为只会将较大的元素向右移动，不会打乱相等元素的顺序。\n\n**归并排序（Merge Sort）**：\n\n- 递归地将数组分成两部分，然后合并时保持稳定性。\n- 稳定性：是稳定的，因为在合并过程中可以确保相等元素按原始顺序排列。\n\n**计数排序（Counting Sort）**：\n\n- 使用额外的计数数组来记录每个元素的出现次数，然后依次将元素放回原数组。\n- 稳定性：是稳定的，因为在放回元素时保持了它们的原始顺序。\n\n**基数排序（Radix Sort）**：\n\n- 逐位排序，通常从最低有效位到最高有效位，使用稳定的子排序算法（如计数排序）。\n- 稳定性：是稳定的，因为它依赖于稳定的子排序算法。\n\n\n\n#### 不稳定 \n\n**快速排序（Quick Sort）**：\n\n- 基于分治法，选择一个主元，然后对数组进行划分。\n- 不稳定性：分区过程中，可能会打乱相等元素的顺序。\n\n**堆排序（Heap Sort）**：\n\n- 基于堆数据结构，首先构建最大堆，然后不断提取最大元素。\n- 不稳定性：由于堆的重构过程，可能会打乱相等元素的顺序\n\n**希尔排序（shell sort）:**\n\n​\t 基于插入排序的 不稳定\n\n#### 寄！\n\n### 异常捕获\n\n```c++\nclass MyException {};\nclass derivedException : public MyException {};\n\nvoid func(){\n  throw deriveexception();\n}\n\nint main(){\n  try{\n    func();\n  }\n  catch(MyException &e){\n    cout << \"MyException\" << endl;\n  }\n  catch(derivedException &e){\n    cout << \"derivedException\" << endl;\n  }\n}\n```\n\n会输出什么信息？\n\n只会输出 `\"MyException\"`\n\n#### 为什么？ -  **异常处理的顺序**：\n\n在异常处理机制中，如果先捕获基类的异常，所有派生自它的异常也会被捕获，导致派生类的异常处理代码被跳过。因此，应该先捕获 `derivedException`，然后再捕获 `MyException`。\n\n#### 寄\n\n### TCP与UDP\n\n\n\n## 编程   \n\n### 模拟\n\n> 米小游有一个长度为 n 的数组，其中第 i 个元素为 ai。现在定义数组的价值是最大的相邻数字的乘积。例如数组为 [3,5,1,2] ，相邻元素的乘积分别是 3*5=15,5*1=5和1*2=2 ，则数组的价值是这些数字中的最大值，即 15。\n>\n> 现在米小游想要任选数组中的某两个相邻的元素进行交换（**你必须使用这次交换机会**），他想知道最大可以将数组的价值更改为多少\n\n从前往后遍历，两种情况\n\n```c++\nfor(int i = 0;i + 1 < nums.size() ;i++){\n   ans = max(ans, nums[i] * nums[i + 1]);\n}\n```\n\na b c\n\n对应于不换或者换相邻的两个 也就是计算 ab bc 的值，\n\n\n\n```c++\nfor(int i = 0;i + 2 < nums.size();i++){\n  ans = max(ans, nums[i] * nums[i + 2]);\n}\n```\n\n对应于 ac\n\n\n\n<mark>唯一需要注意的点就是，乘法可能结果很大，所以需要选用long long </mark>\n\n启示:\n\n<font color = 'blue'>对于C++的ACM模式而言，选用存储结果的数据类型可以直接使用long long，以后一定要注意返回的结果用什么类型的变量存储 </font>\n\n### dfs","slug":"mhy_笔试","published":1,"date":"2024-08-03T15:31:29.712Z","updated":"2024-08-03T17:27:24.202Z","_id":"clzeak54k0000kxjk2tft6rrq","comments":1,"layout":"post","photos":[],"content":"<p>mhy8.3 笔试回顾</p>\n<h2 id=\"选择题\"><a href=\"#选择题\" class=\"headerlink\" title=\"选择题\"></a>选择题</h2><h3 id=\"流水线的执行时间计算\"><a href=\"#流水线的执行时间计算\" class=\"headerlink\" title=\"流水线的执行时间计算\"></a>流水线的执行时间计算</h3><blockquote>\n<p>有8个磁盘块需要处理，现在有一个缓存大小和一个磁盘块一样，磁盘块搬移到缓存需要80ms， 缓存搬移到cpu需要40ms，cpu处理这个磁盘块的数据需要60ms，流水线架构需要多长时间完成？</p>\n<p>如果换成双缓存，需要多长时间？</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/202408040053939.png\"></p>\n<p>所以答案是 (80 + 40) * 8 + 60  &#x3D; 1020 ms</p>\n<p>如果是双缓冲的话是多少呢？</p>\n<p><img src=\"https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804005551.png\"> </p>\n<p>所以答案是 80 * 8 + 40 + 60 &#x3D; 740 ms</p>\n<p>总结</p>\n<p> 把图画出来 分析清楚各个stage如何链接就可以了</p>\n<p>流水线的思想就是 一个过程如果可以被划分成实际的多个小过程，就可以使用流水线，使得每个模块都尽量不空转😈，进而提升吞吐率</p>\n<p>距离就是 洗衣服40min-烘干30min-折叠衣服20min</p>\n<p>如果有5桶衣服，洗第一桶衣服走完整个流程 也就是折叠完第一桶衣服之后才去 提第二桶衣服放到洗衣机里面洗 （问题在哪？ 在折叠衣服的时候， 洗衣机没有人用！浪费时间）</p>\n<p>还有笔者 小时候学校考的一道题， 大意是用一口锅烙饼，也是使用的流水线思想来提升效率；</p>\n<h3 id=\"稳定的排序算法\"><a href=\"#稳定的排序算法\" class=\"headerlink\" title=\"稳定的排序算法\"></a>稳定的排序算法</h3><h4 id=\"什么是稳定？\"><a href=\"#什么是稳定？\" class=\"headerlink\" title=\"什么是稳定？\"></a>什么是稳定？</h4><p><strong>稳定的排序算法</strong>是一种在排序过程中<mark>不会改变具有相等键值的元素的相对顺序的算法。</mark></p>\n<p>换句话说，如果在未排序的数据中有两个元素A和B，它们的值相等，并且在排序前A在B之前，那么在排序完成后A仍然会在B之前。</p>\n<h4 id=\"稳定具体有哪些？\"><a href=\"#稳定具体有哪些？\" class=\"headerlink\" title=\"稳定具体有哪些？\"></a>稳定具体有哪些？</h4><p><strong>冒泡排序（Bubble Sort）</strong>：</p>\n<ul>\n<li>每次比较相邻的元素并交换它们，直到整个数组有序。</li>\n<li>稳定性：是稳定的，因为只有在前一个元素大于后一个元素时才会交换。</li>\n</ul>\n<p><strong>插入排序（Insertion Sort）</strong>：</p>\n<ul>\n<li>从数组的第二个元素开始，依次将每个元素插入到已经排序的部分中。</li>\n<li>稳定性：是稳定的，因为只会将较大的元素向右移动，不会打乱相等元素的顺序。</li>\n</ul>\n<p><strong>归并排序（Merge Sort）</strong>：</p>\n<ul>\n<li>递归地将数组分成两部分，然后合并时保持稳定性。</li>\n<li>稳定性：是稳定的，因为在合并过程中可以确保相等元素按原始顺序排列。</li>\n</ul>\n<p><strong>计数排序（Counting Sort）</strong>：</p>\n<ul>\n<li>使用额外的计数数组来记录每个元素的出现次数，然后依次将元素放回原数组。</li>\n<li>稳定性：是稳定的，因为在放回元素时保持了它们的原始顺序。</li>\n</ul>\n<p><strong>基数排序（Radix Sort）</strong>：</p>\n<ul>\n<li>逐位排序，通常从最低有效位到最高有效位，使用稳定的子排序算法（如计数排序）。</li>\n<li>稳定性：是稳定的，因为它依赖于稳定的子排序算法。</li>\n</ul>\n<h4 id=\"不稳定\"><a href=\"#不稳定\" class=\"headerlink\" title=\"不稳定\"></a>不稳定</h4><p><strong>快速排序（Quick Sort）</strong>：</p>\n<ul>\n<li>基于分治法，选择一个主元，然后对数组进行划分。</li>\n<li>不稳定性：分区过程中，可能会打乱相等元素的顺序。</li>\n</ul>\n<p><strong>堆排序（Heap Sort）</strong>：</p>\n<ul>\n<li>基于堆数据结构，首先构建最大堆，然后不断提取最大元素。</li>\n<li>不稳定性：由于堆的重构过程，可能会打乱相等元素的顺序</li>\n</ul>\n<p><strong>希尔排序（shell sort）:</strong></p>\n<p>​\t 基于插入排序的 不稳定</p>\n<h4 id=\"寄！\"><a href=\"#寄！\" class=\"headerlink\" title=\"寄！\"></a>寄！</h4><h3 id=\"异常捕获\"><a href=\"#异常捕获\" class=\"headerlink\" title=\"异常捕获\"></a>异常捕获</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyException</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">derivedException</span> : <span class=\"keyword\">public</span> MyException &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"built_in\">deriveexception</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(MyException &amp;e)&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;MyException&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(derivedException &amp;e)&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;derivedException&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会输出什么信息？</p>\n<p>只会输出 <code>&quot;MyException&quot;</code></p>\n<h4 id=\"为什么？-异常处理的顺序：\"><a href=\"#为什么？-异常处理的顺序：\" class=\"headerlink\" title=\"为什么？ -  异常处理的顺序：\"></a>为什么？ -  <strong>异常处理的顺序</strong>：</h4><p>在异常处理机制中，如果先捕获基类的异常，所有派生自它的异常也会被捕获，导致派生类的异常处理代码被跳过。因此，应该先捕获 <code>derivedException</code>，然后再捕获 <code>MyException</code>。</p>\n<h4 id=\"寄\"><a href=\"#寄\" class=\"headerlink\" title=\"寄\"></a>寄</h4><h3 id=\"TCP与UDP\"><a href=\"#TCP与UDP\" class=\"headerlink\" title=\"TCP与UDP\"></a>TCP与UDP</h3><h2 id=\"编程\"><a href=\"#编程\" class=\"headerlink\" title=\"编程\"></a>编程</h2><h3 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h3><blockquote>\n<p>米小游有一个长度为 n 的数组，其中第 i 个元素为 ai。现在定义数组的价值是最大的相邻数字的乘积。例如数组为 [3,5,1,2] ，相邻元素的乘积分别是 3<em>5&#x3D;15,5</em>1&#x3D;5和1*2&#x3D;2 ，则数组的价值是这些数字中的最大值，即 15。</p>\n<p>现在米小游想要任选数组中的某两个相邻的元素进行交换（<strong>你必须使用这次交换机会</strong>），他想知道最大可以将数组的价值更改为多少</p>\n</blockquote>\n<p>从前往后遍历，两种情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i + <span class=\"number\">1</span> &lt; nums.<span class=\"built_in\">size</span>() ;i++)&#123;</span><br><span class=\"line\">   ans = <span class=\"built_in\">max</span>(ans, nums[i] * nums[i + <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>a b c</p>\n<p>对应于不换或者换相邻的两个 也就是计算 ab bc 的值，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i + <span class=\"number\">2</span> &lt; nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">  ans = <span class=\"built_in\">max</span>(ans, nums[i] * nums[i + <span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应于 ac</p>\n<p><mark>唯一需要注意的点就是，乘法可能结果很大，所以需要选用long long </mark></p>\n<p>启示:</p>\n<p><font color = 'blue'>对于C++的ACM模式而言，选用存储结果的数据类型可以直接使用long long，以后一定要注意返回的结果用什么类型的变量存储 </font></p>\n<h3 id=\"dfs\"><a href=\"#dfs\" class=\"headerlink\" title=\"dfs\"></a>dfs</h3>","cover":false,"excerpt":"","more":"<p>mhy8.3 笔试回顾</p>\n<h2 id=\"选择题\"><a href=\"#选择题\" class=\"headerlink\" title=\"选择题\"></a>选择题</h2><h3 id=\"流水线的执行时间计算\"><a href=\"#流水线的执行时间计算\" class=\"headerlink\" title=\"流水线的执行时间计算\"></a>流水线的执行时间计算</h3><blockquote>\n<p>有8个磁盘块需要处理，现在有一个缓存大小和一个磁盘块一样，磁盘块搬移到缓存需要80ms， 缓存搬移到cpu需要40ms，cpu处理这个磁盘块的数据需要60ms，流水线架构需要多长时间完成？</p>\n<p>如果换成双缓存，需要多长时间？</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/202408040053939.png\"></p>\n<p>所以答案是 (80 + 40) * 8 + 60  &#x3D; 1020 ms</p>\n<p>如果是双缓冲的话是多少呢？</p>\n<p><img src=\"https://raw.githubusercontent.com/jeycechen/jeycechen_pics_bed/main/20240804005551.png\"> </p>\n<p>所以答案是 80 * 8 + 40 + 60 &#x3D; 740 ms</p>\n<p>总结</p>\n<p> 把图画出来 分析清楚各个stage如何链接就可以了</p>\n<p>流水线的思想就是 一个过程如果可以被划分成实际的多个小过程，就可以使用流水线，使得每个模块都尽量不空转😈，进而提升吞吐率</p>\n<p>距离就是 洗衣服40min-烘干30min-折叠衣服20min</p>\n<p>如果有5桶衣服，洗第一桶衣服走完整个流程 也就是折叠完第一桶衣服之后才去 提第二桶衣服放到洗衣机里面洗 （问题在哪？ 在折叠衣服的时候， 洗衣机没有人用！浪费时间）</p>\n<p>还有笔者 小时候学校考的一道题， 大意是用一口锅烙饼，也是使用的流水线思想来提升效率；</p>\n<h3 id=\"稳定的排序算法\"><a href=\"#稳定的排序算法\" class=\"headerlink\" title=\"稳定的排序算法\"></a>稳定的排序算法</h3><h4 id=\"什么是稳定？\"><a href=\"#什么是稳定？\" class=\"headerlink\" title=\"什么是稳定？\"></a>什么是稳定？</h4><p><strong>稳定的排序算法</strong>是一种在排序过程中<mark>不会改变具有相等键值的元素的相对顺序的算法。</mark></p>\n<p>换句话说，如果在未排序的数据中有两个元素A和B，它们的值相等，并且在排序前A在B之前，那么在排序完成后A仍然会在B之前。</p>\n<h4 id=\"稳定具体有哪些？\"><a href=\"#稳定具体有哪些？\" class=\"headerlink\" title=\"稳定具体有哪些？\"></a>稳定具体有哪些？</h4><p><strong>冒泡排序（Bubble Sort）</strong>：</p>\n<ul>\n<li>每次比较相邻的元素并交换它们，直到整个数组有序。</li>\n<li>稳定性：是稳定的，因为只有在前一个元素大于后一个元素时才会交换。</li>\n</ul>\n<p><strong>插入排序（Insertion Sort）</strong>：</p>\n<ul>\n<li>从数组的第二个元素开始，依次将每个元素插入到已经排序的部分中。</li>\n<li>稳定性：是稳定的，因为只会将较大的元素向右移动，不会打乱相等元素的顺序。</li>\n</ul>\n<p><strong>归并排序（Merge Sort）</strong>：</p>\n<ul>\n<li>递归地将数组分成两部分，然后合并时保持稳定性。</li>\n<li>稳定性：是稳定的，因为在合并过程中可以确保相等元素按原始顺序排列。</li>\n</ul>\n<p><strong>计数排序（Counting Sort）</strong>：</p>\n<ul>\n<li>使用额外的计数数组来记录每个元素的出现次数，然后依次将元素放回原数组。</li>\n<li>稳定性：是稳定的，因为在放回元素时保持了它们的原始顺序。</li>\n</ul>\n<p><strong>基数排序（Radix Sort）</strong>：</p>\n<ul>\n<li>逐位排序，通常从最低有效位到最高有效位，使用稳定的子排序算法（如计数排序）。</li>\n<li>稳定性：是稳定的，因为它依赖于稳定的子排序算法。</li>\n</ul>\n<h4 id=\"不稳定\"><a href=\"#不稳定\" class=\"headerlink\" title=\"不稳定\"></a>不稳定</h4><p><strong>快速排序（Quick Sort）</strong>：</p>\n<ul>\n<li>基于分治法，选择一个主元，然后对数组进行划分。</li>\n<li>不稳定性：分区过程中，可能会打乱相等元素的顺序。</li>\n</ul>\n<p><strong>堆排序（Heap Sort）</strong>：</p>\n<ul>\n<li>基于堆数据结构，首先构建最大堆，然后不断提取最大元素。</li>\n<li>不稳定性：由于堆的重构过程，可能会打乱相等元素的顺序</li>\n</ul>\n<p><strong>希尔排序（shell sort）:</strong></p>\n<p>​\t 基于插入排序的 不稳定</p>\n<h4 id=\"寄！\"><a href=\"#寄！\" class=\"headerlink\" title=\"寄！\"></a>寄！</h4><h3 id=\"异常捕获\"><a href=\"#异常捕获\" class=\"headerlink\" title=\"异常捕获\"></a>异常捕获</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyException</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">derivedException</span> : <span class=\"keyword\">public</span> MyException &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"built_in\">deriveexception</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(MyException &amp;e)&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;MyException&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">catch</span>(derivedException &amp;e)&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;derivedException&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会输出什么信息？</p>\n<p>只会输出 <code>&quot;MyException&quot;</code></p>\n<h4 id=\"为什么？-异常处理的顺序：\"><a href=\"#为什么？-异常处理的顺序：\" class=\"headerlink\" title=\"为什么？ -  异常处理的顺序：\"></a>为什么？ -  <strong>异常处理的顺序</strong>：</h4><p>在异常处理机制中，如果先捕获基类的异常，所有派生自它的异常也会被捕获，导致派生类的异常处理代码被跳过。因此，应该先捕获 <code>derivedException</code>，然后再捕获 <code>MyException</code>。</p>\n<h4 id=\"寄\"><a href=\"#寄\" class=\"headerlink\" title=\"寄\"></a>寄</h4><h3 id=\"TCP与UDP\"><a href=\"#TCP与UDP\" class=\"headerlink\" title=\"TCP与UDP\"></a>TCP与UDP</h3><h2 id=\"编程\"><a href=\"#编程\" class=\"headerlink\" title=\"编程\"></a>编程</h2><h3 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h3><blockquote>\n<p>米小游有一个长度为 n 的数组，其中第 i 个元素为 ai。现在定义数组的价值是最大的相邻数字的乘积。例如数组为 [3,5,1,2] ，相邻元素的乘积分别是 3<em>5&#x3D;15,5</em>1&#x3D;5和1*2&#x3D;2 ，则数组的价值是这些数字中的最大值，即 15。</p>\n<p>现在米小游想要任选数组中的某两个相邻的元素进行交换（<strong>你必须使用这次交换机会</strong>），他想知道最大可以将数组的价值更改为多少</p>\n</blockquote>\n<p>从前往后遍历，两种情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i + <span class=\"number\">1</span> &lt; nums.<span class=\"built_in\">size</span>() ;i++)&#123;</span><br><span class=\"line\">   ans = <span class=\"built_in\">max</span>(ans, nums[i] * nums[i + <span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>a b c</p>\n<p>对应于不换或者换相邻的两个 也就是计算 ab bc 的值，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i + <span class=\"number\">2</span> &lt; nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">  ans = <span class=\"built_in\">max</span>(ans, nums[i] * nums[i + <span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应于 ac</p>\n<p><mark>唯一需要注意的点就是，乘法可能结果很大，所以需要选用long long </mark></p>\n<p>启示:</p>\n<p><font color = 'blue'>对于C++的ACM模式而言，选用存储结果的数据类型可以直接使用long long，以后一定要注意返回的结果用什么类型的变量存储 </font></p>\n<h3 id=\"dfs\"><a href=\"#dfs\" class=\"headerlink\" title=\"dfs\"></a>dfs</h3>"},{"title":"静态和动态链接","date":"2024-08-03T16:17:33.000Z","catagories":["计算机组成原理"],"_content":"","source":"_posts/静态和动态链接.md","raw":"---\ntitle: 静态和动态链接\ndate: 2024-08-04 00:17:33\ncatagories: \n- 计算机组成原理\ntags:\n- 静态链接\n- 动态链接\n- GOT和PLT\n- 程序加载\n---\n","slug":"静态和动态链接","published":1,"updated":"2024-08-03T17:30:17.503Z","_id":"clzeeswh80000hsjkcr6y6dlr","comments":1,"layout":"post","photos":[],"content":"","cover":false,"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"clzeak54k0000kxjk2tft6rrq","category_id":"clzebsudg00014mjk36173jd6","_id":"clzebsudi00034mjk6dpy1e0r"},{"post_id":"clut6jjd20000k6vkcg7wax8j","category_id":"clzebsudg00014mjk36173jd6","_id":"clzebsudi00044mjkcunh9737"}],"PostTag":[{"post_id":"clzeak54k0000kxjk2tft6rrq","tag_id":"clzecav550000xajk9qcn115o","_id":"clzecav570005xajk25mjhl6k"},{"post_id":"clzeak54k0000kxjk2tft6rrq","tag_id":"clzecav570001xajk8m0xdi9w","_id":"clzecav580006xajkfijw43g0"},{"post_id":"clzeak54k0000kxjk2tft6rrq","tag_id":"clzecav570002xajkbiol0s7s","_id":"clzecav580007xajkhtreczn1"},{"post_id":"clzeak54k0000kxjk2tft6rrq","tag_id":"clzecav570003xajk8b35cnmu","_id":"clzecav580008xajk3rrm2ki8"},{"post_id":"clzeak54k0000kxjk2tft6rrq","tag_id":"clzecav570004xajke3nxecy4","_id":"clzecav580009xajkaiukbt41"},{"post_id":"clzeeswh80000hsjkcr6y6dlr","tag_id":"clzeeswhc0001hsjkf8i023f1","_id":"clzeeswhe0005hsjkc1i228tu"},{"post_id":"clzeeswh80000hsjkcr6y6dlr","tag_id":"clzeeswhd0002hsjk89tkd7ge","_id":"clzeeswhe0006hsjkf4e8ht8u"},{"post_id":"clzeeswh80000hsjkcr6y6dlr","tag_id":"clzeeswhe0003hsjk97h525uc","_id":"clzeeswhf0007hsjk37abajbq"},{"post_id":"clzeeswh80000hsjkcr6y6dlr","tag_id":"clzeeswhe0004hsjk02as6mwh","_id":"clzeeswhf0008hsjk33405z6z"}],"Tag":[{"name":"流水线","_id":"clzecav550000xajk9qcn115o"},{"name":"排序","_id":"clzecav570001xajk8m0xdi9w"},{"name":"异常处理","_id":"clzecav570002xajkbiol0s7s"},{"name":"TCP UDP","_id":"clzecav570003xajk8b35cnmu"},{"name":"面试 && 笔试","_id":"clzecav570004xajke3nxecy4"},{"name":"静态链接","_id":"clzeeswhc0001hsjkf8i023f1"},{"name":"动态链接","_id":"clzeeswhd0002hsjk89tkd7ge"},{"name":"GOT和PLT","_id":"clzeeswhe0003hsjk97h525uc"},{"name":"程序加载","_id":"clzeeswhe0004hsjk02as6mwh"}]}}